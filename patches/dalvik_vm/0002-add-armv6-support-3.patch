From cd3ab1e9ef8c5d571c440261c055e522430b6a4d Mon Sep 17 00:00:00 2001
From: Lalit Maganti <lalitmaganti@gmail.com>
Date: Thu, 12 Jul 2012 00:40:26 -0700
Subject: [PATCH] dalvik: Update ARMv6 code to compile and bring in line with
 ARMv5

Change-Id: I2764002422ade74db602cc2292108ed67241f0be
---
 vm/compiler/codegen/arm/armv6-vfp/ArchVariant.cpp |    4 +-
 vm/compiler/codegen/arm/armv6j/ArchVariant.cpp    |    4 +-
 vm/mterp/config-armv6-vfp                         |    2 -
 vm/mterp/config-armv6j                            |    1 -
 vm/mterp/out/InterpAsm-armv6-vfp.S                |15204 +++-----------------
 vm/mterp/out/InterpAsm-armv6j.S                   |15444 ++++-----------------
 vm/mterp/out/InterpC-armv6-vfp.cpp                |  139 +-
 vm/mterp/out/InterpC-armv6j.cpp                   |  139 +-
 8 files changed, 4756 insertions(+), 26181 deletions(-)

diff --git a/vm/compiler/codegen/arm/armv6-vfp/ArchVariant.cpp b/vm/compiler/codegen/arm/armv6-vfp/ArchVariant.cpp
index 5188417..3b5c083 100644
--- a/vm/compiler/codegen/arm/armv6-vfp/ArchVariant.cpp
+++ b/vm/compiler/codegen/arm/armv6-vfp/ArchVariant.cpp
@@ -77,7 +77,7 @@ bool dvmCompilerArchVariantInit(void)
      */
     if ((offsetof(Thread, jitToInterpEntries) +
          sizeof(struct JitToInterpEntries)) >= 128) {
-        LOGE("Thread.jitToInterpEntries size overflow");
+        ALOGE("Thread.jitToInterpEntries size overflow");
         dvmAbort();
     }
 
@@ -98,7 +98,7 @@ int dvmCompilerTargetOptHint(int key)
             res = 2;
             break;
         default:
-            LOGE("Unknown target optimization hint key: %d",key);
+            ALOGE("Unknown target optimization hint key: %d",key);
             res = 0;
     }
     return res;
diff --git a/vm/compiler/codegen/arm/armv6j/ArchVariant.cpp b/vm/compiler/codegen/arm/armv6j/ArchVariant.cpp
index f394aa1..f2d4815 100644
--- a/vm/compiler/codegen/arm/armv6j/ArchVariant.cpp
+++ b/vm/compiler/codegen/arm/armv6j/ArchVariant.cpp
@@ -77,7 +77,7 @@ bool dvmCompilerArchVariantInit(void)
      */
     if ((offsetof(Thread, jitToInterpEntries) +
          sizeof(struct JitToInterpEntries)) >= 128) {
-        LOGE("Thread.jitToInterpEntries size overflow");
+        ALOGE("Thread.jitToInterpEntries size overflow");
         dvmAbort();
     }
 
@@ -98,7 +98,7 @@ int dvmCompilerTargetOptHint(int key)
             res = 2;
             break;
         default:
-            LOGE("Unknown target optimization hint key: %d",key);
+            ALOGE("Unknown target optimization hint key: %d",key);
             res = 0;
     }
     return res;
diff --git a/vm/mterp/config-armv6-vfp b/vm/mterp/config-armv6-vfp
index 2cdcc31..d47b9e5 100644
--- a/vm/mterp/config-armv6-vfp
+++ b/vm/mterp/config-armv6-vfp
@@ -74,8 +74,6 @@ op-start armv5te
     op OP_SUB_FLOAT arm-vfp
     op OP_SUB_FLOAT_2ADDR arm-vfp
 
-    alt OP_DISPATCH_FF armv5te
-
     # use trivial integer operation
     #op OP_NEG_DOUBLE armv5te
     #op OP_NEG_FLOAT armv5te
diff --git a/vm/mterp/config-armv6j b/vm/mterp/config-armv6j
index 3718c0a..6215780 100644
--- a/vm/mterp/config-armv6j
+++ b/vm/mterp/config-armv6j
@@ -44,7 +44,6 @@ import armv5te/entry.S
 # opcode list; argument to op-start is default directory
 op-start armv5te
     #op OP_FILL_ARRAY_DATA c
-    alt OP_DISPATCH_FF armv5te
 
     # use trivial integer operation
     op OP_NEG_DOUBLE armv5te
diff --git a/vm/mterp/out/InterpAsm-armv6-vfp.S b/vm/mterp/out/InterpAsm-armv6-vfp.S
index 6847f28..1cd2240 100644
--- a/vm/mterp/out/InterpAsm-armv6-vfp.S
+++ b/vm/mterp/out/InterpAsm-armv6-vfp.S
@@ -7700,12642 +7700,2057 @@ dalvik_inst:
 
 /* ------------------------------ */
     .balign 64
-.L_OP_DISPATCH_FF: /* 0xff */
-/* File: armv5te/OP_DISPATCH_FF.S */
-    mov     ip, rINST, lsr #8           @ ip<- extended opcode
-    add     ip, ip, #256                @ add offset for extended opcodes
-    GOTO_OPCODE(ip)                     @ go to proper extended handler
+.L_OP_UNUSED_FF: /* 0xff */
+/* File: armv5te/OP_UNUSED_FF.S */
+/* File: armv5te/unused.S */
+    bl      common_abort
 
 
-/* ------------------------------ */
     .balign 64
-.L_OP_CONST_CLASS_JUMBO: /* 0x100 */
-/* File: armv5te/OP_CONST_CLASS_JUMBO.S */
-    /* const-class/jumbo vBBBB, Class@AAAAAAAA */
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<-self>methodClassDex
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r2, [r2, #offDvmDex_pResClasses]   @ r2<- dvmDex->pResClasses
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    FETCH(r9, 3)                        @ r9<- BBBB
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- pResClasses[AAAAaaaa]
-    cmp     r0, #0                      @ not yet resolved?
-    beq     .LOP_CONST_CLASS_JUMBO_resolve
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r9)                    @ vBBBB<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+    .size   dvmAsmInstructionStart, .-dvmAsmInstructionStart
+    .global dvmAsmInstructionEnd
+dvmAsmInstructionEnd:
+
+/*
+ * ===========================================================================
+ *  Sister implementations
+ * ===========================================================================
+ */
+    .global dvmAsmSisterStart
+    .type   dvmAsmSisterStart, %function
+    .text
+    .balign 4
+dvmAsmSisterStart:
+
+/* continuation for OP_CONST_STRING */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_CHECK_CAST_JUMBO: /* 0x101 */
-/* File: armv5te/OP_CHECK_CAST_JUMBO.S */
     /*
-     * Check to see if a cast from one class to another is allowed.
+     * Continuation if the String has not yet been resolved.
+     *  r1: BBBB (String ref)
+     *  r9: target register
      */
-    /* check-cast/jumbo vBBBB, class@AAAAAAAA */
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r3, 3)                        @ r3<- BBBB
-    orr     r2, r0, r2, lsl #16         @ r2<- AAAAaaaa
-    GET_VREG(r9, r3)                    @ r9<- object
-    ldr     r0, [rSELF, #offThread_methodClassDex]    @ r0<- pDvmDex
-    cmp     r9, #0                      @ is object null?
-    ldr     r0, [r0, #offDvmDex_pResClasses]    @ r0<- pDvmDex->pResClasses
-    beq     .LOP_CHECK_CAST_JUMBO_okay            @ null obj, cast always succeeds
-    ldr     r1, [r0, r2, lsl #2]        @ r1<- resolved class
-    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz
-    cmp     r1, #0                      @ have we resolved this before?
-    beq     .LOP_CHECK_CAST_JUMBO_resolve         @ not resolved, do it now
-.LOP_CHECK_CAST_JUMBO_resolved:
-    cmp     r0, r1                      @ same class (trivial success)?
-    bne     .LOP_CHECK_CAST_JUMBO_fullcheck       @ no, do full check
-    b       .LOP_CHECK_CAST_JUMBO_okay            @ yes, finish up
+.LOP_CONST_STRING_resolve:
+    EXPORT_PC()
+    ldr     r0, [rSELF, #offThread_method] @ r0<- self->method
+    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveString            @ r0<- String reference
+    cmp     r0, #0                      @ failed?
+    beq     common_exceptionThrown      @ yup, handle the exception
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r9)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_CONST_STRING_JUMBO */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_INSTANCE_OF_JUMBO: /* 0x102 */
-/* File: armv5te/OP_INSTANCE_OF_JUMBO.S */
     /*
-     * Check to see if an object reference is an instance of a class.
-     *
-     * Most common situation is a non-null object, being compared against
-     * an already-resolved class.
-     *
-     * TODO: convert most of this into a common subroutine, shared with
-     *       OP_INSTANCE_OF.S.
+     * Continuation if the String has not yet been resolved.
+     *  r1: BBBBBBBB (String ref)
+     *  r9: target register
      */
-    /* instance-of/jumbo vBBBB, vCCCC, class@AAAAAAAA */
-    FETCH(r3, 4)                        @ r3<- vCCCC
-    FETCH(r9, 3)                        @ r9<- vBBBB
-    GET_VREG(r0, r3)                    @ r0<- vCCCC (object)
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- pDvmDex
-    cmp     r0, #0                      @ is object null?
-    beq     .LOP_INSTANCE_OF_JUMBO_store           @ null obj, not an instance, store r0
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r3, 2)                        @ r3<- AAAA (hi)
-    ldr     r2, [r2, #offDvmDex_pResClasses]    @ r2<- pDvmDex->pResClasses
-    orr     r3, r1, r3, lsl #16         @ r3<- AAAAaaaa
-    ldr     r1, [r2, r3, lsl #2]        @ r1<- resolved class
-    ldr     r0, [r0, #offObject_clazz]  @ r0<- obj->clazz
-    cmp     r1, #0                      @ have we resolved this before?
-    beq     .LOP_INSTANCE_OF_JUMBO_resolve         @ not resolved, do it now
-    b       .LOP_INSTANCE_OF_JUMBO_resolved        @ resolved, continue
+.LOP_CONST_STRING_JUMBO_resolve:
+    EXPORT_PC()
+    ldr     r0, [rSELF, #offThread_method] @ r0<- self->method
+    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveString            @ r0<- String reference
+    cmp     r0, #0                      @ failed?
+    beq     common_exceptionThrown      @ yup, handle the exception
+    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r9)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_CONST_CLASS */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_NEW_INSTANCE_JUMBO: /* 0x103 */
-/* File: armv5te/OP_NEW_INSTANCE_JUMBO.S */
     /*
-     * Create a new instance of a class.
+     * Continuation if the Class has not yet been resolved.
+     *  r1: BBBB (Class ref)
+     *  r9: target register
      */
-    /* new-instance/jumbo vBBBB, class@AAAAAAAA */
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- pDvmDex
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r3, [r3, #offDvmDex_pResClasses]    @ r3<- pDvmDex->pResClasses
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved class
-#if defined(WITH_JIT)
-    add     r10, r3, r1, lsl #2         @ r10<- &resolved_class
-#endif
-    EXPORT_PC()                         @ req'd for init, resolve, alloc
-    cmp     r0, #0                      @ already resolved?
-    beq     .LOP_NEW_INSTANCE_JUMBO_resolve         @ no, resolve it now
-.LOP_NEW_INSTANCE_JUMBO_resolved:   @ r0=class
-    ldrb    r1, [r0, #offClassObject_status]    @ r1<- ClassStatus enum
-    cmp     r1, #CLASS_INITIALIZED      @ has class been initialized?
-    bne     .LOP_NEW_INSTANCE_JUMBO_needinit        @ no, init class now
-.LOP_NEW_INSTANCE_JUMBO_initialized: @ r0=class
-    mov     r1, #ALLOC_DONT_TRACK       @ flags for alloc call
-    bl      dvmAllocObject              @ r0<- new object
-    b       .LOP_NEW_INSTANCE_JUMBO_finish          @ continue
+.LOP_CONST_CLASS_resolve:
+    EXPORT_PC()
+    ldr     r0, [rSELF, #offThread_method] @ r0<- self->method
+    mov     r2, #1                      @ r2<- true
+    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveClass             @ r0<- Class reference
+    cmp     r0, #0                      @ failed?
+    beq     common_exceptionThrown      @ yup, handle the exception
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r9)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_CHECK_CAST */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_NEW_ARRAY_JUMBO: /* 0x104 */
-/* File: armv5te/OP_NEW_ARRAY_JUMBO.S */
     /*
-     * Allocate an array of objects, specified with the array class
-     * and a count.
-     *
-     * The verifier guarantees that this is an array class, so we don't
-     * check for it here.
+     * Trivial test failed, need to perform full check.  This is common.
+     *  r0 holds obj->clazz
+     *  r1 holds desired class resolved from BBBB
+     *  r9 holds object
      */
-    /* new-array/jumbo vBBBB, vCCCC, class@AAAAAAAA */
-    FETCH(r2, 1)                        @ r2<- aaaa (lo)
-    FETCH(r3, 2)                        @ r3<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- vCCCC
-    orr     r2, r2, r3, lsl #16         @ r2<- AAAAaaaa
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- pDvmDex
-    GET_VREG(r1, r0)                    @ r1<- vCCCC (array length)
-    ldr     r3, [r3, #offDvmDex_pResClasses]    @ r3<- pDvmDex->pResClasses
-    cmp     r1, #0                      @ check length
-    ldr     r0, [r3, r2, lsl #2]        @ r0<- resolved class
-    bmi     common_errNegativeArraySize @ negative length, bail - len in r1
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ req'd for resolve, alloc
-    bne     .LOP_NEW_ARRAY_JUMBO_finish          @ resolved, continue
-    b       .LOP_NEW_ARRAY_JUMBO_resolve         @ do resolve now
+.LOP_CHECK_CAST_fullcheck:
+    mov     r10, r1                     @ avoid ClassObject getting clobbered
+    bl      dvmInstanceofNonTrivial     @ r0<- boolean result
+    cmp     r0, #0                      @ failed?
+    bne     .LOP_CHECK_CAST_okay            @ no, success
+
+    @ A cast has failed.  We need to throw a ClassCastException.
+    EXPORT_PC()                         @ about to throw
+    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz (actual class)
+    mov     r1, r10                     @ r1<- desired class
+    bl      dvmThrowClassCastException
+    b       common_exceptionThrown
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_FILLED_NEW_ARRAY_JUMBO: /* 0x105 */
-/* File: armv5te/OP_FILLED_NEW_ARRAY_JUMBO.S */
     /*
-     * Create a new array with elements filled from registers.
+     * Resolution required.  This is the least-likely path.
      *
-     * TODO: convert most of this into a common subroutine, shared with
-     *       OP_FILLED_NEW_ARRAY.S.
+     *  r2 holds BBBB
+     *  r9 holds object
      */
-    /* filled-new-array/jumbo {vCCCC..v(CCCC+BBBB-1)}, type@AAAAAAAA */
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r3, [r3, #offDvmDex_pResClasses]    @ r3<- pDvmDex->pResClasses
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved class
-    EXPORT_PC()                         @ need for resolve and alloc
-    cmp     r0, #0                      @ already resolved?
-    bne     .LOP_FILLED_NEW_ARRAY_JUMBO_continue        @ yes, continue on
-8:  ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
+.LOP_CHECK_CAST_resolve:
+    EXPORT_PC()                         @ resolve() could throw
+    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
+    mov     r1, r2                      @ r1<- BBBB
     mov     r2, #0                      @ r2<- false
     ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- call(clazz, ref)
+    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
     cmp     r0, #0                      @ got null?
     beq     common_exceptionThrown      @ yes, handle exception
-    b       .LOP_FILLED_NEW_ARRAY_JUMBO_continue
+    mov     r1, r0                      @ r1<- class resolved from BBB
+    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz
+    b       .LOP_CHECK_CAST_resolved        @ pick up where we left off
+
+/* continuation for OP_INSTANCE_OF */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_JUMBO: /* 0x106 */
-/* File: armv5te/OP_IGET_JUMBO.S */
     /*
-     * Jumbo 32-bit instance field get.
-     *
-     * for: iget/jumbo, iget-object/jumbo, iget-boolean/jumbo, iget-byte/jumbo,
-     *      iget-char/jumbo, iget-short/jumbo
+     * Trivial test failed, need to perform full check.  This is common.
+     *  r0 holds obj->clazz
+     *  r1 holds class resolved from BBBB
+     *  r9 holds A
      */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_JUMBO_resolved        @ resolved, continue
+.LOP_INSTANCE_OF_fullcheck:
+    bl      dvmInstanceofNonTrivial     @ r0<- boolean result
+    @ fall through to OP_INSTANCE_OF_store
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_WIDE_JUMBO: /* 0x107 */
-/* File: armv5te/OP_IGET_WIDE_JUMBO.S */
     /*
-     * Jumbo 64-bit instance field get.
+     * r0 holds boolean result
+     * r9 holds A
      */
-    /* iget-wide/jumbo vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_WIDE_JUMBO_finish          @ no, already resolved
-    ldr     r2, [rSELF, #offThread_method] @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_WIDE_JUMBO_resolved        @ resolved, continue
+.LOP_INSTANCE_OF_store:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    SET_VREG(r0, r9)                    @ vA<- r0
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_OBJECT_JUMBO: /* 0x108 */
-/* File: armv5te/OP_IGET_OBJECT_JUMBO.S */
-/* File: armv5te/OP_IGET_JUMBO.S */
     /*
-     * Jumbo 32-bit instance field get.
-     *
-     * for: iget/jumbo, iget-object/jumbo, iget-boolean/jumbo, iget-byte/jumbo,
-     *      iget-char/jumbo, iget-short/jumbo
+     * Trivial test succeeded, save and bail.
+     *  r9 holds A
      */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_OBJECT_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_OBJECT_JUMBO_resolved        @ resolved, continue
-
+.LOP_INSTANCE_OF_trivial:
+    mov     r0, #1                      @ indicate success
+    @ could b OP_INSTANCE_OF_store, but copying is faster and cheaper
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    SET_VREG(r0, r9)                    @ vA<- r0
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_BOOLEAN_JUMBO: /* 0x109 */
-/* File: armv5te/OP_IGET_BOOLEAN_JUMBO.S */
-@include "armv5te/OP_IGET_JUMBO.S" { "load":"ldrb", "sqnum":"1" }
-/* File: armv5te/OP_IGET_JUMBO.S */
     /*
-     * Jumbo 32-bit instance field get.
+     * Resolution required.  This is the least-likely path.
      *
-     * for: iget/jumbo, iget-object/jumbo, iget-boolean/jumbo, iget-byte/jumbo,
-     *      iget-char/jumbo, iget-short/jumbo
+     *  r3 holds BBBB
+     *  r9 holds A
      */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_BOOLEAN_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+.LOP_INSTANCE_OF_resolve:
     EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_BOOLEAN_JUMBO_resolved        @ resolved, continue
+    ldr     r0, [rSELF, #offThread_method]    @ r0<- self->method
+    mov     r1, r3                      @ r1<- BBBB
+    mov     r2, #1                      @ r2<- true
+    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
+    cmp     r0, #0                      @ got null?
+    beq     common_exceptionThrown      @ yes, handle exception
+    mov     r1, r0                      @ r1<- class resolved from BBB
+    mov     r3, rINST, lsr #12          @ r3<- B
+    GET_VREG(r0, r3)                    @ r0<- vB (object)
+    ldr     r0, [r0, #offObject_clazz]  @ r0<- obj->clazz
+    b       .LOP_INSTANCE_OF_resolved        @ pick up where we left off
 
+/* continuation for OP_NEW_INSTANCE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_BYTE_JUMBO: /* 0x10a */
-/* File: armv5te/OP_IGET_BYTE_JUMBO.S */
-@include "armv5te/OP_IGET_JUMBO.S" { "load":"ldrsb", "sqnum":"2" }
-/* File: armv5te/OP_IGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit instance field get.
-     *
-     * for: iget/jumbo, iget-object/jumbo, iget-boolean/jumbo, iget-byte/jumbo,
-     *      iget-char/jumbo, iget-short/jumbo
-     */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_BYTE_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_BYTE_JUMBO_resolved        @ resolved, continue
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_CHAR_JUMBO: /* 0x10b */
-/* File: armv5te/OP_IGET_CHAR_JUMBO.S */
-@include "armv5te/OP_IGET_JUMBO.S" { "load":"ldrh", "sqnum":"3" }
-/* File: armv5te/OP_IGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit instance field get.
-     *
-     * for: iget/jumbo, iget-object/jumbo, iget-boolean/jumbo, iget-byte/jumbo,
-     *      iget-char/jumbo, iget-short/jumbo
-     */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_CHAR_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_CHAR_JUMBO_resolved        @ resolved, continue
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_SHORT_JUMBO: /* 0x10c */
-/* File: armv5te/OP_IGET_SHORT_JUMBO.S */
-@include "armv5te/OP_IGET_JUMBO.S" { "load":"ldrsh", "sqnum":"4" }
-/* File: armv5te/OP_IGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit instance field get.
-     *
-     * for: iget/jumbo, iget-object/jumbo, iget-boolean/jumbo, iget-byte/jumbo,
-     *      iget-char/jumbo, iget-short/jumbo
-     */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_SHORT_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_SHORT_JUMBO_resolved        @ resolved, continue
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_JUMBO: /* 0x10d */
-/* File: armv5te/OP_IPUT_JUMBO.S */
+    .balign 32                          @ minimize cache lines
+.LOP_NEW_INSTANCE_finish: @ r0=new object
+    mov     r3, rINST, lsr #8           @ r3<- AA
+    cmp     r0, #0                      @ failed?
+#if defined(WITH_JIT)
     /*
-     * Jumbo 32-bit instance field put.
-     *
-     * for: iput/jumbo, iput-boolean/jumbo, iput-byte/jumbo, iput-char/jumbo,
-     *      iput-short/jumbo
+     * The JIT needs the class to be fully resolved before it can
+     * include this instruction in a trace.
      */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_JUMBO_resolved        @ resolved, continue
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_WIDE_JUMBO: /* 0x10e */
-/* File: armv5te/OP_IPUT_WIDE_JUMBO.S */
-    /* iput-wide/jumbo vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_WIDE_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method] @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_WIDE_JUMBO_resolved        @ resolved, continue
+    ldrh    r1, [rSELF, #offThread_subMode]
+    beq     common_exceptionThrown      @ yes, handle the exception
+    ands    r1, #kSubModeJitTraceBuild  @ under construction?
+    bne     .LOP_NEW_INSTANCE_jitCheck
+#else
+    beq     common_exceptionThrown      @ yes, handle the exception
+#endif
+.LOP_NEW_INSTANCE_end:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r3)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_OBJECT_JUMBO: /* 0x10f */
-/* File: armv5te/OP_IPUT_OBJECT_JUMBO.S */
+#if defined(WITH_JIT)
     /*
-     * Jumbo 32-bit instance field put.
+     * Check to see if we need to stop the trace building early.
+     * r0: new object
+     * r3: vAA
      */
-    /* iput-object/jumbo vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_OBJECT_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_OBJECT_JUMBO_resolved        @ resolved, continue
+.LOP_NEW_INSTANCE_jitCheck:
+    ldr     r1, [r10]                   @ reload resolved class
+    cmp     r1, #0                      @ okay?
+    bne     .LOP_NEW_INSTANCE_end             @ yes, finish
+    mov     r9, r0                      @ preserve new object
+    mov     r10, r3                     @ preserve vAA
+    mov     r0, rSELF
+    mov     r1, rPC
+    bl      dvmJitEndTraceSelect        @ (self, pc)
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r9, r10)                   @ vAA<- new object
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#endif
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_BOOLEAN_JUMBO: /* 0x110 */
-/* File: armv5te/OP_IPUT_BOOLEAN_JUMBO.S */
-@include "armv5te/OP_IPUT_JUMBO.S" { "store":"strb", "sqnum":"1" }
-/* File: armv5te/OP_IPUT_JUMBO.S */
     /*
-     * Jumbo 32-bit instance field put.
+     * Class initialization required.
      *
-     * for: iput/jumbo, iput-boolean/jumbo, iput-byte/jumbo, iput-char/jumbo,
-     *      iput-short/jumbo
+     *  r0 holds class object
      */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_BOOLEAN_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_BOOLEAN_JUMBO_resolved        @ resolved, continue
-
+.LOP_NEW_INSTANCE_needinit:
+    mov     r9, r0                      @ save r0
+    bl      dvmInitClass                @ initialize class
+    cmp     r0, #0                      @ check boolean result
+    mov     r0, r9                      @ restore r0
+    bne     .LOP_NEW_INSTANCE_initialized     @ success, continue
+    b       common_exceptionThrown      @ failed, deal with init exception
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_BYTE_JUMBO: /* 0x111 */
-/* File: armv5te/OP_IPUT_BYTE_JUMBO.S */
-@include "armv5te/OP_IPUT_JUMBO.S" { "store":"strb", "sqnum":"2" }
-/* File: armv5te/OP_IPUT_JUMBO.S */
     /*
-     * Jumbo 32-bit instance field put.
+     * Resolution required.  This is the least-likely path.
      *
-     * for: iput/jumbo, iput-boolean/jumbo, iput-byte/jumbo, iput-char/jumbo,
-     *      iput-short/jumbo
+     *  r1 holds BBBB
      */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_BYTE_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_BYTE_JUMBO_resolved        @ resolved, continue
-
+.LOP_NEW_INSTANCE_resolve:
+    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
+    mov     r2, #0                      @ r2<- false
+    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
+    cmp     r0, #0                      @ got null?
+    bne     .LOP_NEW_INSTANCE_resolved        @ no, continue
+    b       common_exceptionThrown      @ yes, handle exception
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_CHAR_JUMBO: /* 0x112 */
-/* File: armv5te/OP_IPUT_CHAR_JUMBO.S */
-@include "armv5te/OP_IPUT_JUMBO.S" { "store":"strh", "sqnum":"3" }
-/* File: armv5te/OP_IPUT_JUMBO.S */
-    /*
-     * Jumbo 32-bit instance field put.
-     *
-     * for: iput/jumbo, iput-boolean/jumbo, iput-byte/jumbo, iput-char/jumbo,
-     *      iput-short/jumbo
-     */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_CHAR_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_CHAR_JUMBO_resolved        @ resolved, continue
+/* continuation for OP_NEW_ARRAY */
 
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_SHORT_JUMBO: /* 0x113 */
-/* File: armv5te/OP_IPUT_SHORT_JUMBO.S */
-@include "armv5te/OP_IPUT_JUMBO.S" { "store":"strh", "sqnum":"4" }
-/* File: armv5te/OP_IPUT_JUMBO.S */
     /*
-     * Jumbo 32-bit instance field put.
+     * Resolve class.  (This is an uncommon case.)
      *
-     * for: iput/jumbo, iput-boolean/jumbo, iput-byte/jumbo, iput-char/jumbo,
-     *      iput-short/jumbo
+     *  r1 holds array length
+     *  r2 holds class ref CCCC
      */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_SHORT_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_SHORT_JUMBO_resolved        @ resolved, continue
-
+.LOP_NEW_ARRAY_resolve:
+    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
+    mov     r9, r1                      @ r9<- length (save)
+    mov     r1, r2                      @ r1<- CCCC
+    mov     r2, #0                      @ r2<- false
+    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveClass             @ r0<- call(clazz, ref)
+    cmp     r0, #0                      @ got null?
+    mov     r1, r9                      @ r1<- length (restore)
+    beq     common_exceptionThrown      @ yes, handle exception
+    @ fall through to OP_NEW_ARRAY_finish
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_JUMBO: /* 0x114 */
-/* File: armv5te/OP_SGET_JUMBO.S */
     /*
-     * Jumbo 32-bit SGET handler.
+     * Finish allocation.
      *
-     * for: sget/jumbo, sget-object/jumbo, sget-boolean/jumbo, sget-byte/jumbo,
-     *      sget-char/jumbo, sget-short/jumbo
+     *  r0 holds class
+     *  r1 holds array length
      */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_JUMBO_finish: @ field ptr in r0
-    ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    SET_VREG(r1, r2)                    @ fp[BBBB]<- r1
+.LOP_NEW_ARRAY_finish:
+    mov     r2, #ALLOC_DONT_TRACK       @ don't track in local refs table
+    bl      dvmAllocArrayByClass        @ r0<- call(clazz, length, flags)
+    cmp     r0, #0                      @ failed?
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    beq     common_exceptionThrown      @ yes, handle the exception
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ vA<- r0
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_WIDE_JUMBO: /* 0x115 */
-/* File: armv5te/OP_SGET_WIDE_JUMBO.S */
+/* continuation for OP_FILLED_NEW_ARRAY */
+
     /*
-     * Jumbo 64-bit SGET handler.
+     * On entry:
+     *  r0 holds array class
+     *  r10 holds AA or BA
      */
-    /* sget-wide/jumbo vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r2, [r2, #offDvmDex_pResFields] @ r2<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_WIDE_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_WIDE_JUMBO_finish:
-    FETCH(r9, 3)                        @ r9<- BBBB
-    .if 0
-    add     r0, r0, #offStaticField_value @ r0<- pointer to data
-    bl      dvmQuasiAtomicRead64        @ r0/r1<- contents of field
+.LOP_FILLED_NEW_ARRAY_continue:
+    ldr     r3, [r0, #offClassObject_descriptor] @ r3<- arrayClass->descriptor
+    mov     r2, #ALLOC_DONT_TRACK       @ r2<- alloc flags
+    ldrb    rINST, [r3, #1]             @ rINST<- descriptor[1]
+    .if     0
+    mov     r1, r10                     @ r1<- AA (length)
     .else
-    ldrd    r0, [r0, #offStaticField_value] @ r0/r1<- field value (aligned)
+    mov     r1, r10, lsr #4             @ r1<- B (length)
     .endif
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[BBBB]
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    stmia   r9, {r0-r1}                 @ vBBBB/vBBBB+1<- r0/r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_OBJECT_JUMBO: /* 0x116 */
-/* File: armv5te/OP_SGET_OBJECT_JUMBO.S */
-/* File: armv5te/OP_SGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit SGET handler.
-     *
-     * for: sget/jumbo, sget-object/jumbo, sget-boolean/jumbo, sget-byte/jumbo,
-     *      sget-char/jumbo, sget-short/jumbo
-     */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_OBJECT_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_OBJECT_JUMBO_finish: @ field ptr in r0
-    ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    SET_VREG(r1, r2)                    @ fp[BBBB]<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+    cmp     rINST, #'I'                 @ array of ints?
+    cmpne   rINST, #'L'                 @ array of objects?
+    cmpne   rINST, #'['                 @ array of arrays?
+    mov     r9, r1                      @ save length in r9
+    bne     .LOP_FILLED_NEW_ARRAY_notimpl         @ no, not handled yet
+    bl      dvmAllocArrayByClass        @ r0<- call(arClass, length, flags)
+    cmp     r0, #0                      @ null return?
+    beq     common_exceptionThrown      @ alloc failed, handle exception
 
+    FETCH(r1, 2)                        @ r1<- FEDC or CCCC
+    str     r0, [rSELF, #offThread_retval]      @ retval.l <- new array
+    str     rINST, [rSELF, #offThread_retval+4] @ retval.h <- type
+    add     r0, r0, #offArrayObject_contents @ r0<- newArray->contents
+    subs    r9, r9, #1                  @ length--, check for neg
+    FETCH_ADVANCE_INST(3)               @ advance to next instr, load rINST
+    bmi     2f                          @ was zero, bail
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_BOOLEAN_JUMBO: /* 0x117 */
-/* File: armv5te/OP_SGET_BOOLEAN_JUMBO.S */
-/* File: armv5te/OP_SGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit SGET handler.
-     *
-     * for: sget/jumbo, sget-object/jumbo, sget-boolean/jumbo, sget-byte/jumbo,
-     *      sget-char/jumbo, sget-short/jumbo
-     */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_BOOLEAN_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_BOOLEAN_JUMBO_finish: @ field ptr in r0
-    ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    SET_VREG(r1, r2)                    @ fp[BBBB]<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+    @ copy values from registers into the array
+    @ r0=array, r1=CCCC/FEDC, r9=length (from AA or B), r10=AA/BA
+    .if     0
+    add     r2, rFP, r1, lsl #2         @ r2<- &fp[CCCC]
+1:  ldr     r3, [r2], #4                @ r3<- *r2++
+    subs    r9, r9, #1                  @ count--
+    str     r3, [r0], #4                @ *contents++ = vX
+    bpl     1b
+    @ continue at 2
+    .else
+    cmp     r9, #4                      @ length was initially 5?
+    and     r2, r10, #15                @ r2<- A
+    bne     1f                          @ <= 4 args, branch
+    GET_VREG(r3, r2)                    @ r3<- vA
+    sub     r9, r9, #1                  @ count--
+    str     r3, [r0, #16]               @ contents[4] = vA
+1:  and     r2, r1, #15                 @ r2<- F/E/D/C
+    GET_VREG(r3, r2)                    @ r3<- vF/vE/vD/vC
+    mov     r1, r1, lsr #4              @ r1<- next reg in low 4
+    subs    r9, r9, #1                  @ count--
+    str     r3, [r0], #4                @ *contents++ = vX
+    bpl     1b
+    @ continue at 2
+    .endif
 
+2:
+    ldr     r0, [rSELF, #offThread_retval]     @ r0<- object
+    ldr     r1, [rSELF, #offThread_retval+4]   @ r1<- type
+    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
+    GET_INST_OPCODE(ip)                      @ ip<- opcode from rINST
+    cmp     r1, #'I'                         @ Is int array?
+    strneb  r2, [r2, r0, lsr #GC_CARD_SHIFT] @ Mark card based on object head
+    GOTO_OPCODE(ip)                          @ execute it
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_BYTE_JUMBO: /* 0x118 */
-/* File: armv5te/OP_SGET_BYTE_JUMBO.S */
-/* File: armv5te/OP_SGET_JUMBO.S */
     /*
-     * Jumbo 32-bit SGET handler.
-     *
-     * for: sget/jumbo, sget-object/jumbo, sget-boolean/jumbo, sget-byte/jumbo,
-     *      sget-char/jumbo, sget-short/jumbo
+     * Throw an exception indicating that we have not implemented this
+     * mode of filled-new-array.
      */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_BYTE_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_BYTE_JUMBO_finish: @ field ptr in r0
-    ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    SET_VREG(r1, r2)                    @ fp[BBBB]<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
+.LOP_FILLED_NEW_ARRAY_notimpl:
+    ldr     r0, .L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY
+    bl      dvmThrowInternalError
+    b       common_exceptionThrown
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_CHAR_JUMBO: /* 0x119 */
-/* File: armv5te/OP_SGET_CHAR_JUMBO.S */
-/* File: armv5te/OP_SGET_JUMBO.S */
     /*
-     * Jumbo 32-bit SGET handler.
-     *
-     * for: sget/jumbo, sget-object/jumbo, sget-boolean/jumbo, sget-byte/jumbo,
-     *      sget-char/jumbo, sget-short/jumbo
+     * Ideally we'd only define this once, but depending on layout we can
+     * exceed the range of the load above.
      */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_CHAR_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_CHAR_JUMBO_finish: @ field ptr in r0
-    ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    SET_VREG(r1, r2)                    @ fp[BBBB]<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY:
+    .word   .LstrFilledNewArrayNotImpl
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_SHORT_JUMBO: /* 0x11a */
-/* File: armv5te/OP_SGET_SHORT_JUMBO.S */
-/* File: armv5te/OP_SGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit SGET handler.
-     *
-     * for: sget/jumbo, sget-object/jumbo, sget-boolean/jumbo, sget-byte/jumbo,
-     *      sget-char/jumbo, sget-short/jumbo
-     */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_SHORT_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_SHORT_JUMBO_finish: @ field ptr in r0
-    ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    SET_VREG(r1, r2)                    @ fp[BBBB]<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
+/* continuation for OP_FILLED_NEW_ARRAY_RANGE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_JUMBO: /* 0x11b */
-/* File: armv5te/OP_SPUT_JUMBO.S */
     /*
-     * Jumbo 32-bit SPUT handler.
-     *
-     * for: sput/jumbo, sput-boolean/jumbo, sput-byte/jumbo, sput-char/jumbo,
-     *      sput-short/jumbo
+     * On entry:
+     *  r0 holds array class
+     *  r10 holds AA or BA
      */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]        @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_JUMBO_finish:   @ field ptr in r0
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_VREG(r1, r2)                    @ r1<- fp[BBBB]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                        @ releasing store
-    str     r1, [r0, #offStaticField_value] @ field<- vBBBB
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+.LOP_FILLED_NEW_ARRAY_RANGE_continue:
+    ldr     r3, [r0, #offClassObject_descriptor] @ r3<- arrayClass->descriptor
+    mov     r2, #ALLOC_DONT_TRACK       @ r2<- alloc flags
+    ldrb    rINST, [r3, #1]             @ rINST<- descriptor[1]
+    .if     1
+    mov     r1, r10                     @ r1<- AA (length)
+    .else
+    mov     r1, r10, lsr #4             @ r1<- B (length)
+    .endif
+    cmp     rINST, #'I'                 @ array of ints?
+    cmpne   rINST, #'L'                 @ array of objects?
+    cmpne   rINST, #'['                 @ array of arrays?
+    mov     r9, r1                      @ save length in r9
+    bne     .LOP_FILLED_NEW_ARRAY_RANGE_notimpl         @ no, not handled yet
+    bl      dvmAllocArrayByClass        @ r0<- call(arClass, length, flags)
+    cmp     r0, #0                      @ null return?
+    beq     common_exceptionThrown      @ alloc failed, handle exception
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_WIDE_JUMBO: /* 0x11c */
-/* File: armv5te/OP_SPUT_WIDE_JUMBO.S */
-    /*
-     * Jumbo 64-bit SPUT handler.
-     */
-    /* sput-wide/jumbo vBBBB, field@AAAAAAAA */
-    ldr     r0, [rSELF, #offThread_methodClassDex]  @ r0<- DvmDex
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    ldr     r10, [r0, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    FETCH(r9, 3)                        @ r9<- BBBB
-    ldr     r2, [r10, r1, lsl #2]       @ r2<- resolved StaticField ptr
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[BBBB]
-    cmp     r2, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_WIDE_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_WIDE_JUMBO_finish: @ field ptr in r2, BBBB in r9
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vBBBB/vBBBB+1
-    GET_INST_OPCODE(r10)                @ extract opcode from rINST
-    .if 0
-    add     r2, r2, #offStaticField_value @ r2<- pointer to data
-    bl      dvmQuasiAtomicSwap64Sync    @ stores r0/r1 into addr r2
+    FETCH(r1, 2)                        @ r1<- FEDC or CCCC
+    str     r0, [rSELF, #offThread_retval]      @ retval.l <- new array
+    str     rINST, [rSELF, #offThread_retval+4] @ retval.h <- type
+    add     r0, r0, #offArrayObject_contents @ r0<- newArray->contents
+    subs    r9, r9, #1                  @ length--, check for neg
+    FETCH_ADVANCE_INST(3)               @ advance to next instr, load rINST
+    bmi     2f                          @ was zero, bail
+
+    @ copy values from registers into the array
+    @ r0=array, r1=CCCC/FEDC, r9=length (from AA or B), r10=AA/BA
+    .if     1
+    add     r2, rFP, r1, lsl #2         @ r2<- &fp[CCCC]
+1:  ldr     r3, [r2], #4                @ r3<- *r2++
+    subs    r9, r9, #1                  @ count--
+    str     r3, [r0], #4                @ *contents++ = vX
+    bpl     1b
+    @ continue at 2
     .else
-    strd    r0, [r2, #offStaticField_value] @ field<- vBBBB/vBBBB+1
+    cmp     r9, #4                      @ length was initially 5?
+    and     r2, r10, #15                @ r2<- A
+    bne     1f                          @ <= 4 args, branch
+    GET_VREG(r3, r2)                    @ r3<- vA
+    sub     r9, r9, #1                  @ count--
+    str     r3, [r0, #16]               @ contents[4] = vA
+1:  and     r2, r1, #15                 @ r2<- F/E/D/C
+    GET_VREG(r3, r2)                    @ r3<- vF/vE/vD/vC
+    mov     r1, r1, lsr #4              @ r1<- next reg in low 4
+    subs    r9, r9, #1                  @ count--
+    str     r3, [r0], #4                @ *contents++ = vX
+    bpl     1b
+    @ continue at 2
     .endif
-    GOTO_OPCODE(r10)                    @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_OBJECT_JUMBO: /* 0x11d */
-/* File: armv5te/OP_SPUT_OBJECT_JUMBO.S */
-    /*
-     * Jumbo 32-bit SPUT handler for objects
-     */
-    /* sput-object/jumbo vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_OBJECT_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_OBJECT_JUMBO_finish:   @ field ptr in r0
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_VREG(r1, r2)                    @ r1<- fp[BBBB]
+2:
+    ldr     r0, [rSELF, #offThread_retval]     @ r0<- object
+    ldr     r1, [rSELF, #offThread_retval+4]   @ r1<- type
     ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
-    ldr     r9, [r0, #offField_clazz]   @ r9<- field->clazz
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                         @ releasing store
-    b       .LOP_SPUT_OBJECT_JUMBO_end
+    GET_INST_OPCODE(ip)                      @ ip<- opcode from rINST
+    cmp     r1, #'I'                         @ Is int array?
+    strneb  r2, [r2, r0, lsr #GC_CARD_SHIFT] @ Mark card based on object head
+    GOTO_OPCODE(ip)                          @ execute it
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_BOOLEAN_JUMBO: /* 0x11e */
-/* File: armv5te/OP_SPUT_BOOLEAN_JUMBO.S */
-/* File: armv5te/OP_SPUT_JUMBO.S */
     /*
-     * Jumbo 32-bit SPUT handler.
-     *
-     * for: sput/jumbo, sput-boolean/jumbo, sput-byte/jumbo, sput-char/jumbo,
-     *      sput-short/jumbo
+     * Throw an exception indicating that we have not implemented this
+     * mode of filled-new-array.
      */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]        @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_BOOLEAN_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_BOOLEAN_JUMBO_finish:   @ field ptr in r0
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_VREG(r1, r2)                    @ r1<- fp[BBBB]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                        @ releasing store
-    str     r1, [r0, #offStaticField_value] @ field<- vBBBB
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
+.LOP_FILLED_NEW_ARRAY_RANGE_notimpl:
+    ldr     r0, .L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY_RANGE
+    bl      dvmThrowInternalError
+    b       common_exceptionThrown
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_BYTE_JUMBO: /* 0x11f */
-/* File: armv5te/OP_SPUT_BYTE_JUMBO.S */
-/* File: armv5te/OP_SPUT_JUMBO.S */
     /*
-     * Jumbo 32-bit SPUT handler.
-     *
-     * for: sput/jumbo, sput-boolean/jumbo, sput-byte/jumbo, sput-char/jumbo,
-     *      sput-short/jumbo
+     * Ideally we'd only define this once, but depending on layout we can
+     * exceed the range of the load above.
      */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]        @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_BYTE_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_BYTE_JUMBO_finish:   @ field ptr in r0
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_VREG(r1, r2)                    @ r1<- fp[BBBB]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                        @ releasing store
-    str     r1, [r0, #offStaticField_value] @ field<- vBBBB
-    @ no-op 
+
+.L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY_RANGE:
+    .word   .LstrFilledNewArrayNotImpl
+
+/* continuation for OP_CMPL_FLOAT */
+.LOP_CMPL_FLOAT_finish:
+    SET_VREG(r0, r9)                    @ vAA<- r0
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_CMPG_FLOAT */
+.LOP_CMPG_FLOAT_finish:
+    SET_VREG(r0, r9)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_CHAR_JUMBO: /* 0x120 */
-/* File: armv5te/OP_SPUT_CHAR_JUMBO.S */
-/* File: armv5te/OP_SPUT_JUMBO.S */
-    /*
-     * Jumbo 32-bit SPUT handler.
-     *
-     * for: sput/jumbo, sput-boolean/jumbo, sput-byte/jumbo, sput-char/jumbo,
-     *      sput-short/jumbo
-     */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]        @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_CHAR_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_CHAR_JUMBO_finish:   @ field ptr in r0
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_VREG(r1, r2)                    @ r1<- fp[BBBB]
+/* continuation for OP_CMPL_DOUBLE */
+.LOP_CMPL_DOUBLE_finish:
+    SET_VREG(r0, r9)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_CMPG_DOUBLE */
+.LOP_CMPG_DOUBLE_finish:
+    SET_VREG(r0, r9)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_CMP_LONG */
+
+.LOP_CMP_LONG_less:
+    mvn     r1, #0                      @ r1<- -1
+    @ Want to cond code the next mov so we can avoid branch, but don't see it;
+    @ instead, we just replicate the tail end.
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    SET_VREG(r1, r9)                    @ vAA<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                        @ releasing store
-    str     r1, [r0, #offStaticField_value] @ field<- vBBBB
-    @ no-op 
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_CMP_LONG_greater:
+    mov     r1, #1                      @ r1<- 1
+    @ fall through to _finish
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_SHORT_JUMBO: /* 0x121 */
-/* File: armv5te/OP_SPUT_SHORT_JUMBO.S */
-/* File: armv5te/OP_SPUT_JUMBO.S */
-    /*
-     * Jumbo 32-bit SPUT handler.
-     *
-     * for: sput/jumbo, sput-boolean/jumbo, sput-byte/jumbo, sput-char/jumbo,
-     *      sput-short/jumbo
-     */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]        @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_SHORT_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_SHORT_JUMBO_finish:   @ field ptr in r0
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_VREG(r1, r2)                    @ r1<- fp[BBBB]
+.LOP_CMP_LONG_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    SET_VREG(r1, r9)                    @ vAA<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                        @ releasing store
-    str     r1, [r0, #offStaticField_value] @ field<- vBBBB
-    @ no-op 
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_AGET_WIDE */
+
+.LOP_AGET_WIDE_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    ldrd    r2, [r0, #offArrayObject_contents]  @ r2/r3<- vBB[vCC]
+    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r9, {r2-r3}                 @ vAA/vAA+1<- r2/r3
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_APUT_WIDE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_INVOKE_VIRTUAL_JUMBO: /* 0x122 */
-/* File: armv5te/OP_INVOKE_VIRTUAL_JUMBO.S */
+.LOP_APUT_WIDE_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    ldmia   r9, {r2-r3}                 @ r2/r3<- vAA/vAA+1
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    strd    r2, [r0, #offArrayObject_contents]  @ r2/r3<- vBB[vCC]
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_APUT_OBJECT */
     /*
-     * Handle a virtual method call.
+     * On entry:
+     *  rINST = vBB (arrayObj)
+     *  r9 = vAA (obj)
+     *  r10 = offset into array (vBB + vCC * width)
      */
-    /* invoke-virtual/jumbo {vCCCC..v(CCCC+BBBB-1)}, meth@AAAAAAAA */
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r0, 1)                        @ r1<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved baseMethod
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    bne     .LOP_INVOKE_VIRTUAL_JUMBO_continue        @ yes, continue on
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_VIRTUAL_JUMBO_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
+.LOP_APUT_OBJECT_finish:
+    cmp     r9, #0                      @ storing null reference?
+    beq     .LOP_APUT_OBJECT_skip_check      @ yes, skip type checks
+    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz
+    ldr     r1, [rINST, #offObject_clazz]  @ r1<- arrayObj->clazz
+    bl      dvmCanPutArrayElement       @ test object type vs. array type
+    cmp     r0, #0                      @ okay?
+    beq     .LOP_APUT_OBJECT_throw           @ no
+    mov     r1, rINST                   @ r1<- arrayObj
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    ldr     r2, [rSELF, #offThread_cardTable]     @ get biased CT base
+    add     r10, #offArrayObject_contents   @ r0<- pointer to slot
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    str     r9, [r10]                   @ vBB[vCC]<- vAA
+    strb    r2, [r2, r1, lsr #GC_CARD_SHIFT] @ mark card using object head
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+.LOP_APUT_OBJECT_skip_check:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    str     r9, [r10, #offArrayObject_contents] @ vBB[vCC]<- vAA
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+.LOP_APUT_OBJECT_throw:
+    @ The types don't match.  We need to throw an ArrayStoreException.
+    ldr     r0, [r9, #offObject_clazz]
+    ldr     r1, [rINST, #offObject_clazz]
+    EXPORT_PC()
+    bl      dvmThrowArrayStoreExceptionIncompatibleElement
+    b       common_exceptionThrown
+
+/* continuation for OP_IGET */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_INVOKE_SUPER_JUMBO: /* 0x123 */
-/* File: armv5te/OP_INVOKE_SUPER_JUMBO.S */
     /*
-     * Handle a "super" method call.
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
      */
-    /* invoke-super/jumbo {vCCCC..v(CCCC+BBBB-1)}, meth@AAAAAAAA */
-    FETCH(r10, 4)                       @ r10<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r0, 1)                        @ r1<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    GET_VREG(r9, r10)                   @ r9<- "this" ptr
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved baseMethod
-    cmp     r9, #0                      @ null "this"?
-    ldr     r10, [rSELF, #offThread_method] @ r10<- current method
-    beq     common_errNullObject        @ null "this", throw exception
-    cmp     r0, #0                      @ already resolved?
-    ldr     r10, [r10, #offMethod_clazz]  @ r10<- method->clazz
-    EXPORT_PC()                         @ must export for invoke
-    bne     .LOP_INVOKE_SUPER_JUMBO_continue        @ resolved, continue on
-    b       .LOP_INVOKE_SUPER_JUMBO_resolve         @ do resolve now
+.LOP_IGET_finish:
+    @bl      common_squeak0
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+    @ no-op                             @ acquiring load
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_IGET_WIDE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_INVOKE_DIRECT_JUMBO: /* 0x124 */
-/* File: armv5te/OP_INVOKE_DIRECT_JUMBO.S */
     /*
-     * Handle a direct method call.
-     *
-     * (We could defer the "is 'this' pointer null" test to the common
-     * method invocation code, and use a flag to indicate that static
-     * calls don't count.  If we do this as part of copying the arguments
-     * out we could avoiding loading the first arg twice.)
-     *
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
      */
-    /* invoke-direct/jumbo {vCCCC..v(CCCC+BBBB-1)}, meth@AAAAAAAA */
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r0, 1)                        @ r1<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    FETCH(r10, 4)                       @ r10<- CCCC
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved methodToCall
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    GET_VREG(r9, r10)                   @ r9<- "this" ptr
-    beq     .LOP_INVOKE_DIRECT_JUMBO_resolve         @ not resolved, do it now
-.LOP_INVOKE_DIRECT_JUMBO_finish:
-    cmp     r9, #0                      @ null "this" ref?
-    bne     common_invokeMethodJumbo    @ (r0=method, r9="this")
-    b       common_errNullObject        @ yes, throw exception
+.LOP_IGET_WIDE_finish:
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    .if     0
+    add     r0, r9, r3                  @ r0<- address of field
+    bl      dvmQuasiAtomicRead64        @ r0/r1<- contents of field
+    .else
+    ldrd    r0, [r9, r3]                @ r0/r1<- obj.field (64-bit align ok)
+    .endif
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    add     r3, rFP, r2, lsl #2         @ r3<- &fp[A]
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_IGET_OBJECT */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_INVOKE_STATIC_JUMBO: /* 0x125 */
-/* File: armv5te/OP_INVOKE_STATIC_JUMBO.S */
     /*
-     * Handle a static method call.
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
      */
-    /* invoke-static/jumbo {vCCCC..v(CCCC+BBBB-1)}, meth@AAAAAAAA */
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r0, 1)                        @ r1<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved methodToCall
-#if defined(WITH_JIT)
-    add     r10, r3, r1, lsl #2         @ r10<- &resolved_methodToCall
-#endif
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    bne     common_invokeMethodJumboNoThis   @ (r0=method)
-    b       .LOP_INVOKE_STATIC_JUMBO_resolve
+.LOP_IGET_OBJECT_finish:
+    @bl      common_squeak0
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+    @ no-op                             @ acquiring load
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_IGET_BOOLEAN */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_INVOKE_INTERFACE_JUMBO: /* 0x126 */
-/* File: armv5te/OP_INVOKE_INTERFACE_JUMBO.S */
     /*
-     * Handle an interface method call.
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
      */
-    /* invoke-interface/jumbo {vCCCC..v(CCCC+BBBB-1)}, meth@AAAAAAAA */
-    FETCH(r2, 4)                        @ r2<- CCCC
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    EXPORT_PC()                         @ must export for invoke
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    GET_VREG(r9, r2)                    @ r9<- first arg ("this")
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- methodClassDex
-    cmp     r9, #0                      @ null obj?
-    ldr     r2, [rSELF, #offThread_method]  @ r2<- method
-    beq     common_errNullObject        @ yes, fail
-    ldr     r0, [r9, #offObject_clazz]  @ r0<- thisPtr->clazz
-    bl      dvmFindInterfaceMethodInCache @ r0<- call(class, ref, method, dex)
-    cmp     r0, #0                      @ failed?
-    beq     common_exceptionThrown      @ yes, handle exception
-    b       common_invokeMethodJumbo    @ (r0=method, r9="this")
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_27FF: /* 0x127 */
-/* File: armv5te/OP_UNUSED_27FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+.LOP_IGET_BOOLEAN_finish:
+    @bl      common_squeak1
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+    @ no-op                             @ acquiring load
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IGET_BYTE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_28FF: /* 0x128 */
-/* File: armv5te/OP_UNUSED_28FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_29FF: /* 0x129 */
-/* File: armv5te/OP_UNUSED_29FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_2AFF: /* 0x12a */
-/* File: armv5te/OP_UNUSED_2AFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IGET_BYTE_finish:
+    @bl      common_squeak2
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+    @ no-op                             @ acquiring load
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IGET_CHAR */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_2BFF: /* 0x12b */
-/* File: armv5te/OP_UNUSED_2BFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IGET_CHAR_finish:
+    @bl      common_squeak3
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+    @ no-op                             @ acquiring load
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IGET_SHORT */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_2CFF: /* 0x12c */
-/* File: armv5te/OP_UNUSED_2CFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IGET_SHORT_finish:
+    @bl      common_squeak4
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+    @ no-op                             @ acquiring load
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IPUT */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_2DFF: /* 0x12d */
-/* File: armv5te/OP_UNUSED_2DFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_finish:
+    @bl      common_squeak0
+    mov     r1, rINST, lsr #8           @ r1<- A+
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    and     r1, r1, #15                 @ r1<- A
+    cmp     r9, #0                      @ check object for null
+    GET_VREG(r0, r1)                    @ r0<- fp[A]
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    @ no-op                         @ releasing store
+    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+    @ no-op 
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IPUT_WIDE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_2EFF: /* 0x12e */
-/* File: armv5te/OP_UNUSED_2EFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_WIDE_finish:
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    cmp     r9, #0                      @ check object for null
+    and     r2, r2, #15                 @ r2<- A
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    add     r2, rFP, r2, lsl #2         @ r3<- &fp[A]
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[A]
+    GET_INST_OPCODE(r10)                @ extract opcode from rINST
+    .if     0
+    add     r2, r9, r3                  @ r2<- target address
+    bl      dvmQuasiAtomicSwap64Sync    @ stores r0/r1 into addr r2
+    .else
+    strd    r0, [r9, r3]                @ obj.field (64 bits, aligned)<- r0/r1
+    .endif
+    GOTO_OPCODE(r10)                    @ jump to next instruction
 
+/* continuation for OP_IPUT_OBJECT */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_2FFF: /* 0x12f */
-/* File: armv5te/OP_UNUSED_2FFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_OBJECT_finish:
+    @bl      common_squeak0
+    mov     r1, rINST, lsr #8           @ r1<- A+
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    and     r1, r1, #15                 @ r1<- A
+    cmp     r9, #0                      @ check object for null
+    GET_VREG(r0, r1)                    @ r0<- fp[A]
+    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    @ no-op                         @ releasing store
+    str     r0, [r9, r3]                @ obj.field (32 bits)<- r0
+    @ no-op 
+    cmp     r0, #0                      @ stored a null reference?
+    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card if not
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IPUT_BOOLEAN */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_30FF: /* 0x130 */
-/* File: armv5te/OP_UNUSED_30FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_BOOLEAN_finish:
+    @bl      common_squeak1
+    mov     r1, rINST, lsr #8           @ r1<- A+
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    and     r1, r1, #15                 @ r1<- A
+    cmp     r9, #0                      @ check object for null
+    GET_VREG(r0, r1)                    @ r0<- fp[A]
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    @ no-op                         @ releasing store
+    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+    @ no-op 
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IPUT_BYTE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_31FF: /* 0x131 */
-/* File: armv5te/OP_UNUSED_31FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_BYTE_finish:
+    @bl      common_squeak2
+    mov     r1, rINST, lsr #8           @ r1<- A+
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    and     r1, r1, #15                 @ r1<- A
+    cmp     r9, #0                      @ check object for null
+    GET_VREG(r0, r1)                    @ r0<- fp[A]
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    @ no-op                         @ releasing store
+    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+    @ no-op 
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IPUT_CHAR */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_32FF: /* 0x132 */
-/* File: armv5te/OP_UNUSED_32FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_CHAR_finish:
+    @bl      common_squeak3
+    mov     r1, rINST, lsr #8           @ r1<- A+
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    and     r1, r1, #15                 @ r1<- A
+    cmp     r9, #0                      @ check object for null
+    GET_VREG(r0, r1)                    @ r0<- fp[A]
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    @ no-op                         @ releasing store
+    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+    @ no-op 
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IPUT_SHORT */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_33FF: /* 0x133 */
-/* File: armv5te/OP_UNUSED_33FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_SHORT_finish:
+    @bl      common_squeak4
+    mov     r1, rINST, lsr #8           @ r1<- A+
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    and     r1, r1, #15                 @ r1<- A
+    cmp     r9, #0                      @ check object for null
+    GET_VREG(r0, r1)                    @ r0<- fp[A]
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    @ no-op                         @ releasing store
+    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+    @ no-op 
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_SGET */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_34FF: /* 0x134 */
-/* File: armv5te/OP_UNUSED_34FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SGET_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_finish
 
+/* continuation for OP_SGET_WIDE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_35FF: /* 0x135 */
-/* File: armv5te/OP_UNUSED_35FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     *
+     * Returns StaticField pointer in r0.
+     */
+.LOP_SGET_WIDE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r1<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_WIDE_finish          @ resume
 
+/* continuation for OP_SGET_OBJECT */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_36FF: /* 0x136 */
-/* File: armv5te/OP_UNUSED_36FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SGET_OBJECT_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_OBJECT_finish
 
+/* continuation for OP_SGET_BOOLEAN */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_37FF: /* 0x137 */
-/* File: armv5te/OP_UNUSED_37FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SGET_BOOLEAN_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_BOOLEAN_finish
 
+/* continuation for OP_SGET_BYTE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_38FF: /* 0x138 */
-/* File: armv5te/OP_UNUSED_38FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SGET_BYTE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_BYTE_finish
 
+/* continuation for OP_SGET_CHAR */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_39FF: /* 0x139 */
-/* File: armv5te/OP_UNUSED_39FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SGET_CHAR_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_CHAR_finish
 
+/* continuation for OP_SGET_SHORT */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_3AFF: /* 0x13a */
-/* File: armv5te/OP_UNUSED_3AFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SGET_SHORT_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_SHORT_finish
 
+/* continuation for OP_SPUT */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_3BFF: /* 0x13b */
-/* File: armv5te/OP_UNUSED_3BFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SPUT_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_finish          @ resume
 
+/* continuation for OP_SPUT_WIDE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_3CFF: /* 0x13c */
-/* File: armv5te/OP_UNUSED_3CFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r9:  &fp[AA]
+     *  r10: dvmDex->pResFields
+     *
+     * Returns StaticField pointer in r2.
+     */
+.LOP_SPUT_WIDE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    mov     r2, r0                      @ copy to r2
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_WIDE_finish          @ resume
 
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_3DFF: /* 0x13d */
-/* File: armv5te/OP_UNUSED_3DFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_3EFF: /* 0x13e */
-/* File: armv5te/OP_UNUSED_3EFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_3FFF: /* 0x13f */
-/* File: armv5te/OP_UNUSED_3FFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_SPUT_OBJECT */
 
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_40FF: /* 0x140 */
-/* File: armv5te/OP_UNUSED_40FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_41FF: /* 0x141 */
-/* File: armv5te/OP_UNUSED_41FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_42FF: /* 0x142 */
-/* File: armv5te/OP_UNUSED_42FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+.LOP_SPUT_OBJECT_end:
+    str     r1, [r0, #offStaticField_value]  @ field<- vAA
+    @ no-op 
+    cmp     r1, #0                      @ stored a null object?
+    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card based on obj head
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+    /* Continuation if the field has not yet been resolved.
+     * r1:  BBBB field ref
+     * r10: dvmDex->pResFields
+     */
+.LOP_SPUT_OBJECT_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_OBJECT_finish          @ resume
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_43FF: /* 0x143 */
-/* File: armv5te/OP_UNUSED_43FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
 
+/* continuation for OP_SPUT_BOOLEAN */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_44FF: /* 0x144 */
-/* File: armv5te/OP_UNUSED_44FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SPUT_BOOLEAN_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_BOOLEAN_finish          @ resume
 
+/* continuation for OP_SPUT_BYTE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_45FF: /* 0x145 */
-/* File: armv5te/OP_UNUSED_45FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SPUT_BYTE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_BYTE_finish          @ resume
 
+/* continuation for OP_SPUT_CHAR */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_46FF: /* 0x146 */
-/* File: armv5te/OP_UNUSED_46FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SPUT_CHAR_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_CHAR_finish          @ resume
 
+/* continuation for OP_SPUT_SHORT */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_47FF: /* 0x147 */
-/* File: armv5te/OP_UNUSED_47FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SPUT_SHORT_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_SHORT_finish          @ resume
 
+/* continuation for OP_INVOKE_VIRTUAL */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_48FF: /* 0x148 */
-/* File: armv5te/OP_UNUSED_48FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * At this point:
+     *  r0 = resolved base method
+     *  r10 = C or CCCC (index of first arg, which is the "this" ptr)
+     */
+.LOP_INVOKE_VIRTUAL_continue:
+    GET_VREG(r9, r10)                   @ r9<- "this" ptr
+    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
+    cmp     r9, #0                      @ is "this" null?
+    beq     common_errNullObject        @ null "this", throw exception
+    ldr     r3, [r9, #offObject_clazz]  @ r3<- thisPtr->clazz
+    ldr     r3, [r3, #offClassObject_vtable]    @ r3<- thisPtr->clazz->vtable
+    ldr     r0, [r3, r2, lsl #2]        @ r3<- vtable[methodIndex]
+    bl      common_invokeMethodNoRange @ (r0=method, r9="this")
 
+/* continuation for OP_INVOKE_SUPER */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_49FF: /* 0x149 */
-/* File: armv5te/OP_UNUSED_49FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * At this point:
+     *  r0 = resolved base method
+     *  r10 = method->clazz
+     */
+.LOP_INVOKE_SUPER_continue:
+    ldr     r1, [r10, #offClassObject_super]    @ r1<- method->clazz->super
+    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
+    ldr     r3, [r1, #offClassObject_vtableCount]   @ r3<- super->vtableCount
+    EXPORT_PC()                         @ must export for invoke
+    cmp     r2, r3                      @ compare (methodIndex, vtableCount)
+    bcs     .LOP_INVOKE_SUPER_nsm             @ method not present in superclass
+    ldr     r1, [r1, #offClassObject_vtable]    @ r1<- ...clazz->super->vtable
+    ldr     r0, [r1, r2, lsl #2]        @ r3<- vtable[methodIndex]
+    bl      common_invokeMethodNoRange @ continue on
 
+.LOP_INVOKE_SUPER_resolve:
+    mov     r0, r10                     @ r0<- method->clazz
+    mov     r2, #METHOD_VIRTUAL         @ resolver method type
+    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
+    cmp     r0, #0                      @ got null?
+    bne     .LOP_INVOKE_SUPER_continue        @ no, continue
+    b       common_exceptionThrown      @ yes, handle exception
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_4AFF: /* 0x14a */
-/* File: armv5te/OP_UNUSED_4AFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Throw a NoSuchMethodError with the method name as the message.
+     *  r0 = resolved base method
+     */
+.LOP_INVOKE_SUPER_nsm:
+    ldr     r1, [r0, #offMethod_name]   @ r1<- method name
+    b       common_errNoSuchMethod
 
+/* continuation for OP_INVOKE_DIRECT */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_4BFF: /* 0x14b */
-/* File: armv5te/OP_UNUSED_4BFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * On entry:
+     *  r1 = reference (BBBB or CCCC)
+     *  r10 = "this" register
+     */
+.LOP_INVOKE_DIRECT_resolve:
+    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
+    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
+    mov     r2, #METHOD_DIRECT          @ resolver method type
+    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
+    cmp     r0, #0                      @ got null?
+    bne     .LOP_INVOKE_DIRECT_finish          @ no, continue
+    b       common_exceptionThrown      @ yes, handle exception
 
+/* continuation for OP_INVOKE_STATIC */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_4CFF: /* 0x14c */
-/* File: armv5te/OP_UNUSED_4CFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
 
+.LOP_INVOKE_STATIC_resolve:
+    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
+    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
+    mov     r2, #METHOD_STATIC          @ resolver method type
+    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
+    cmp     r0, #0                      @ got null?
+#if defined(WITH_JIT)
+    /*
+     * Check to see if we're actively building a trace.  If so,
+     * we need to keep this instruction out of it.
+     * r10: &resolved_methodToCall
+     */
+    ldrh    r2, [rSELF, #offThread_subMode]
+    beq     common_exceptionThrown            @ null, handle exception
+    ands    r2, #kSubModeJitTraceBuild        @ trace under construction?
+    beq     common_invokeMethodNoRange     @ no (r0=method, r9="this")
+    ldr     r1, [r10]                         @ reload resolved method
+    cmp     r1, #0                            @ finished resolving?
+    bne     common_invokeMethodNoRange     @ yes (r0=method, r9="this")
+    mov     r10, r0                           @ preserve method
+    mov     r0, rSELF
+    mov     r1, rPC
+    bl      dvmJitEndTraceSelect              @ (self, pc)
+    mov     r0, r10
+    b       common_invokeMethodNoRange     @ whew, finally!
+#else
+    bne     common_invokeMethodNoRange     @ (r0=method, r9="this")
+    b       common_exceptionThrown            @ yes, handle exception
+#endif
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_4DFF: /* 0x14d */
-/* File: armv5te/OP_UNUSED_4DFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_INVOKE_VIRTUAL_RANGE */
 
+    /*
+     * At this point:
+     *  r0 = resolved base method
+     *  r10 = C or CCCC (index of first arg, which is the "this" ptr)
+     */
+.LOP_INVOKE_VIRTUAL_RANGE_continue:
+    GET_VREG(r9, r10)                   @ r9<- "this" ptr
+    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
+    cmp     r9, #0                      @ is "this" null?
+    beq     common_errNullObject        @ null "this", throw exception
+    ldr     r3, [r9, #offObject_clazz]  @ r3<- thisPtr->clazz
+    ldr     r3, [r3, #offClassObject_vtable]    @ r3<- thisPtr->clazz->vtable
+    ldr     r0, [r3, r2, lsl #2]        @ r3<- vtable[methodIndex]
+    bl      common_invokeMethodRange @ (r0=method, r9="this")
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_4EFF: /* 0x14e */
-/* File: armv5te/OP_UNUSED_4EFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_INVOKE_SUPER_RANGE */
 
+    /*
+     * At this point:
+     *  r0 = resolved base method
+     *  r10 = method->clazz
+     */
+.LOP_INVOKE_SUPER_RANGE_continue:
+    ldr     r1, [r10, #offClassObject_super]    @ r1<- method->clazz->super
+    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
+    ldr     r3, [r1, #offClassObject_vtableCount]   @ r3<- super->vtableCount
+    EXPORT_PC()                         @ must export for invoke
+    cmp     r2, r3                      @ compare (methodIndex, vtableCount)
+    bcs     .LOP_INVOKE_SUPER_RANGE_nsm             @ method not present in superclass
+    ldr     r1, [r1, #offClassObject_vtable]    @ r1<- ...clazz->super->vtable
+    ldr     r0, [r1, r2, lsl #2]        @ r3<- vtable[methodIndex]
+    bl      common_invokeMethodRange @ continue on
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_4FFF: /* 0x14f */
-/* File: armv5te/OP_UNUSED_4FFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+.LOP_INVOKE_SUPER_RANGE_resolve:
+    mov     r0, r10                     @ r0<- method->clazz
+    mov     r2, #METHOD_VIRTUAL         @ resolver method type
+    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
+    cmp     r0, #0                      @ got null?
+    bne     .LOP_INVOKE_SUPER_RANGE_continue        @ no, continue
+    b       common_exceptionThrown      @ yes, handle exception
 
+    /*
+     * Throw a NoSuchMethodError with the method name as the message.
+     *  r0 = resolved base method
+     */
+.LOP_INVOKE_SUPER_RANGE_nsm:
+    ldr     r1, [r0, #offMethod_name]   @ r1<- method name
+    b       common_errNoSuchMethod
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_50FF: /* 0x150 */
-/* File: armv5te/OP_UNUSED_50FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_INVOKE_DIRECT_RANGE */
 
+    /*
+     * On entry:
+     *  r1 = reference (BBBB or CCCC)
+     *  r10 = "this" register
+     */
+.LOP_INVOKE_DIRECT_RANGE_resolve:
+    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
+    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
+    mov     r2, #METHOD_DIRECT          @ resolver method type
+    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
+    cmp     r0, #0                      @ got null?
+    bne     .LOP_INVOKE_DIRECT_RANGE_finish          @ no, continue
+    b       common_exceptionThrown      @ yes, handle exception
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_51FF: /* 0x151 */
-/* File: armv5te/OP_UNUSED_51FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_INVOKE_STATIC_RANGE */
 
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_52FF: /* 0x152 */
-/* File: armv5te/OP_UNUSED_52FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+.LOP_INVOKE_STATIC_RANGE_resolve:
+    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
+    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
+    mov     r2, #METHOD_STATIC          @ resolver method type
+    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
+    cmp     r0, #0                      @ got null?
+#if defined(WITH_JIT)
+    /*
+     * Check to see if we're actively building a trace.  If so,
+     * we need to keep this instruction out of it.
+     * r10: &resolved_methodToCall
+     */
+    ldrh    r2, [rSELF, #offThread_subMode]
+    beq     common_exceptionThrown            @ null, handle exception
+    ands    r2, #kSubModeJitTraceBuild        @ trace under construction?
+    beq     common_invokeMethodRange     @ no (r0=method, r9="this")
+    ldr     r1, [r10]                         @ reload resolved method
+    cmp     r1, #0                            @ finished resolving?
+    bne     common_invokeMethodRange     @ yes (r0=method, r9="this")
+    mov     r10, r0                           @ preserve method
+    mov     r0, rSELF
+    mov     r1, rPC
+    bl      dvmJitEndTraceSelect              @ (self, pc)
+    mov     r0, r10
+    b       common_invokeMethodRange     @ whew, finally!
+#else
+    bne     common_invokeMethodRange     @ (r0=method, r9="this")
+    b       common_exceptionThrown            @ yes, handle exception
+#endif
 
+/* continuation for OP_FLOAT_TO_LONG */
+/*
+ * Convert the float in r0 to a long in r0/r1.
+ *
+ * We have to clip values to long min/max per the specification.  The
+ * expected common case is a "reasonable" value that converts directly
+ * to modest integer.  The EABI convert function isn't doing this for us.
+ */
+f2l_doconv:
+    stmfd   sp!, {r4, lr}
+    mov     r1, #0x5f000000             @ (float)maxlong
+    mov     r4, r0
+    bl      __aeabi_fcmpge              @ is arg >= maxlong?
+    cmp     r0, #0                      @ nonzero == yes
+    mvnne   r0, #0                      @ return maxlong (7fffffff)
+    mvnne   r1, #0x80000000
+    ldmnefd sp!, {r4, pc}
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_53FF: /* 0x153 */
-/* File: armv5te/OP_UNUSED_53FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    mov     r0, r4                      @ recover arg
+    mov     r1, #0xdf000000             @ (float)minlong
+    bl      __aeabi_fcmple              @ is arg <= minlong?
+    cmp     r0, #0                      @ nonzero == yes
+    movne   r0, #0                      @ return minlong (80000000)
+    movne   r1, #0x80000000
+    ldmnefd sp!, {r4, pc}
 
+    mov     r0, r4                      @ recover arg
+    mov     r1, r4
+    bl      __aeabi_fcmpeq              @ is arg == self?
+    cmp     r0, #0                      @ zero == no
+    moveq   r1, #0                      @ return zero for NaN
+    ldmeqfd sp!, {r4, pc}
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_54FF: /* 0x154 */
-/* File: armv5te/OP_UNUSED_54FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    mov     r0, r4                      @ recover arg
+    bl      __aeabi_f2lz                @ convert float to long
+    ldmfd   sp!, {r4, pc}
 
+/* continuation for OP_DOUBLE_TO_LONG */
+/*
+ * Convert the double in r0/r1 to a long in r0/r1.
+ *
+ * We have to clip values to long min/max per the specification.  The
+ * expected common case is a "reasonable" value that converts directly
+ * to modest integer.  The EABI convert function isn't doing this for us.
+ */
+d2l_doconv:
+    stmfd   sp!, {r4, r5, lr}           @ save regs
+    mov     r3, #0x43000000             @ maxlong, as a double (high word)
+    add     r3, #0x00e00000             @  0x43e00000
+    mov     r2, #0                      @ maxlong, as a double (low word)
+    sub     sp, sp, #4                  @ align for EABI
+    mov     r4, r0                      @ save a copy of r0
+    mov     r5, r1                      @  and r1
+    bl      __aeabi_dcmpge              @ is arg >= maxlong?
+    cmp     r0, #0                      @ nonzero == yes
+    mvnne   r0, #0                      @ return maxlong (7fffffffffffffff)
+    mvnne   r1, #0x80000000
+    bne     1f
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_55FF: /* 0x155 */
-/* File: armv5te/OP_UNUSED_55FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    mov     r0, r4                      @ recover arg
+    mov     r1, r5
+    mov     r3, #0xc3000000             @ minlong, as a double (high word)
+    add     r3, #0x00e00000             @  0xc3e00000
+    mov     r2, #0                      @ minlong, as a double (low word)
+    bl      __aeabi_dcmple              @ is arg <= minlong?
+    cmp     r0, #0                      @ nonzero == yes
+    movne   r0, #0                      @ return minlong (8000000000000000)
+    movne   r1, #0x80000000
+    bne     1f
 
+    mov     r0, r4                      @ recover arg
+    mov     r1, r5
+    mov     r2, r4                      @ compare against self
+    mov     r3, r5
+    bl      __aeabi_dcmpeq              @ is arg == self?
+    cmp     r0, #0                      @ zero == no
+    moveq   r1, #0                      @ return zero for NaN
+    beq     1f
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_56FF: /* 0x156 */
-/* File: armv5te/OP_UNUSED_56FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    mov     r0, r4                      @ recover arg
+    mov     r1, r5
+    bl      __aeabi_d2lz                @ convert double to long
 
+1:
+    add     sp, sp, #4
+    ldmfd   sp!, {r4, r5, pc}
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_57FF: /* 0x157 */
-/* File: armv5te/OP_UNUSED_57FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_MUL_LONG */
 
+.LOP_MUL_LONG_finish:
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r0, {r9-r10}                @ vAA/vAA+1<- r9/r10
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_58FF: /* 0x158 */
-/* File: armv5te/OP_UNUSED_58FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_SHL_LONG */
 
+.LOP_SHL_LONG_finish:
+    mov     r0, r0, asl r2              @  r0<- r0 << r2
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_59FF: /* 0x159 */
-/* File: armv5te/OP_UNUSED_59FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_SHR_LONG */
 
+.LOP_SHR_LONG_finish:
+    mov     r1, r1, asr r2              @  r1<- r1 >> r2
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_5AFF: /* 0x15a */
-/* File: armv5te/OP_UNUSED_5AFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_USHR_LONG */
 
+.LOP_USHR_LONG_finish:
+    mov     r1, r1, lsr r2              @  r1<- r1 >>> r2
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_5BFF: /* 0x15b */
-/* File: armv5te/OP_UNUSED_5BFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_SHL_LONG_2ADDR */
 
+.LOP_SHL_LONG_2ADDR_finish:
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_5CFF: /* 0x15c */
-/* File: armv5te/OP_UNUSED_5CFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_SHR_LONG_2ADDR */
 
+.LOP_SHR_LONG_2ADDR_finish:
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_5DFF: /* 0x15d */
-/* File: armv5te/OP_UNUSED_5DFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_USHR_LONG_2ADDR */
 
+.LOP_USHR_LONG_2ADDR_finish:
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_5EFF: /* 0x15e */
-/* File: armv5te/OP_UNUSED_5EFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_IGET_VOLATILE */
 
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IGET_VOLATILE_finish:
+    @bl      common_squeak0
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+    SMP_DMB                            @ acquiring load
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_5FFF: /* 0x15f */
-/* File: armv5te/OP_UNUSED_5FFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_IPUT_VOLATILE */
 
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_VOLATILE_finish:
+    @bl      common_squeak0
+    mov     r1, rINST, lsr #8           @ r1<- A+
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    and     r1, r1, #15                 @ r1<- A
+    cmp     r9, #0                      @ check object for null
+    GET_VREG(r0, r1)                    @ r0<- fp[A]
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SMP_DMB_ST                        @ releasing store
+    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+    SMP_DMB
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_60FF: /* 0x160 */
-/* File: armv5te/OP_UNUSED_60FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_SGET_VOLATILE */
 
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SGET_VOLATILE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_VOLATILE_finish
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_61FF: /* 0x161 */
-/* File: armv5te/OP_UNUSED_61FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_SPUT_VOLATILE */
 
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SPUT_VOLATILE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_VOLATILE_finish          @ resume
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_62FF: /* 0x162 */
-/* File: armv5te/OP_UNUSED_62FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_IGET_OBJECT_VOLATILE */
 
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IGET_OBJECT_VOLATILE_finish:
+    @bl      common_squeak0
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+    SMP_DMB                            @ acquiring load
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_63FF: /* 0x163 */
-/* File: armv5te/OP_UNUSED_63FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_IGET_WIDE_VOLATILE */
 
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IGET_WIDE_VOLATILE_finish:
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    .if     1
+    add     r0, r9, r3                  @ r0<- address of field
+    bl      dvmQuasiAtomicRead64        @ r0/r1<- contents of field
+    .else
+    ldrd    r0, [r9, r3]                @ r0/r1<- obj.field (64-bit align ok)
+    .endif
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    add     r3, rFP, r2, lsl #2         @ r3<- &fp[A]
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_64FF: /* 0x164 */
-/* File: armv5te/OP_UNUSED_64FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_IPUT_WIDE_VOLATILE */
 
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_WIDE_VOLATILE_finish:
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    cmp     r9, #0                      @ check object for null
+    and     r2, r2, #15                 @ r2<- A
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    add     r2, rFP, r2, lsl #2         @ r3<- &fp[A]
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[A]
+    GET_INST_OPCODE(r10)                @ extract opcode from rINST
+    .if     1
+    add     r2, r9, r3                  @ r2<- target address
+    bl      dvmQuasiAtomicSwap64Sync    @ stores r0/r1 into addr r2
+    .else
+    strd    r0, [r9, r3]                @ obj.field (64 bits, aligned)<- r0/r1
+    .endif
+    GOTO_OPCODE(r10)                    @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_65FF: /* 0x165 */
-/* File: armv5te/OP_UNUSED_65FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_SGET_WIDE_VOLATILE */
 
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     *
+     * Returns StaticField pointer in r0.
+     */
+.LOP_SGET_WIDE_VOLATILE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r1<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_WIDE_VOLATILE_finish          @ resume
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_66FF: /* 0x166 */
-/* File: armv5te/OP_UNUSED_66FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_67FF: /* 0x167 */
-/* File: armv5te/OP_UNUSED_67FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_68FF: /* 0x168 */
-/* File: armv5te/OP_UNUSED_68FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_69FF: /* 0x169 */
-/* File: armv5te/OP_UNUSED_69FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_6AFF: /* 0x16a */
-/* File: armv5te/OP_UNUSED_6AFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_6BFF: /* 0x16b */
-/* File: armv5te/OP_UNUSED_6BFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_6CFF: /* 0x16c */
-/* File: armv5te/OP_UNUSED_6CFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_6DFF: /* 0x16d */
-/* File: armv5te/OP_UNUSED_6DFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_6EFF: /* 0x16e */
-/* File: armv5te/OP_UNUSED_6EFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_SPUT_WIDE_VOLATILE */
 
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r9:  &fp[AA]
+     *  r10: dvmDex->pResFields
+     *
+     * Returns StaticField pointer in r2.
+     */
+.LOP_SPUT_WIDE_VOLATILE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    mov     r2, r0                      @ copy to r2
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_WIDE_VOLATILE_finish          @ resume
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_6FFF: /* 0x16f */
-/* File: armv5te/OP_UNUSED_6FFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_EXECUTE_INLINE */
 
+    /*
+     * Extract args, call function.
+     *  r0 = #of args (0-4)
+     *  r10 = call index
+     *  lr = return addr, above  [DO NOT bl out of here w/o preserving LR]
+     *
+     * Other ideas:
+     * - Use a jump table from the main piece to jump directly into the
+     *   AND/LDR pairs.  Costs a data load, saves a branch.
+     * - Have five separate pieces that do the loading, so we can work the
+     *   interleave a little better.  Increases code size.
+     */
+.LOP_EXECUTE_INLINE_continue:
+    rsb     r0, r0, #4                  @ r0<- 4-r0
+    FETCH(rINST, 2)                     @ rINST<- FEDC
+    add     pc, pc, r0, lsl #3          @ computed goto, 2 instrs each
+    bl      common_abort                @ (skipped due to ARM prefetch)
+4:  and     ip, rINST, #0xf000          @ isolate F
+    ldr     r3, [rFP, ip, lsr #10]      @ r3<- vF (shift right 12, left 2)
+3:  and     ip, rINST, #0x0f00          @ isolate E
+    ldr     r2, [rFP, ip, lsr #6]       @ r2<- vE
+2:  and     ip, rINST, #0x00f0          @ isolate D
+    ldr     r1, [rFP, ip, lsr #2]       @ r1<- vD
+1:  and     ip, rINST, #0x000f          @ isolate C
+    ldr     r0, [rFP, ip, lsl #2]       @ r0<- vC
+0:
+    ldr     rINST, .LOP_EXECUTE_INLINE_table    @ table of InlineOperation
+    ldr     pc, [rINST, r10, lsl #4]    @ sizeof=16, "func" is first entry
+    @ (not reached)
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_70FF: /* 0x170 */
-/* File: armv5te/OP_UNUSED_70FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * We're debugging or profiling.
+     * r10: opIndex
+     */
+.LOP_EXECUTE_INLINE_debugmode:
+    mov     r0, r10
+    bl      dvmResolveInlineNative
+    cmp     r0, #0                      @ did it resolve?
+    beq     .LOP_EXECUTE_INLINE_resume          @ no, just move on
+    mov     r9, r0                      @ remember method
+    mov     r1, rSELF
+    bl      dvmFastMethodTraceEnter     @ (method, self)
+    add     r1, rSELF, #offThread_retval@ r1<- &self->retval
+    sub     sp, sp, #8                  @ make room for arg, +64 bit align
+    mov     r0, rINST, lsr #12          @ r0<- B
+    str     r1, [sp]                    @ push &self->retval
+    bl      .LOP_EXECUTE_INLINE_continue        @ make call; will return after
+    mov     rINST, r0                   @ save result of inline
+    add     sp, sp, #8                  @ pop stack
+    mov     r0, r9                      @ r0<- method
+    mov     r1, rSELF
+    bl      dvmFastNativeMethodTraceExit @ (method, self)
+    cmp     rINST, #0                   @ test boolean result of inline
+    beq     common_exceptionThrown      @ returned false, handle exception
+    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_71FF: /* 0x171 */
-/* File: armv5te/OP_UNUSED_71FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
 
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_72FF: /* 0x172 */
-/* File: armv5te/OP_UNUSED_72FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+.LOP_EXECUTE_INLINE_table:
+    .word   gDvmInlineOpsTable
 
+/* continuation for OP_EXECUTE_INLINE_RANGE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_73FF: /* 0x173 */
-/* File: armv5te/OP_UNUSED_73FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Extract args, call function.
+     *  r0 = #of args (0-4)
+     *  r10 = call index
+     *  lr = return addr, above  [DO NOT bl out of here w/o preserving LR]
+     */
+.LOP_EXECUTE_INLINE_RANGE_continue:
+    rsb     r0, r0, #4                  @ r0<- 4-r0
+    FETCH(r9, 2)                        @ r9<- CCCC
+    add     pc, pc, r0, lsl #3          @ computed goto, 2 instrs each
+    bl      common_abort                @ (skipped due to ARM prefetch)
+4:  add     ip, r9, #3                  @ base+3
+    GET_VREG(r3, ip)                    @ r3<- vBase[3]
+3:  add     ip, r9, #2                  @ base+2
+    GET_VREG(r2, ip)                    @ r2<- vBase[2]
+2:  add     ip, r9, #1                  @ base+1
+    GET_VREG(r1, ip)                    @ r1<- vBase[1]
+1:  add     ip, r9, #0                  @ (nop)
+    GET_VREG(r0, ip)                    @ r0<- vBase[0]
+0:
+    ldr     r9, .LOP_EXECUTE_INLINE_RANGE_table       @ table of InlineOperation
+    ldr     pc, [r9, r10, lsl #4]       @ sizeof=16, "func" is first entry
+    @ (not reached)
 
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_74FF: /* 0x174 */
-/* File: armv5te/OP_UNUSED_74FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * We're debugging or profiling.
+     * r10: opIndex
+     */
+.LOP_EXECUTE_INLINE_RANGE_debugmode:
+    mov     r0, r10
+    bl      dvmResolveInlineNative
+    cmp     r0, #0                      @ did it resolve?
+    beq     .LOP_EXECUTE_INLINE_RANGE_resume          @ no, just move on
+    mov     r9, r0                      @ remember method
+    mov     r1, rSELF
+    bl      dvmFastMethodTraceEnter     @ (method, self)
+    add     r1, rSELF, #offThread_retval@ r1<- &self->retval
+    sub     sp, sp, #8                  @ make room for arg, +64 bit align
+    mov     r0, rINST, lsr #8           @ r0<- B
+    mov     rINST, r9                   @ rINST<- method
+    str     r1, [sp]                    @ push &self->retval
+    bl      .LOP_EXECUTE_INLINE_RANGE_continue        @ make call; will return after
+    mov     r9, r0                      @ save result of inline
+    add     sp, sp, #8                  @ pop stack
+    mov     r0, rINST                   @ r0<- method
+    mov     r1, rSELF
+    bl      dvmFastNativeMethodTraceExit  @ (method, self)
+    cmp     r9, #0                      @ test boolean result of inline
+    beq     common_exceptionThrown      @ returned false, handle exception
+    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_75FF: /* 0x175 */
-/* File: armv5te/OP_UNUSED_75FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
 
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_76FF: /* 0x176 */
-/* File: armv5te/OP_UNUSED_76FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+.LOP_EXECUTE_INLINE_RANGE_table:
+    .word   gDvmInlineOpsTable
 
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_77FF: /* 0x177 */
-/* File: armv5te/OP_UNUSED_77FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_INVOKE_OBJECT_INIT_RANGE */
 
+.LOP_INVOKE_OBJECT_INIT_RANGE_setFinal:
+    EXPORT_PC()                         @ can throw
+    bl      dvmSetFinalizable           @ call dvmSetFinalizable(obj)
+    ldr     r0, [rSELF, #offThread_exception] @ r0<- self->exception
+    cmp     r0, #0                      @ exception pending?
+    bne     common_exceptionThrown      @ yes, handle it
+    b       .LOP_INVOKE_OBJECT_INIT_RANGE_finish
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_78FF: /* 0x178 */
-/* File: armv5te/OP_UNUSED_78FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * A debugger is attached, so we need to go ahead and do
+     * this.  For simplicity, we'll just jump directly to the
+     * corresponding handler.  Note that we can't use
+     * rIBASE here because it may be in single-step mode.
+     * Load the primary table base directly.
+     */
+.LOP_INVOKE_OBJECT_INIT_RANGE_debugger:
+    ldr     r1, [rSELF, #offThread_mainHandlerTable]
+    mov     ip, #OP_INVOKE_DIRECT_RANGE
+    GOTO_OPCODE_BASE(r1,ip)             @ execute it
 
+/* continuation for OP_IPUT_OBJECT_VOLATILE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_79FF: /* 0x179 */
-/* File: armv5te/OP_UNUSED_79FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_7AFF: /* 0x17a */
-/* File: armv5te/OP_UNUSED_7AFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_7BFF: /* 0x17b */
-/* File: armv5te/OP_UNUSED_7BFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_7CFF: /* 0x17c */
-/* File: armv5te/OP_UNUSED_7CFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_7DFF: /* 0x17d */
-/* File: armv5te/OP_UNUSED_7DFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_7EFF: /* 0x17e */
-/* File: armv5te/OP_UNUSED_7EFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_7FFF: /* 0x17f */
-/* File: armv5te/OP_UNUSED_7FFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_80FF: /* 0x180 */
-/* File: armv5te/OP_UNUSED_80FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_81FF: /* 0x181 */
-/* File: armv5te/OP_UNUSED_81FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_82FF: /* 0x182 */
-/* File: armv5te/OP_UNUSED_82FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_83FF: /* 0x183 */
-/* File: armv5te/OP_UNUSED_83FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_84FF: /* 0x184 */
-/* File: armv5te/OP_UNUSED_84FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_85FF: /* 0x185 */
-/* File: armv5te/OP_UNUSED_85FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_86FF: /* 0x186 */
-/* File: armv5te/OP_UNUSED_86FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_87FF: /* 0x187 */
-/* File: armv5te/OP_UNUSED_87FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_88FF: /* 0x188 */
-/* File: armv5te/OP_UNUSED_88FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_89FF: /* 0x189 */
-/* File: armv5te/OP_UNUSED_89FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_8AFF: /* 0x18a */
-/* File: armv5te/OP_UNUSED_8AFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_8BFF: /* 0x18b */
-/* File: armv5te/OP_UNUSED_8BFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_8CFF: /* 0x18c */
-/* File: armv5te/OP_UNUSED_8CFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_8DFF: /* 0x18d */
-/* File: armv5te/OP_UNUSED_8DFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_8EFF: /* 0x18e */
-/* File: armv5te/OP_UNUSED_8EFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_8FFF: /* 0x18f */
-/* File: armv5te/OP_UNUSED_8FFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_90FF: /* 0x190 */
-/* File: armv5te/OP_UNUSED_90FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_91FF: /* 0x191 */
-/* File: armv5te/OP_UNUSED_91FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_92FF: /* 0x192 */
-/* File: armv5te/OP_UNUSED_92FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_93FF: /* 0x193 */
-/* File: armv5te/OP_UNUSED_93FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_94FF: /* 0x194 */
-/* File: armv5te/OP_UNUSED_94FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_95FF: /* 0x195 */
-/* File: armv5te/OP_UNUSED_95FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_96FF: /* 0x196 */
-/* File: armv5te/OP_UNUSED_96FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_97FF: /* 0x197 */
-/* File: armv5te/OP_UNUSED_97FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_98FF: /* 0x198 */
-/* File: armv5te/OP_UNUSED_98FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_99FF: /* 0x199 */
-/* File: armv5te/OP_UNUSED_99FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_9AFF: /* 0x19a */
-/* File: armv5te/OP_UNUSED_9AFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_9BFF: /* 0x19b */
-/* File: armv5te/OP_UNUSED_9BFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_9CFF: /* 0x19c */
-/* File: armv5te/OP_UNUSED_9CFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_9DFF: /* 0x19d */
-/* File: armv5te/OP_UNUSED_9DFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_9EFF: /* 0x19e */
-/* File: armv5te/OP_UNUSED_9EFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_9FFF: /* 0x19f */
-/* File: armv5te/OP_UNUSED_9FFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A0FF: /* 0x1a0 */
-/* File: armv5te/OP_UNUSED_A0FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A1FF: /* 0x1a1 */
-/* File: armv5te/OP_UNUSED_A1FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A2FF: /* 0x1a2 */
-/* File: armv5te/OP_UNUSED_A2FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A3FF: /* 0x1a3 */
-/* File: armv5te/OP_UNUSED_A3FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A4FF: /* 0x1a4 */
-/* File: armv5te/OP_UNUSED_A4FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A5FF: /* 0x1a5 */
-/* File: armv5te/OP_UNUSED_A5FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A6FF: /* 0x1a6 */
-/* File: armv5te/OP_UNUSED_A6FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A7FF: /* 0x1a7 */
-/* File: armv5te/OP_UNUSED_A7FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A8FF: /* 0x1a8 */
-/* File: armv5te/OP_UNUSED_A8FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A9FF: /* 0x1a9 */
-/* File: armv5te/OP_UNUSED_A9FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_AAFF: /* 0x1aa */
-/* File: armv5te/OP_UNUSED_AAFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_ABFF: /* 0x1ab */
-/* File: armv5te/OP_UNUSED_ABFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_ACFF: /* 0x1ac */
-/* File: armv5te/OP_UNUSED_ACFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_ADFF: /* 0x1ad */
-/* File: armv5te/OP_UNUSED_ADFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_AEFF: /* 0x1ae */
-/* File: armv5te/OP_UNUSED_AEFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_AFFF: /* 0x1af */
-/* File: armv5te/OP_UNUSED_AFFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B0FF: /* 0x1b0 */
-/* File: armv5te/OP_UNUSED_B0FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B1FF: /* 0x1b1 */
-/* File: armv5te/OP_UNUSED_B1FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B2FF: /* 0x1b2 */
-/* File: armv5te/OP_UNUSED_B2FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B3FF: /* 0x1b3 */
-/* File: armv5te/OP_UNUSED_B3FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B4FF: /* 0x1b4 */
-/* File: armv5te/OP_UNUSED_B4FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B5FF: /* 0x1b5 */
-/* File: armv5te/OP_UNUSED_B5FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B6FF: /* 0x1b6 */
-/* File: armv5te/OP_UNUSED_B6FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B7FF: /* 0x1b7 */
-/* File: armv5te/OP_UNUSED_B7FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B8FF: /* 0x1b8 */
-/* File: armv5te/OP_UNUSED_B8FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B9FF: /* 0x1b9 */
-/* File: armv5te/OP_UNUSED_B9FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_BAFF: /* 0x1ba */
-/* File: armv5te/OP_UNUSED_BAFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_BBFF: /* 0x1bb */
-/* File: armv5te/OP_UNUSED_BBFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_BCFF: /* 0x1bc */
-/* File: armv5te/OP_UNUSED_BCFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_BDFF: /* 0x1bd */
-/* File: armv5te/OP_UNUSED_BDFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_BEFF: /* 0x1be */
-/* File: armv5te/OP_UNUSED_BEFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_BFFF: /* 0x1bf */
-/* File: armv5te/OP_UNUSED_BFFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C0FF: /* 0x1c0 */
-/* File: armv5te/OP_UNUSED_C0FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C1FF: /* 0x1c1 */
-/* File: armv5te/OP_UNUSED_C1FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C2FF: /* 0x1c2 */
-/* File: armv5te/OP_UNUSED_C2FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C3FF: /* 0x1c3 */
-/* File: armv5te/OP_UNUSED_C3FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C4FF: /* 0x1c4 */
-/* File: armv5te/OP_UNUSED_C4FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C5FF: /* 0x1c5 */
-/* File: armv5te/OP_UNUSED_C5FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C6FF: /* 0x1c6 */
-/* File: armv5te/OP_UNUSED_C6FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C7FF: /* 0x1c7 */
-/* File: armv5te/OP_UNUSED_C7FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C8FF: /* 0x1c8 */
-/* File: armv5te/OP_UNUSED_C8FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C9FF: /* 0x1c9 */
-/* File: armv5te/OP_UNUSED_C9FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_CAFF: /* 0x1ca */
-/* File: armv5te/OP_UNUSED_CAFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_CBFF: /* 0x1cb */
-/* File: armv5te/OP_UNUSED_CBFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_CCFF: /* 0x1cc */
-/* File: armv5te/OP_UNUSED_CCFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_CDFF: /* 0x1cd */
-/* File: armv5te/OP_UNUSED_CDFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_CEFF: /* 0x1ce */
-/* File: armv5te/OP_UNUSED_CEFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_CFFF: /* 0x1cf */
-/* File: armv5te/OP_UNUSED_CFFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D0FF: /* 0x1d0 */
-/* File: armv5te/OP_UNUSED_D0FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D1FF: /* 0x1d1 */
-/* File: armv5te/OP_UNUSED_D1FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D2FF: /* 0x1d2 */
-/* File: armv5te/OP_UNUSED_D2FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D3FF: /* 0x1d3 */
-/* File: armv5te/OP_UNUSED_D3FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D4FF: /* 0x1d4 */
-/* File: armv5te/OP_UNUSED_D4FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D5FF: /* 0x1d5 */
-/* File: armv5te/OP_UNUSED_D5FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D6FF: /* 0x1d6 */
-/* File: armv5te/OP_UNUSED_D6FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D7FF: /* 0x1d7 */
-/* File: armv5te/OP_UNUSED_D7FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D8FF: /* 0x1d8 */
-/* File: armv5te/OP_UNUSED_D8FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D9FF: /* 0x1d9 */
-/* File: armv5te/OP_UNUSED_D9FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_DAFF: /* 0x1da */
-/* File: armv5te/OP_UNUSED_DAFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_DBFF: /* 0x1db */
-/* File: armv5te/OP_UNUSED_DBFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_DCFF: /* 0x1dc */
-/* File: armv5te/OP_UNUSED_DCFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_DDFF: /* 0x1dd */
-/* File: armv5te/OP_UNUSED_DDFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_DEFF: /* 0x1de */
-/* File: armv5te/OP_UNUSED_DEFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_DFFF: /* 0x1df */
-/* File: armv5te/OP_UNUSED_DFFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E0FF: /* 0x1e0 */
-/* File: armv5te/OP_UNUSED_E0FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E1FF: /* 0x1e1 */
-/* File: armv5te/OP_UNUSED_E1FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E2FF: /* 0x1e2 */
-/* File: armv5te/OP_UNUSED_E2FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E3FF: /* 0x1e3 */
-/* File: armv5te/OP_UNUSED_E3FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E4FF: /* 0x1e4 */
-/* File: armv5te/OP_UNUSED_E4FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E5FF: /* 0x1e5 */
-/* File: armv5te/OP_UNUSED_E5FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E6FF: /* 0x1e6 */
-/* File: armv5te/OP_UNUSED_E6FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E7FF: /* 0x1e7 */
-/* File: armv5te/OP_UNUSED_E7FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E8FF: /* 0x1e8 */
-/* File: armv5te/OP_UNUSED_E8FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E9FF: /* 0x1e9 */
-/* File: armv5te/OP_UNUSED_E9FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_EAFF: /* 0x1ea */
-/* File: armv5te/OP_UNUSED_EAFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_EBFF: /* 0x1eb */
-/* File: armv5te/OP_UNUSED_EBFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_ECFF: /* 0x1ec */
-/* File: armv5te/OP_UNUSED_ECFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_EDFF: /* 0x1ed */
-/* File: armv5te/OP_UNUSED_EDFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_EEFF: /* 0x1ee */
-/* File: armv5te/OP_UNUSED_EEFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_EFFF: /* 0x1ef */
-/* File: armv5te/OP_UNUSED_EFFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_F0FF: /* 0x1f0 */
-/* File: armv5te/OP_UNUSED_F0FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_F1FF: /* 0x1f1 */
-/* File: armv5te/OP_UNUSED_F1FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_INVOKE_OBJECT_INIT_JUMBO: /* 0x1f2 */
-/* File: armv5te/OP_INVOKE_OBJECT_INIT_JUMBO.S */
-/* File: armv5te/OP_INVOKE_OBJECT_INIT_RANGE.S */
-    /*
-     * Invoke Object.<init> on an object.  In practice we know that
-     * Object's nullary constructor doesn't do anything, so we just
-     * skip it unless a debugger is active.
-     */
-    FETCH(r1, 4)                  @ r1<- CCCC
-    GET_VREG(r0, r1)                    @ r0<- "this" ptr
-    cmp     r0, #0                      @ check for NULL
-    beq     common_errNullObject        @ export PC and throw NPE
-    ldr     r1, [r0, #offObject_clazz]  @ r1<- obj->clazz
-    ldr     r2, [r1, #offClassObject_accessFlags] @ r2<- clazz->accessFlags
-    tst     r2, #CLASS_ISFINALIZABLE    @ is this class finalizable?
-    bne     .LOP_INVOKE_OBJECT_INIT_JUMBO_setFinal        @ yes, go
-.LOP_INVOKE_OBJECT_INIT_JUMBO_finish:
-    ldrh    r1, [rSELF, #offThread_subMode]
-    ands    r1, #kSubModeDebuggerActive @ debugger active?
-    bne     .LOP_INVOKE_OBJECT_INIT_JUMBO_debugger        @ Yes - skip optimization
-    FETCH_ADVANCE_INST(4+1)       @ advance to next instr, load rINST
-    GET_INST_OPCODE(ip)                 @ ip<- opcode from rINST
-    GOTO_OPCODE(ip)                     @ execute it
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_VOLATILE_JUMBO: /* 0x1f3 */
-/* File: armv5te/OP_IGET_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_IGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit instance field get.
-     *
-     * for: iget/jumbo, iget-object/jumbo, iget-boolean/jumbo, iget-byte/jumbo,
-     *      iget-char/jumbo, iget-short/jumbo
-     */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_VOLATILE_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_VOLATILE_JUMBO_resolved        @ resolved, continue
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_WIDE_VOLATILE_JUMBO: /* 0x1f4 */
-/* File: armv5te/OP_IGET_WIDE_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_IGET_WIDE_JUMBO.S */
-    /*
-     * Jumbo 64-bit instance field get.
-     */
-    /* iget-wide/jumbo vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_WIDE_VOLATILE_JUMBO_finish          @ no, already resolved
-    ldr     r2, [rSELF, #offThread_method] @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_WIDE_VOLATILE_JUMBO_resolved        @ resolved, continue
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_OBJECT_VOLATILE_JUMBO: /* 0x1f5 */
-/* File: armv5te/OP_IGET_OBJECT_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_IGET_OBJECT_JUMBO.S */
-/* File: armv5te/OP_IGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit instance field get.
-     *
-     * for: iget/jumbo, iget-object/jumbo, iget-boolean/jumbo, iget-byte/jumbo,
-     *      iget-char/jumbo, iget-short/jumbo
-     */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_OBJECT_VOLATILE_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_OBJECT_VOLATILE_JUMBO_resolved        @ resolved, continue
-
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_VOLATILE_JUMBO: /* 0x1f6 */
-/* File: armv5te/OP_IPUT_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_IPUT_JUMBO.S */
-    /*
-     * Jumbo 32-bit instance field put.
-     *
-     * for: iput/jumbo, iput-boolean/jumbo, iput-byte/jumbo, iput-char/jumbo,
-     *      iput-short/jumbo
-     */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_VOLATILE_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_VOLATILE_JUMBO_resolved        @ resolved, continue
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_WIDE_VOLATILE_JUMBO: /* 0x1f7 */
-/* File: armv5te/OP_IPUT_WIDE_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_IPUT_WIDE_JUMBO.S */
-    /* iput-wide/jumbo vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_WIDE_VOLATILE_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method] @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_WIDE_VOLATILE_JUMBO_resolved        @ resolved, continue
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_OBJECT_VOLATILE_JUMBO: /* 0x1f8 */
-/* File: armv5te/OP_IPUT_OBJECT_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_IPUT_OBJECT_JUMBO.S */
-    /*
-     * Jumbo 32-bit instance field put.
-     */
-    /* iput-object/jumbo vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_OBJECT_VOLATILE_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_OBJECT_VOLATILE_JUMBO_resolved        @ resolved, continue
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_VOLATILE_JUMBO: /* 0x1f9 */
-/* File: armv5te/OP_SGET_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_SGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit SGET handler.
-     *
-     * for: sget/jumbo, sget-object/jumbo, sget-boolean/jumbo, sget-byte/jumbo,
-     *      sget-char/jumbo, sget-short/jumbo
-     */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_VOLATILE_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_VOLATILE_JUMBO_finish: @ field ptr in r0
-    ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    SMP_DMB                            @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    SET_VREG(r1, r2)                    @ fp[BBBB]<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_WIDE_VOLATILE_JUMBO: /* 0x1fa */
-/* File: armv5te/OP_SGET_WIDE_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_SGET_WIDE_JUMBO.S */
-    /*
-     * Jumbo 64-bit SGET handler.
-     */
-    /* sget-wide/jumbo vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r2, [r2, #offDvmDex_pResFields] @ r2<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_WIDE_VOLATILE_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_WIDE_VOLATILE_JUMBO_finish:
-    FETCH(r9, 3)                        @ r9<- BBBB
-    .if 1
-    add     r0, r0, #offStaticField_value @ r0<- pointer to data
-    bl      dvmQuasiAtomicRead64        @ r0/r1<- contents of field
-    .else
-    ldrd    r0, [r0, #offStaticField_value] @ r0/r1<- field value (aligned)
-    .endif
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[BBBB]
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    stmia   r9, {r0-r1}                 @ vBBBB/vBBBB+1<- r0/r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_OBJECT_VOLATILE_JUMBO: /* 0x1fb */
-/* File: armv5te/OP_SGET_OBJECT_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_SGET_OBJECT_JUMBO.S */
-/* File: armv5te/OP_SGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit SGET handler.
-     *
-     * for: sget/jumbo, sget-object/jumbo, sget-boolean/jumbo, sget-byte/jumbo,
-     *      sget-char/jumbo, sget-short/jumbo
-     */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_OBJECT_VOLATILE_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_OBJECT_VOLATILE_JUMBO_finish: @ field ptr in r0
-    ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    SMP_DMB                            @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    SET_VREG(r1, r2)                    @ fp[BBBB]<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_VOLATILE_JUMBO: /* 0x1fc */
-/* File: armv5te/OP_SPUT_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_SPUT_JUMBO.S */
-    /*
-     * Jumbo 32-bit SPUT handler.
-     *
-     * for: sput/jumbo, sput-boolean/jumbo, sput-byte/jumbo, sput-char/jumbo,
-     *      sput-short/jumbo
-     */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]        @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_VOLATILE_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_VOLATILE_JUMBO_finish:   @ field ptr in r0
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_VREG(r1, r2)                    @ r1<- fp[BBBB]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SMP_DMB_ST                        @ releasing store
-    str     r1, [r0, #offStaticField_value] @ field<- vBBBB
-    SMP_DMB
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_WIDE_VOLATILE_JUMBO: /* 0x1fd */
-/* File: armv5te/OP_SPUT_WIDE_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_SPUT_WIDE_JUMBO.S */
-    /*
-     * Jumbo 64-bit SPUT handler.
-     */
-    /* sput-wide/jumbo vBBBB, field@AAAAAAAA */
-    ldr     r0, [rSELF, #offThread_methodClassDex]  @ r0<- DvmDex
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    ldr     r10, [r0, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    FETCH(r9, 3)                        @ r9<- BBBB
-    ldr     r2, [r10, r1, lsl #2]       @ r2<- resolved StaticField ptr
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[BBBB]
-    cmp     r2, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_WIDE_VOLATILE_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_WIDE_VOLATILE_JUMBO_finish: @ field ptr in r2, BBBB in r9
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vBBBB/vBBBB+1
-    GET_INST_OPCODE(r10)                @ extract opcode from rINST
-    .if 1
-    add     r2, r2, #offStaticField_value @ r2<- pointer to data
-    bl      dvmQuasiAtomicSwap64Sync    @ stores r0/r1 into addr r2
-    .else
-    strd    r0, [r2, #offStaticField_value] @ field<- vBBBB/vBBBB+1
-    .endif
-    GOTO_OPCODE(r10)                    @ jump to next instruction
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_OBJECT_VOLATILE_JUMBO: /* 0x1fe */
-/* File: armv5te/OP_SPUT_OBJECT_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_SPUT_OBJECT_JUMBO.S */
-    /*
-     * Jumbo 32-bit SPUT handler for objects
-     */
-    /* sput-object/jumbo vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_OBJECT_VOLATILE_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_OBJECT_VOLATILE_JUMBO_finish:   @ field ptr in r0
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_VREG(r1, r2)                    @ r1<- fp[BBBB]
-    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
-    ldr     r9, [r0, #offField_clazz]   @ r9<- field->clazz
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SMP_DMB_ST                        @ releasing store
-    b       .LOP_SPUT_OBJECT_VOLATILE_JUMBO_end
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_THROW_VERIFICATION_ERROR_JUMBO: /* 0x1ff */
-/* File: armv5te/OP_THROW_VERIFICATION_ERROR_JUMBO.S */
-    /*
-     * Handle a jumbo throw-verification-error instruction.  This throws an
-     * exception for an error discovered during verification.  The
-     * exception is indicated by BBBB, with some detail provided by AAAAAAAA.
-     */
-    /* exop BBBB, Class@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    ldr     r0, [rSELF, #offThread_method]    @ r0<- self->method
-    orr     r2, r1, r2, lsl #16         @ r2<- AAAAaaaa
-    EXPORT_PC()                         @ export the PC
-    FETCH(r1, 3)                        @ r1<- BBBB
-    bl      dvmThrowVerificationError   @ always throws
-    b       common_exceptionThrown      @ handle exception
-
-    .balign 64
-    .size   dvmAsmInstructionStart, .-dvmAsmInstructionStart
-    .global dvmAsmInstructionEnd
-dvmAsmInstructionEnd:
-
-/*
- * ===========================================================================
- *  Sister implementations
- * ===========================================================================
- */
-    .global dvmAsmSisterStart
-    .type   dvmAsmSisterStart, %function
-    .text
-    .balign 4
-dvmAsmSisterStart:
-
-/* continuation for OP_CONST_STRING */
-
-    /*
-     * Continuation if the String has not yet been resolved.
-     *  r1: BBBB (String ref)
-     *  r9: target register
-     */
-.LOP_CONST_STRING_resolve:
-    EXPORT_PC()
-    ldr     r0, [rSELF, #offThread_method] @ r0<- self->method
-    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveString            @ r0<- String reference
-    cmp     r0, #0                      @ failed?
-    beq     common_exceptionThrown      @ yup, handle the exception
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r9)                    @ vAA<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_CONST_STRING_JUMBO */
-
-    /*
-     * Continuation if the String has not yet been resolved.
-     *  r1: BBBBBBBB (String ref)
-     *  r9: target register
-     */
-.LOP_CONST_STRING_JUMBO_resolve:
-    EXPORT_PC()
-    ldr     r0, [rSELF, #offThread_method] @ r0<- self->method
-    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveString            @ r0<- String reference
-    cmp     r0, #0                      @ failed?
-    beq     common_exceptionThrown      @ yup, handle the exception
-    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r9)                    @ vAA<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_CONST_CLASS */
-
-    /*
-     * Continuation if the Class has not yet been resolved.
-     *  r1: BBBB (Class ref)
-     *  r9: target register
-     */
-.LOP_CONST_CLASS_resolve:
-    EXPORT_PC()
-    ldr     r0, [rSELF, #offThread_method] @ r0<- self->method
-    mov     r2, #1                      @ r2<- true
-    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- Class reference
-    cmp     r0, #0                      @ failed?
-    beq     common_exceptionThrown      @ yup, handle the exception
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r9)                    @ vAA<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_CHECK_CAST */
-
-    /*
-     * Trivial test failed, need to perform full check.  This is common.
-     *  r0 holds obj->clazz
-     *  r1 holds desired class resolved from BBBB
-     *  r9 holds object
-     */
-.LOP_CHECK_CAST_fullcheck:
-    mov     r10, r1                     @ avoid ClassObject getting clobbered
-    bl      dvmInstanceofNonTrivial     @ r0<- boolean result
-    cmp     r0, #0                      @ failed?
-    bne     .LOP_CHECK_CAST_okay            @ no, success
-
-    @ A cast has failed.  We need to throw a ClassCastException.
-    EXPORT_PC()                         @ about to throw
-    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz (actual class)
-    mov     r1, r10                     @ r1<- desired class
-    bl      dvmThrowClassCastException
-    b       common_exceptionThrown
-
-    /*
-     * Resolution required.  This is the least-likely path.
-     *
-     *  r2 holds BBBB
-     *  r9 holds object
-     */
-.LOP_CHECK_CAST_resolve:
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    mov     r1, r2                      @ r1<- BBBB
-    mov     r2, #0                      @ r2<- false
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
-    cmp     r0, #0                      @ got null?
-    beq     common_exceptionThrown      @ yes, handle exception
-    mov     r1, r0                      @ r1<- class resolved from BBB
-    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz
-    b       .LOP_CHECK_CAST_resolved        @ pick up where we left off
-
-/* continuation for OP_INSTANCE_OF */
-
-    /*
-     * Trivial test failed, need to perform full check.  This is common.
-     *  r0 holds obj->clazz
-     *  r1 holds class resolved from BBBB
-     *  r9 holds A
-     */
-.LOP_INSTANCE_OF_fullcheck:
-    bl      dvmInstanceofNonTrivial     @ r0<- boolean result
-    @ fall through to OP_INSTANCE_OF_store
-
-    /*
-     * r0 holds boolean result
-     * r9 holds A
-     */
-.LOP_INSTANCE_OF_store:
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    SET_VREG(r0, r9)                    @ vA<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /*
-     * Trivial test succeeded, save and bail.
-     *  r9 holds A
-     */
-.LOP_INSTANCE_OF_trivial:
-    mov     r0, #1                      @ indicate success
-    @ could b OP_INSTANCE_OF_store, but copying is faster and cheaper
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    SET_VREG(r0, r9)                    @ vA<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /*
-     * Resolution required.  This is the least-likely path.
-     *
-     *  r3 holds BBBB
-     *  r9 holds A
-     */
-.LOP_INSTANCE_OF_resolve:
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [rSELF, #offThread_method]    @ r0<- self->method
-    mov     r1, r3                      @ r1<- BBBB
-    mov     r2, #1                      @ r2<- true
-    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
-    cmp     r0, #0                      @ got null?
-    beq     common_exceptionThrown      @ yes, handle exception
-    mov     r1, r0                      @ r1<- class resolved from BBB
-    mov     r3, rINST, lsr #12          @ r3<- B
-    GET_VREG(r0, r3)                    @ r0<- vB (object)
-    ldr     r0, [r0, #offObject_clazz]  @ r0<- obj->clazz
-    b       .LOP_INSTANCE_OF_resolved        @ pick up where we left off
-
-/* continuation for OP_NEW_INSTANCE */
-
-    .balign 32                          @ minimize cache lines
-.LOP_NEW_INSTANCE_finish: @ r0=new object
-    mov     r3, rINST, lsr #8           @ r3<- AA
-    cmp     r0, #0                      @ failed?
-#if defined(WITH_JIT)
-    /*
-     * The JIT needs the class to be fully resolved before it can
-     * include this instruction in a trace.
-     */
-    ldrh    r1, [rSELF, #offThread_subMode]
-    beq     common_exceptionThrown      @ yes, handle the exception
-    ands    r1, #kSubModeJitTraceBuild  @ under construction?
-    bne     .LOP_NEW_INSTANCE_jitCheck
-#else
-    beq     common_exceptionThrown      @ yes, handle the exception
-#endif
-.LOP_NEW_INSTANCE_end:
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r3)                    @ vAA<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-#if defined(WITH_JIT)
-    /*
-     * Check to see if we need to stop the trace building early.
-     * r0: new object
-     * r3: vAA
-     */
-.LOP_NEW_INSTANCE_jitCheck:
-    ldr     r1, [r10]                   @ reload resolved class
-    cmp     r1, #0                      @ okay?
-    bne     .LOP_NEW_INSTANCE_end             @ yes, finish
-    mov     r9, r0                      @ preserve new object
-    mov     r10, r3                     @ preserve vAA
-    mov     r0, rSELF
-    mov     r1, rPC
-    bl      dvmJitEndTraceSelect        @ (self, pc)
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r9, r10)                   @ vAA<- new object
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-#endif
-
-    /*
-     * Class initialization required.
-     *
-     *  r0 holds class object
-     */
-.LOP_NEW_INSTANCE_needinit:
-    mov     r9, r0                      @ save r0
-    bl      dvmInitClass                @ initialize class
-    cmp     r0, #0                      @ check boolean result
-    mov     r0, r9                      @ restore r0
-    bne     .LOP_NEW_INSTANCE_initialized     @ success, continue
-    b       common_exceptionThrown      @ failed, deal with init exception
-
-    /*
-     * Resolution required.  This is the least-likely path.
-     *
-     *  r1 holds BBBB
-     */
-.LOP_NEW_INSTANCE_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    mov     r2, #0                      @ r2<- false
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_NEW_INSTANCE_resolved        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-/* continuation for OP_NEW_ARRAY */
-
-
-    /*
-     * Resolve class.  (This is an uncommon case.)
-     *
-     *  r1 holds array length
-     *  r2 holds class ref CCCC
-     */
-.LOP_NEW_ARRAY_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    mov     r9, r1                      @ r9<- length (save)
-    mov     r1, r2                      @ r1<- CCCC
-    mov     r2, #0                      @ r2<- false
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- call(clazz, ref)
-    cmp     r0, #0                      @ got null?
-    mov     r1, r9                      @ r1<- length (restore)
-    beq     common_exceptionThrown      @ yes, handle exception
-    @ fall through to OP_NEW_ARRAY_finish
-
-    /*
-     * Finish allocation.
-     *
-     *  r0 holds class
-     *  r1 holds array length
-     */
-.LOP_NEW_ARRAY_finish:
-    mov     r2, #ALLOC_DONT_TRACK       @ don't track in local refs table
-    bl      dvmAllocArrayByClass        @ r0<- call(clazz, length, flags)
-    cmp     r0, #0                      @ failed?
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    beq     common_exceptionThrown      @ yes, handle the exception
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ vA<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_FILLED_NEW_ARRAY */
-
-    /*
-     * On entry:
-     *  r0 holds array class
-     *  r10 holds AA or BA
-     */
-.LOP_FILLED_NEW_ARRAY_continue:
-    ldr     r3, [r0, #offClassObject_descriptor] @ r3<- arrayClass->descriptor
-    mov     r2, #ALLOC_DONT_TRACK       @ r2<- alloc flags
-    ldrb    rINST, [r3, #1]             @ rINST<- descriptor[1]
-    .if     0
-    mov     r1, r10                     @ r1<- AA (length)
-    .else
-    mov     r1, r10, lsr #4             @ r1<- B (length)
-    .endif
-    cmp     rINST, #'I'                 @ array of ints?
-    cmpne   rINST, #'L'                 @ array of objects?
-    cmpne   rINST, #'['                 @ array of arrays?
-    mov     r9, r1                      @ save length in r9
-    bne     .LOP_FILLED_NEW_ARRAY_notimpl         @ no, not handled yet
-    bl      dvmAllocArrayByClass        @ r0<- call(arClass, length, flags)
-    cmp     r0, #0                      @ null return?
-    beq     common_exceptionThrown      @ alloc failed, handle exception
-
-    FETCH(r1, 2)                        @ r1<- FEDC or CCCC
-    str     r0, [rSELF, #offThread_retval]      @ retval.l <- new array
-    str     rINST, [rSELF, #offThread_retval+4] @ retval.h <- type
-    add     r0, r0, #offArrayObject_contents @ r0<- newArray->contents
-    subs    r9, r9, #1                  @ length--, check for neg
-    FETCH_ADVANCE_INST(3)               @ advance to next instr, load rINST
-    bmi     2f                          @ was zero, bail
-
-    @ copy values from registers into the array
-    @ r0=array, r1=CCCC/FEDC, r9=length (from AA or B), r10=AA/BA
-    .if     0
-    add     r2, rFP, r1, lsl #2         @ r2<- &fp[CCCC]
-1:  ldr     r3, [r2], #4                @ r3<- *r2++
-    subs    r9, r9, #1                  @ count--
-    str     r3, [r0], #4                @ *contents++ = vX
-    bpl     1b
-    @ continue at 2
-    .else
-    cmp     r9, #4                      @ length was initially 5?
-    and     r2, r10, #15                @ r2<- A
-    bne     1f                          @ <= 4 args, branch
-    GET_VREG(r3, r2)                    @ r3<- vA
-    sub     r9, r9, #1                  @ count--
-    str     r3, [r0, #16]               @ contents[4] = vA
-1:  and     r2, r1, #15                 @ r2<- F/E/D/C
-    GET_VREG(r3, r2)                    @ r3<- vF/vE/vD/vC
-    mov     r1, r1, lsr #4              @ r1<- next reg in low 4
-    subs    r9, r9, #1                  @ count--
-    str     r3, [r0], #4                @ *contents++ = vX
-    bpl     1b
-    @ continue at 2
-    .endif
-
-2:
-    ldr     r0, [rSELF, #offThread_retval]     @ r0<- object
-    ldr     r1, [rSELF, #offThread_retval+4]   @ r1<- type
-    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
-    GET_INST_OPCODE(ip)                      @ ip<- opcode from rINST
-    cmp     r1, #'I'                         @ Is int array?
-    strneb  r2, [r2, r0, lsr #GC_CARD_SHIFT] @ Mark card based on object head
-    GOTO_OPCODE(ip)                          @ execute it
-
-    /*
-     * Throw an exception indicating that we have not implemented this
-     * mode of filled-new-array.
-     */
-.LOP_FILLED_NEW_ARRAY_notimpl:
-    ldr     r0, .L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY
-    bl      dvmThrowInternalError
-    b       common_exceptionThrown
-
-    /*
-     * Ideally we'd only define this once, but depending on layout we can
-     * exceed the range of the load above.
-     */
-
-.L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY:
-    .word   .LstrFilledNewArrayNotImpl
-
-/* continuation for OP_FILLED_NEW_ARRAY_RANGE */
-
-    /*
-     * On entry:
-     *  r0 holds array class
-     *  r10 holds AA or BA
-     */
-.LOP_FILLED_NEW_ARRAY_RANGE_continue:
-    ldr     r3, [r0, #offClassObject_descriptor] @ r3<- arrayClass->descriptor
-    mov     r2, #ALLOC_DONT_TRACK       @ r2<- alloc flags
-    ldrb    rINST, [r3, #1]             @ rINST<- descriptor[1]
-    .if     1
-    mov     r1, r10                     @ r1<- AA (length)
-    .else
-    mov     r1, r10, lsr #4             @ r1<- B (length)
-    .endif
-    cmp     rINST, #'I'                 @ array of ints?
-    cmpne   rINST, #'L'                 @ array of objects?
-    cmpne   rINST, #'['                 @ array of arrays?
-    mov     r9, r1                      @ save length in r9
-    bne     .LOP_FILLED_NEW_ARRAY_RANGE_notimpl         @ no, not handled yet
-    bl      dvmAllocArrayByClass        @ r0<- call(arClass, length, flags)
-    cmp     r0, #0                      @ null return?
-    beq     common_exceptionThrown      @ alloc failed, handle exception
-
-    FETCH(r1, 2)                        @ r1<- FEDC or CCCC
-    str     r0, [rSELF, #offThread_retval]      @ retval.l <- new array
-    str     rINST, [rSELF, #offThread_retval+4] @ retval.h <- type
-    add     r0, r0, #offArrayObject_contents @ r0<- newArray->contents
-    subs    r9, r9, #1                  @ length--, check for neg
-    FETCH_ADVANCE_INST(3)               @ advance to next instr, load rINST
-    bmi     2f                          @ was zero, bail
-
-    @ copy values from registers into the array
-    @ r0=array, r1=CCCC/FEDC, r9=length (from AA or B), r10=AA/BA
-    .if     1
-    add     r2, rFP, r1, lsl #2         @ r2<- &fp[CCCC]
-1:  ldr     r3, [r2], #4                @ r3<- *r2++
-    subs    r9, r9, #1                  @ count--
-    str     r3, [r0], #4                @ *contents++ = vX
-    bpl     1b
-    @ continue at 2
-    .else
-    cmp     r9, #4                      @ length was initially 5?
-    and     r2, r10, #15                @ r2<- A
-    bne     1f                          @ <= 4 args, branch
-    GET_VREG(r3, r2)                    @ r3<- vA
-    sub     r9, r9, #1                  @ count--
-    str     r3, [r0, #16]               @ contents[4] = vA
-1:  and     r2, r1, #15                 @ r2<- F/E/D/C
-    GET_VREG(r3, r2)                    @ r3<- vF/vE/vD/vC
-    mov     r1, r1, lsr #4              @ r1<- next reg in low 4
-    subs    r9, r9, #1                  @ count--
-    str     r3, [r0], #4                @ *contents++ = vX
-    bpl     1b
-    @ continue at 2
-    .endif
-
-2:
-    ldr     r0, [rSELF, #offThread_retval]     @ r0<- object
-    ldr     r1, [rSELF, #offThread_retval+4]   @ r1<- type
-    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
-    GET_INST_OPCODE(ip)                      @ ip<- opcode from rINST
-    cmp     r1, #'I'                         @ Is int array?
-    strneb  r2, [r2, r0, lsr #GC_CARD_SHIFT] @ Mark card based on object head
-    GOTO_OPCODE(ip)                          @ execute it
-
-    /*
-     * Throw an exception indicating that we have not implemented this
-     * mode of filled-new-array.
-     */
-.LOP_FILLED_NEW_ARRAY_RANGE_notimpl:
-    ldr     r0, .L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY_RANGE
-    bl      dvmThrowInternalError
-    b       common_exceptionThrown
-
-    /*
-     * Ideally we'd only define this once, but depending on layout we can
-     * exceed the range of the load above.
-     */
-
-.L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY_RANGE:
-    .word   .LstrFilledNewArrayNotImpl
-
-/* continuation for OP_CMPL_FLOAT */
-.LOP_CMPL_FLOAT_finish:
-    SET_VREG(r0, r9)                    @ vAA<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_CMPG_FLOAT */
-.LOP_CMPG_FLOAT_finish:
-    SET_VREG(r0, r9)                    @ vAA<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_CMPL_DOUBLE */
-.LOP_CMPL_DOUBLE_finish:
-    SET_VREG(r0, r9)                    @ vAA<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_CMPG_DOUBLE */
-.LOP_CMPG_DOUBLE_finish:
-    SET_VREG(r0, r9)                    @ vAA<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_CMP_LONG */
-
-.LOP_CMP_LONG_less:
-    mvn     r1, #0                      @ r1<- -1
-    @ Want to cond code the next mov so we can avoid branch, but don't see it;
-    @ instead, we just replicate the tail end.
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    SET_VREG(r1, r9)                    @ vAA<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-.LOP_CMP_LONG_greater:
-    mov     r1, #1                      @ r1<- 1
-    @ fall through to _finish
-
-.LOP_CMP_LONG_finish:
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    SET_VREG(r1, r9)                    @ vAA<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_AGET_WIDE */
-
-.LOP_AGET_WIDE_finish:
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldrd    r2, [r0, #offArrayObject_contents]  @ r2/r3<- vBB[vCC]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r2-r3}                 @ vAA/vAA+1<- r2/r3
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_APUT_WIDE */
-
-.LOP_APUT_WIDE_finish:
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldmia   r9, {r2-r3}                 @ r2/r3<- vAA/vAA+1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    strd    r2, [r0, #offArrayObject_contents]  @ r2/r3<- vBB[vCC]
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_APUT_OBJECT */
-    /*
-     * On entry:
-     *  rINST = vBB (arrayObj)
-     *  r9 = vAA (obj)
-     *  r10 = offset into array (vBB + vCC * width)
-     */
-.LOP_APUT_OBJECT_finish:
-    cmp     r9, #0                      @ storing null reference?
-    beq     .LOP_APUT_OBJECT_skip_check      @ yes, skip type checks
-    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz
-    ldr     r1, [rINST, #offObject_clazz]  @ r1<- arrayObj->clazz
-    bl      dvmCanPutArrayElement       @ test object type vs. array type
-    cmp     r0, #0                      @ okay?
-    beq     .LOP_APUT_OBJECT_throw           @ no
-    mov     r1, rINST                   @ r1<- arrayObj
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldr     r2, [rSELF, #offThread_cardTable]     @ get biased CT base
-    add     r10, #offArrayObject_contents   @ r0<- pointer to slot
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    str     r9, [r10]                   @ vBB[vCC]<- vAA
-    strb    r2, [r2, r1, lsr #GC_CARD_SHIFT] @ mark card using object head
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-.LOP_APUT_OBJECT_skip_check:
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    str     r9, [r10, #offArrayObject_contents] @ vBB[vCC]<- vAA
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-.LOP_APUT_OBJECT_throw:
-    @ The types don't match.  We need to throw an ArrayStoreException.
-    ldr     r0, [r9, #offObject_clazz]
-    ldr     r1, [rINST, #offObject_clazz]
-    EXPORT_PC()
-    bl      dvmThrowArrayStoreExceptionIncompatibleElement
-    b       common_exceptionThrown
-
-/* continuation for OP_IGET */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_finish:
-    @bl      common_squeak0
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ fp[A]<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_WIDE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_WIDE_finish:
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    .if     0
-    add     r0, r9, r3                  @ r0<- address of field
-    bl      dvmQuasiAtomicRead64        @ r0/r1<- contents of field
-    .else
-    ldrd    r0, [r9, r3]                @ r0/r1<- obj.field (64-bit align ok)
-    .endif
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    add     r3, rFP, r2, lsl #2         @ r3<- &fp[A]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_OBJECT */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_OBJECT_finish:
-    @bl      common_squeak0
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ fp[A]<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_BOOLEAN */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_BOOLEAN_finish:
-    @bl      common_squeak1
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ fp[A]<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_BYTE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_BYTE_finish:
-    @bl      common_squeak2
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ fp[A]<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_CHAR */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_CHAR_finish:
-    @bl      common_squeak3
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ fp[A]<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_SHORT */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_SHORT_finish:
-    @bl      common_squeak4
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ fp[A]<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_finish:
-    @bl      common_squeak0
-    mov     r1, rINST, lsr #8           @ r1<- A+
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    and     r1, r1, #15                 @ r1<- A
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[A]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                         @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_WIDE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_WIDE_finish:
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    cmp     r9, #0                      @ check object for null
-    and     r2, r2, #15                 @ r2<- A
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    add     r2, rFP, r2, lsl #2         @ r3<- &fp[A]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[A]
-    GET_INST_OPCODE(r10)                @ extract opcode from rINST
-    .if     0
-    add     r2, r9, r3                  @ r2<- target address
-    bl      dvmQuasiAtomicSwap64Sync    @ stores r0/r1 into addr r2
-    .else
-    strd    r0, [r9, r3]                @ obj.field (64 bits, aligned)<- r0/r1
-    .endif
-    GOTO_OPCODE(r10)                    @ jump to next instruction
-
-/* continuation for OP_IPUT_OBJECT */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_OBJECT_finish:
-    @bl      common_squeak0
-    mov     r1, rINST, lsr #8           @ r1<- A+
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    and     r1, r1, #15                 @ r1<- A
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[A]
-    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                         @ releasing store
-    str     r0, [r9, r3]                @ obj.field (32 bits)<- r0
-    @ no-op 
-    cmp     r0, #0                      @ stored a null reference?
-    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card if not
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_BOOLEAN */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_BOOLEAN_finish:
-    @bl      common_squeak1
-    mov     r1, rINST, lsr #8           @ r1<- A+
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    and     r1, r1, #15                 @ r1<- A
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[A]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                         @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_BYTE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_BYTE_finish:
-    @bl      common_squeak2
-    mov     r1, rINST, lsr #8           @ r1<- A+
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    and     r1, r1, #15                 @ r1<- A
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[A]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                         @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_CHAR */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_CHAR_finish:
-    @bl      common_squeak3
-    mov     r1, rINST, lsr #8           @ r1<- A+
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    and     r1, r1, #15                 @ r1<- A
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[A]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                         @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_SHORT */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_SHORT_finish:
-    @bl      common_squeak4
-    mov     r1, rINST, lsr #8           @ r1<- A+
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    and     r1, r1, #15                 @ r1<- A
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[A]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                         @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_SGET */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_finish
-
-/* continuation for OP_SGET_WIDE */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     *
-     * Returns StaticField pointer in r0.
-     */
-.LOP_SGET_WIDE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r1<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_WIDE_finish          @ resume
-
-/* continuation for OP_SGET_OBJECT */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_OBJECT_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_OBJECT_finish
-
-/* continuation for OP_SGET_BOOLEAN */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_BOOLEAN_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_BOOLEAN_finish
-
-/* continuation for OP_SGET_BYTE */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_BYTE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_BYTE_finish
-
-/* continuation for OP_SGET_CHAR */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_CHAR_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_CHAR_finish
-
-/* continuation for OP_SGET_SHORT */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_SHORT_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_SHORT_finish
-
-/* continuation for OP_SPUT */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_finish          @ resume
-
-/* continuation for OP_SPUT_WIDE */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r9:  &fp[AA]
-     *  r10: dvmDex->pResFields
-     *
-     * Returns StaticField pointer in r2.
-     */
-.LOP_SPUT_WIDE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    mov     r2, r0                      @ copy to r2
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_WIDE_finish          @ resume
-
-/* continuation for OP_SPUT_OBJECT */
-
-
-.LOP_SPUT_OBJECT_end:
-    str     r1, [r0, #offStaticField_value]  @ field<- vAA
-    @ no-op 
-    cmp     r1, #0                      @ stored a null object?
-    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card based on obj head
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /* Continuation if the field has not yet been resolved.
-     * r1:  BBBB field ref
-     * r10: dvmDex->pResFields
-     */
-.LOP_SPUT_OBJECT_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_OBJECT_finish          @ resume
-
-
-/* continuation for OP_SPUT_BOOLEAN */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_BOOLEAN_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_BOOLEAN_finish          @ resume
-
-/* continuation for OP_SPUT_BYTE */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_BYTE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_BYTE_finish          @ resume
-
-/* continuation for OP_SPUT_CHAR */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_CHAR_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_CHAR_finish          @ resume
-
-/* continuation for OP_SPUT_SHORT */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_SHORT_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_SHORT_finish          @ resume
-
-/* continuation for OP_INVOKE_VIRTUAL */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r10 = C or CCCC (index of first arg, which is the "this" ptr)
-     */
-.LOP_INVOKE_VIRTUAL_continue:
-    GET_VREG(r9, r10)                   @ r9<- "this" ptr
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    cmp     r9, #0                      @ is "this" null?
-    beq     common_errNullObject        @ null "this", throw exception
-    ldr     r3, [r9, #offObject_clazz]  @ r3<- thisPtr->clazz
-    ldr     r3, [r3, #offClassObject_vtable]    @ r3<- thisPtr->clazz->vtable
-    ldr     r0, [r3, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodNoRange @ (r0=method, r9="this")
-
-/* continuation for OP_INVOKE_SUPER */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r10 = method->clazz
-     */
-.LOP_INVOKE_SUPER_continue:
-    ldr     r1, [r10, #offClassObject_super]    @ r1<- method->clazz->super
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    ldr     r3, [r1, #offClassObject_vtableCount]   @ r3<- super->vtableCount
-    EXPORT_PC()                         @ must export for invoke
-    cmp     r2, r3                      @ compare (methodIndex, vtableCount)
-    bcs     .LOP_INVOKE_SUPER_nsm             @ method not present in superclass
-    ldr     r1, [r1, #offClassObject_vtable]    @ r1<- ...clazz->super->vtable
-    ldr     r0, [r1, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodNoRange @ continue on
-
-.LOP_INVOKE_SUPER_resolve:
-    mov     r0, r10                     @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_SUPER_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-    /*
-     * Throw a NoSuchMethodError with the method name as the message.
-     *  r0 = resolved base method
-     */
-.LOP_INVOKE_SUPER_nsm:
-    ldr     r1, [r0, #offMethod_name]   @ r1<- method name
-    b       common_errNoSuchMethod
-
-/* continuation for OP_INVOKE_DIRECT */
-
-    /*
-     * On entry:
-     *  r1 = reference (BBBB or CCCC)
-     *  r10 = "this" register
-     */
-.LOP_INVOKE_DIRECT_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_DIRECT          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_DIRECT_finish          @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-/* continuation for OP_INVOKE_STATIC */
-
-
-.LOP_INVOKE_STATIC_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_STATIC          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-#if defined(WITH_JIT)
-    /*
-     * Check to see if we're actively building a trace.  If so,
-     * we need to keep this instruction out of it.
-     * r10: &resolved_methodToCall
-     */
-    ldrh    r2, [rSELF, #offThread_subMode]
-    beq     common_exceptionThrown            @ null, handle exception
-    ands    r2, #kSubModeJitTraceBuild        @ trace under construction?
-    beq     common_invokeMethodNoRange     @ no (r0=method, r9="this")
-    ldr     r1, [r10]                         @ reload resolved method
-    cmp     r1, #0                            @ finished resolving?
-    bne     common_invokeMethodNoRange     @ yes (r0=method, r9="this")
-    mov     r10, r0                           @ preserve method
-    mov     r0, rSELF
-    mov     r1, rPC
-    bl      dvmJitEndTraceSelect              @ (self, pc)
-    mov     r0, r10
-    b       common_invokeMethodNoRange     @ whew, finally!
-#else
-    bne     common_invokeMethodNoRange     @ (r0=method, r9="this")
-    b       common_exceptionThrown            @ yes, handle exception
-#endif
-
-/* continuation for OP_INVOKE_VIRTUAL_RANGE */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r10 = C or CCCC (index of first arg, which is the "this" ptr)
-     */
-.LOP_INVOKE_VIRTUAL_RANGE_continue:
-    GET_VREG(r9, r10)                   @ r9<- "this" ptr
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    cmp     r9, #0                      @ is "this" null?
-    beq     common_errNullObject        @ null "this", throw exception
-    ldr     r3, [r9, #offObject_clazz]  @ r3<- thisPtr->clazz
-    ldr     r3, [r3, #offClassObject_vtable]    @ r3<- thisPtr->clazz->vtable
-    ldr     r0, [r3, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodRange @ (r0=method, r9="this")
-
-/* continuation for OP_INVOKE_SUPER_RANGE */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r10 = method->clazz
-     */
-.LOP_INVOKE_SUPER_RANGE_continue:
-    ldr     r1, [r10, #offClassObject_super]    @ r1<- method->clazz->super
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    ldr     r3, [r1, #offClassObject_vtableCount]   @ r3<- super->vtableCount
-    EXPORT_PC()                         @ must export for invoke
-    cmp     r2, r3                      @ compare (methodIndex, vtableCount)
-    bcs     .LOP_INVOKE_SUPER_RANGE_nsm             @ method not present in superclass
-    ldr     r1, [r1, #offClassObject_vtable]    @ r1<- ...clazz->super->vtable
-    ldr     r0, [r1, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodRange @ continue on
-
-.LOP_INVOKE_SUPER_RANGE_resolve:
-    mov     r0, r10                     @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_SUPER_RANGE_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-    /*
-     * Throw a NoSuchMethodError with the method name as the message.
-     *  r0 = resolved base method
-     */
-.LOP_INVOKE_SUPER_RANGE_nsm:
-    ldr     r1, [r0, #offMethod_name]   @ r1<- method name
-    b       common_errNoSuchMethod
-
-/* continuation for OP_INVOKE_DIRECT_RANGE */
-
-    /*
-     * On entry:
-     *  r1 = reference (BBBB or CCCC)
-     *  r10 = "this" register
-     */
-.LOP_INVOKE_DIRECT_RANGE_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_DIRECT          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_DIRECT_RANGE_finish          @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-/* continuation for OP_INVOKE_STATIC_RANGE */
-
-
-.LOP_INVOKE_STATIC_RANGE_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_STATIC          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-#if defined(WITH_JIT)
-    /*
-     * Check to see if we're actively building a trace.  If so,
-     * we need to keep this instruction out of it.
-     * r10: &resolved_methodToCall
-     */
-    ldrh    r2, [rSELF, #offThread_subMode]
-    beq     common_exceptionThrown            @ null, handle exception
-    ands    r2, #kSubModeJitTraceBuild        @ trace under construction?
-    beq     common_invokeMethodRange     @ no (r0=method, r9="this")
-    ldr     r1, [r10]                         @ reload resolved method
-    cmp     r1, #0                            @ finished resolving?
-    bne     common_invokeMethodRange     @ yes (r0=method, r9="this")
-    mov     r10, r0                           @ preserve method
-    mov     r0, rSELF
-    mov     r1, rPC
-    bl      dvmJitEndTraceSelect              @ (self, pc)
-    mov     r0, r10
-    b       common_invokeMethodRange     @ whew, finally!
-#else
-    bne     common_invokeMethodRange     @ (r0=method, r9="this")
-    b       common_exceptionThrown            @ yes, handle exception
-#endif
-
-/* continuation for OP_FLOAT_TO_LONG */
-/*
- * Convert the float in r0 to a long in r0/r1.
- *
- * We have to clip values to long min/max per the specification.  The
- * expected common case is a "reasonable" value that converts directly
- * to modest integer.  The EABI convert function isn't doing this for us.
- */
-f2l_doconv:
-    stmfd   sp!, {r4, lr}
-    mov     r1, #0x5f000000             @ (float)maxlong
-    mov     r4, r0
-    bl      __aeabi_fcmpge              @ is arg >= maxlong?
-    cmp     r0, #0                      @ nonzero == yes
-    mvnne   r0, #0                      @ return maxlong (7fffffff)
-    mvnne   r1, #0x80000000
-    ldmnefd sp!, {r4, pc}
-
-    mov     r0, r4                      @ recover arg
-    mov     r1, #0xdf000000             @ (float)minlong
-    bl      __aeabi_fcmple              @ is arg <= minlong?
-    cmp     r0, #0                      @ nonzero == yes
-    movne   r0, #0                      @ return minlong (80000000)
-    movne   r1, #0x80000000
-    ldmnefd sp!, {r4, pc}
-
-    mov     r0, r4                      @ recover arg
-    mov     r1, r4
-    bl      __aeabi_fcmpeq              @ is arg == self?
-    cmp     r0, #0                      @ zero == no
-    moveq   r1, #0                      @ return zero for NaN
-    ldmeqfd sp!, {r4, pc}
-
-    mov     r0, r4                      @ recover arg
-    bl      __aeabi_f2lz                @ convert float to long
-    ldmfd   sp!, {r4, pc}
-
-/* continuation for OP_DOUBLE_TO_LONG */
-/*
- * Convert the double in r0/r1 to a long in r0/r1.
- *
- * We have to clip values to long min/max per the specification.  The
- * expected common case is a "reasonable" value that converts directly
- * to modest integer.  The EABI convert function isn't doing this for us.
- */
-d2l_doconv:
-    stmfd   sp!, {r4, r5, lr}           @ save regs
-    mov     r3, #0x43000000             @ maxlong, as a double (high word)
-    add     r3, #0x00e00000             @  0x43e00000
-    mov     r2, #0                      @ maxlong, as a double (low word)
-    sub     sp, sp, #4                  @ align for EABI
-    mov     r4, r0                      @ save a copy of r0
-    mov     r5, r1                      @  and r1
-    bl      __aeabi_dcmpge              @ is arg >= maxlong?
-    cmp     r0, #0                      @ nonzero == yes
-    mvnne   r0, #0                      @ return maxlong (7fffffffffffffff)
-    mvnne   r1, #0x80000000
-    bne     1f
-
-    mov     r0, r4                      @ recover arg
-    mov     r1, r5
-    mov     r3, #0xc3000000             @ minlong, as a double (high word)
-    add     r3, #0x00e00000             @  0xc3e00000
-    mov     r2, #0                      @ minlong, as a double (low word)
-    bl      __aeabi_dcmple              @ is arg <= minlong?
-    cmp     r0, #0                      @ nonzero == yes
-    movne   r0, #0                      @ return minlong (8000000000000000)
-    movne   r1, #0x80000000
-    bne     1f
-
-    mov     r0, r4                      @ recover arg
-    mov     r1, r5
-    mov     r2, r4                      @ compare against self
-    mov     r3, r5
-    bl      __aeabi_dcmpeq              @ is arg == self?
-    cmp     r0, #0                      @ zero == no
-    moveq   r1, #0                      @ return zero for NaN
-    beq     1f
-
-    mov     r0, r4                      @ recover arg
-    mov     r1, r5
-    bl      __aeabi_d2lz                @ convert double to long
-
-1:
-    add     sp, sp, #4
-    ldmfd   sp!, {r4, r5, pc}
-
-/* continuation for OP_MUL_LONG */
-
-.LOP_MUL_LONG_finish:
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r0, {r9-r10}                @ vAA/vAA+1<- r9/r10
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_SHL_LONG */
-
-.LOP_SHL_LONG_finish:
-    mov     r0, r0, asl r2              @  r0<- r0 << r2
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_SHR_LONG */
-
-.LOP_SHR_LONG_finish:
-    mov     r1, r1, asr r2              @  r1<- r1 >> r2
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_USHR_LONG */
-
-.LOP_USHR_LONG_finish:
-    mov     r1, r1, lsr r2              @  r1<- r1 >>> r2
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_SHL_LONG_2ADDR */
-
-.LOP_SHL_LONG_2ADDR_finish:
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_SHR_LONG_2ADDR */
-
-.LOP_SHR_LONG_2ADDR_finish:
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_USHR_LONG_2ADDR */
-
-.LOP_USHR_LONG_2ADDR_finish:
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_VOLATILE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_VOLATILE_finish:
-    @bl      common_squeak0
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    SMP_DMB                            @ acquiring load
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ fp[A]<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_VOLATILE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_VOLATILE_finish:
-    @bl      common_squeak0
-    mov     r1, rINST, lsr #8           @ r1<- A+
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    and     r1, r1, #15                 @ r1<- A
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[A]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SMP_DMB_ST                        @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    SMP_DMB
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_SGET_VOLATILE */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_VOLATILE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_VOLATILE_finish
-
-/* continuation for OP_SPUT_VOLATILE */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_VOLATILE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_VOLATILE_finish          @ resume
-
-/* continuation for OP_IGET_OBJECT_VOLATILE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_OBJECT_VOLATILE_finish:
-    @bl      common_squeak0
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    SMP_DMB                            @ acquiring load
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ fp[A]<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_WIDE_VOLATILE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_WIDE_VOLATILE_finish:
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    .if     1
-    add     r0, r9, r3                  @ r0<- address of field
-    bl      dvmQuasiAtomicRead64        @ r0/r1<- contents of field
-    .else
-    ldrd    r0, [r9, r3]                @ r0/r1<- obj.field (64-bit align ok)
-    .endif
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    add     r3, rFP, r2, lsl #2         @ r3<- &fp[A]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_WIDE_VOLATILE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_WIDE_VOLATILE_finish:
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    cmp     r9, #0                      @ check object for null
-    and     r2, r2, #15                 @ r2<- A
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    add     r2, rFP, r2, lsl #2         @ r3<- &fp[A]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[A]
-    GET_INST_OPCODE(r10)                @ extract opcode from rINST
-    .if     1
-    add     r2, r9, r3                  @ r2<- target address
-    bl      dvmQuasiAtomicSwap64Sync    @ stores r0/r1 into addr r2
-    .else
-    strd    r0, [r9, r3]                @ obj.field (64 bits, aligned)<- r0/r1
-    .endif
-    GOTO_OPCODE(r10)                    @ jump to next instruction
-
-/* continuation for OP_SGET_WIDE_VOLATILE */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     *
-     * Returns StaticField pointer in r0.
-     */
-.LOP_SGET_WIDE_VOLATILE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r1<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_WIDE_VOLATILE_finish          @ resume
-
-/* continuation for OP_SPUT_WIDE_VOLATILE */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r9:  &fp[AA]
-     *  r10: dvmDex->pResFields
-     *
-     * Returns StaticField pointer in r2.
-     */
-.LOP_SPUT_WIDE_VOLATILE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    mov     r2, r0                      @ copy to r2
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_WIDE_VOLATILE_finish          @ resume
-
-/* continuation for OP_EXECUTE_INLINE */
-
-    /*
-     * Extract args, call function.
-     *  r0 = #of args (0-4)
-     *  r10 = call index
-     *  lr = return addr, above  [DO NOT bl out of here w/o preserving LR]
-     *
-     * Other ideas:
-     * - Use a jump table from the main piece to jump directly into the
-     *   AND/LDR pairs.  Costs a data load, saves a branch.
-     * - Have five separate pieces that do the loading, so we can work the
-     *   interleave a little better.  Increases code size.
-     */
-.LOP_EXECUTE_INLINE_continue:
-    rsb     r0, r0, #4                  @ r0<- 4-r0
-    FETCH(rINST, 2)                     @ rINST<- FEDC
-    add     pc, pc, r0, lsl #3          @ computed goto, 2 instrs each
-    bl      common_abort                @ (skipped due to ARM prefetch)
-4:  and     ip, rINST, #0xf000          @ isolate F
-    ldr     r3, [rFP, ip, lsr #10]      @ r3<- vF (shift right 12, left 2)
-3:  and     ip, rINST, #0x0f00          @ isolate E
-    ldr     r2, [rFP, ip, lsr #6]       @ r2<- vE
-2:  and     ip, rINST, #0x00f0          @ isolate D
-    ldr     r1, [rFP, ip, lsr #2]       @ r1<- vD
-1:  and     ip, rINST, #0x000f          @ isolate C
-    ldr     r0, [rFP, ip, lsl #2]       @ r0<- vC
-0:
-    ldr     rINST, .LOP_EXECUTE_INLINE_table    @ table of InlineOperation
-    ldr     pc, [rINST, r10, lsl #4]    @ sizeof=16, "func" is first entry
-    @ (not reached)
-
-    /*
-     * We're debugging or profiling.
-     * r10: opIndex
-     */
-.LOP_EXECUTE_INLINE_debugmode:
-    mov     r0, r10
-    bl      dvmResolveInlineNative
-    cmp     r0, #0                      @ did it resolve?
-    beq     .LOP_EXECUTE_INLINE_resume          @ no, just move on
-    mov     r9, r0                      @ remember method
-    mov     r1, rSELF
-    bl      dvmFastMethodTraceEnter     @ (method, self)
-    add     r1, rSELF, #offThread_retval@ r1<- &self->retval
-    sub     sp, sp, #8                  @ make room for arg, +64 bit align
-    mov     r0, rINST, lsr #12          @ r0<- B
-    str     r1, [sp]                    @ push &self->retval
-    bl      .LOP_EXECUTE_INLINE_continue        @ make call; will return after
-    mov     rINST, r0                   @ save result of inline
-    add     sp, sp, #8                  @ pop stack
-    mov     r0, r9                      @ r0<- method
-    mov     r1, rSELF
-    bl      dvmFastNativeMethodTraceExit @ (method, self)
-    cmp     rINST, #0                   @ test boolean result of inline
-    beq     common_exceptionThrown      @ returned false, handle exception
-    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-
-
-
-.LOP_EXECUTE_INLINE_table:
-    .word   gDvmInlineOpsTable
-
-/* continuation for OP_EXECUTE_INLINE_RANGE */
-
-    /*
-     * Extract args, call function.
-     *  r0 = #of args (0-4)
-     *  r10 = call index
-     *  lr = return addr, above  [DO NOT bl out of here w/o preserving LR]
-     */
-.LOP_EXECUTE_INLINE_RANGE_continue:
-    rsb     r0, r0, #4                  @ r0<- 4-r0
-    FETCH(r9, 2)                        @ r9<- CCCC
-    add     pc, pc, r0, lsl #3          @ computed goto, 2 instrs each
-    bl      common_abort                @ (skipped due to ARM prefetch)
-4:  add     ip, r9, #3                  @ base+3
-    GET_VREG(r3, ip)                    @ r3<- vBase[3]
-3:  add     ip, r9, #2                  @ base+2
-    GET_VREG(r2, ip)                    @ r2<- vBase[2]
-2:  add     ip, r9, #1                  @ base+1
-    GET_VREG(r1, ip)                    @ r1<- vBase[1]
-1:  add     ip, r9, #0                  @ (nop)
-    GET_VREG(r0, ip)                    @ r0<- vBase[0]
-0:
-    ldr     r9, .LOP_EXECUTE_INLINE_RANGE_table       @ table of InlineOperation
-    ldr     pc, [r9, r10, lsl #4]       @ sizeof=16, "func" is first entry
-    @ (not reached)
-
-
-    /*
-     * We're debugging or profiling.
-     * r10: opIndex
-     */
-.LOP_EXECUTE_INLINE_RANGE_debugmode:
-    mov     r0, r10
-    bl      dvmResolveInlineNative
-    cmp     r0, #0                      @ did it resolve?
-    beq     .LOP_EXECUTE_INLINE_RANGE_resume          @ no, just move on
-    mov     r9, r0                      @ remember method
-    mov     r1, rSELF
-    bl      dvmFastMethodTraceEnter     @ (method, self)
-    add     r1, rSELF, #offThread_retval@ r1<- &self->retval
-    sub     sp, sp, #8                  @ make room for arg, +64 bit align
-    mov     r0, rINST, lsr #8           @ r0<- B
-    mov     rINST, r9                   @ rINST<- method
-    str     r1, [sp]                    @ push &self->retval
-    bl      .LOP_EXECUTE_INLINE_RANGE_continue        @ make call; will return after
-    mov     r9, r0                      @ save result of inline
-    add     sp, sp, #8                  @ pop stack
-    mov     r0, rINST                   @ r0<- method
-    mov     r1, rSELF
-    bl      dvmFastNativeMethodTraceExit  @ (method, self)
-    cmp     r9, #0                      @ test boolean result of inline
-    beq     common_exceptionThrown      @ returned false, handle exception
-    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-
-
-
-.LOP_EXECUTE_INLINE_RANGE_table:
-    .word   gDvmInlineOpsTable
-
-
-/* continuation for OP_INVOKE_OBJECT_INIT_RANGE */
-
-.LOP_INVOKE_OBJECT_INIT_RANGE_setFinal:
-    EXPORT_PC()                         @ can throw
-    bl      dvmSetFinalizable           @ call dvmSetFinalizable(obj)
-    ldr     r0, [rSELF, #offThread_exception] @ r0<- self->exception
-    cmp     r0, #0                      @ exception pending?
-    bne     common_exceptionThrown      @ yes, handle it
-    b       .LOP_INVOKE_OBJECT_INIT_RANGE_finish
-
-    /*
-     * A debugger is attached, so we need to go ahead and do
-     * this.  For simplicity, we'll just jump directly to the
-     * corresponding handler.  Note that we can't use
-     * rIBASE here because it may be in single-step mode.
-     * Load the primary table base directly.
-     */
-.LOP_INVOKE_OBJECT_INIT_RANGE_debugger:
-    ldr     r1, [rSELF, #offThread_mainHandlerTable]
-    .if 0
-    mov     ip, #OP_INVOKE_DIRECT_JUMBO
-    .else
-    mov     ip, #OP_INVOKE_DIRECT_RANGE
-    .endif
-    GOTO_OPCODE_BASE(r1,ip)             @ execute it
-
-/* continuation for OP_IPUT_OBJECT_VOLATILE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_OBJECT_VOLATILE_finish:
-    @bl      common_squeak0
-    mov     r1, rINST, lsr #8           @ r1<- A+
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    and     r1, r1, #15                 @ r1<- A
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[A]
-    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SMP_DMB_ST                        @ releasing store
-    str     r0, [r9, r3]                @ obj.field (32 bits)<- r0
-    SMP_DMB
-    cmp     r0, #0                      @ stored a null reference?
-    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card if not
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_SGET_OBJECT_VOLATILE */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_OBJECT_VOLATILE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_OBJECT_VOLATILE_finish
-
-/* continuation for OP_SPUT_OBJECT_VOLATILE */
-
-
-.LOP_SPUT_OBJECT_VOLATILE_end:
-    str     r1, [r0, #offStaticField_value]  @ field<- vAA
-    SMP_DMB
-    cmp     r1, #0                      @ stored a null object?
-    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card based on obj head
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /* Continuation if the field has not yet been resolved.
-     * r1:  BBBB field ref
-     * r10: dvmDex->pResFields
-     */
-.LOP_SPUT_OBJECT_VOLATILE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_OBJECT_VOLATILE_finish          @ resume
-
-
-/* continuation for OP_CONST_CLASS_JUMBO */
-
-    /*
-     * Continuation if the Class has not yet been resolved.
-     *  r1: AAAAAAAA (Class ref)
-     *  r9: target register
-     */
-.LOP_CONST_CLASS_JUMBO_resolve:
-    EXPORT_PC()
-    ldr     r0, [rSELF, #offThread_method] @ r0<- self->method
-    mov     r2, #1                      @ r2<- true
-    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- Class reference
-    cmp     r0, #0                      @ failed?
-    beq     common_exceptionThrown      @ yup, handle the exception
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r9)                    @ vBBBB<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_CHECK_CAST_JUMBO */
-
-    /*
-     * Trivial test failed, need to perform full check.  This is common.
-     *  r0 holds obj->clazz
-     *  r1 holds desired class resolved from AAAAAAAA
-     *  r9 holds object
-     */
-.LOP_CHECK_CAST_JUMBO_fullcheck:
-    mov     r10, r1                     @ avoid ClassObject getting clobbered
-    bl      dvmInstanceofNonTrivial     @ r0<- boolean result
-    cmp     r0, #0                      @ failed?
-    bne     .LOP_CHECK_CAST_JUMBO_okay            @ no, success
-
-    @ A cast has failed.  We need to throw a ClassCastException.
-    EXPORT_PC()                         @ about to throw
-    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz (actual class)
-    mov     r1, r10                     @ r1<- desired class
-    bl      dvmThrowClassCastException
-    b       common_exceptionThrown
-
-    /*
-     * Advance PC and get the next opcode.
-     */
-.LOP_CHECK_CAST_JUMBO_okay:
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /*
-     * Resolution required.  This is the least-likely path.
-     *
-     *  r2 holds AAAAAAAA
-     *  r9 holds object
-     */
-.LOP_CHECK_CAST_JUMBO_resolve:
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    mov     r1, r2                      @ r1<- AAAAAAAA
-    mov     r2, #0                      @ r2<- false
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
-    cmp     r0, #0                      @ got null?
-    beq     common_exceptionThrown      @ yes, handle exception
-    mov     r1, r0                      @ r1<- class resolved from AAAAAAAA
-    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz
-    b       .LOP_CHECK_CAST_JUMBO_resolved        @ pick up where we left off
-
-/* continuation for OP_INSTANCE_OF_JUMBO */
-
-    /*
-     * Class resolved, determine type of check necessary.  This is common.
-     *  r0 holds obj->clazz
-     *  r1 holds class resolved from AAAAAAAA
-     *  r9 holds BBBB
-     */
-.LOP_INSTANCE_OF_JUMBO_resolved:
-    cmp     r0, r1                      @ same class (trivial success)?
-    beq     .LOP_INSTANCE_OF_JUMBO_trivial         @ yes, trivial finish
-    @ fall through to OP_INSTANCE_OF_JUMBO_fullcheck
-
-    /*
-     * Trivial test failed, need to perform full check.  This is common.
-     *  r0 holds obj->clazz
-     *  r1 holds class resolved from AAAAAAAA
-     *  r9 holds BBBB
-     */
-.LOP_INSTANCE_OF_JUMBO_fullcheck:
-    bl      dvmInstanceofNonTrivial     @ r0<- boolean result
-    @ fall through to OP_INSTANCE_OF_JUMBO_store
-
-    /*
-     * r0 holds boolean result
-     * r9 holds BBBB
-     */
-.LOP_INSTANCE_OF_JUMBO_store:
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r9)                    @ vBBBB<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /*
-     * Trivial test succeeded, save and bail.
-     *  r9 holds BBBB
-     */
-.LOP_INSTANCE_OF_JUMBO_trivial:
-    mov     r0, #1                      @ indicate success
-    @ could b OP_INSTANCE_OF_JUMBO_store, but copying is faster and cheaper
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r9)                    @ vBBBB<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /*
-     * Resolution required.  This is the least-likely path.
-     *
-     *  r3 holds AAAAAAAA
-     *  r9 holds BBBB
-     */
-
-.LOP_INSTANCE_OF_JUMBO_resolve:
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [rSELF, #offThread_method]    @ r0<- self->method
-    mov     r1, r3                      @ r1<- AAAAAAAA
-    mov     r2, #1                      @ r2<- true
-    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
-    cmp     r0, #0                      @ got null?
-    beq     common_exceptionThrown      @ yes, handle exception
-    FETCH(r3, 4)                        @ r3<- vCCCC
-    mov     r1, r0                      @ r1<- class resolved from AAAAAAAA
-    GET_VREG(r0, r3)                    @ r0<- vCCCC (object)
-    ldr     r0, [r0, #offObject_clazz]  @ r0<- obj->clazz
-    b       .LOP_INSTANCE_OF_JUMBO_resolved        @ pick up where we left off
-
-/* continuation for OP_NEW_INSTANCE_JUMBO */
-
-    .balign 32                          @ minimize cache lines
-.LOP_NEW_INSTANCE_JUMBO_finish: @ r0=new object
-    FETCH(r3, 3)                        @ r3<- BBBB
-    cmp     r0, #0                      @ failed?
-#if defined(WITH_JIT)
-    /*
-     * The JIT needs the class to be fully resolved before it can
-     * include this instruction in a trace.
-     */
-    ldrh    r1, [rSELF, #offThread_subMode]
-    beq     common_exceptionThrown      @ yes, handle the exception
-    ands    r1, #kSubModeJitTraceBuild  @ under construction?
-    bne     .LOP_NEW_INSTANCE_JUMBO_jitCheck
-#else
-    beq     common_exceptionThrown      @ yes, handle the exception
-#endif
-.LOP_NEW_INSTANCE_JUMBO_end:
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r3)                    @ vBBBB<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-#if defined(WITH_JIT)
-    /*
-     * Check to see if we need to stop the trace building early.
-     * r0: new object
-     * r3: vAA
-     */
-.LOP_NEW_INSTANCE_JUMBO_jitCheck:
-    ldr     r1, [r10]                   @ reload resolved class
-    cmp     r1, #0                      @ okay?
-    bne     .LOP_NEW_INSTANCE_JUMBO_end             @ yes, finish
-    mov     r9, r0                      @ preserve new object
-    mov     r10, r3                     @ preserve vAA
-    mov     r0, rSELF
-    mov     r1, rPC
-    bl      dvmJitEndTraceSelect        @ (self, pc)
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r9, r10)                   @ vAA<- new object
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-#endif
-
-    /*
-     * Class initialization required.
-     *
-     *  r0 holds class object
-     */
-.LOP_NEW_INSTANCE_JUMBO_needinit:
-    mov     r9, r0                      @ save r0
-    bl      dvmInitClass                @ initialize class
-    cmp     r0, #0                      @ check boolean result
-    mov     r0, r9                      @ restore r0
-    bne     .LOP_NEW_INSTANCE_JUMBO_initialized     @ success, continue
-    b       common_exceptionThrown      @ failed, deal with init exception
-
-    /*
-     * Resolution required.  This is the least-likely path.
-     *
-     *  r1 holds AAAAAAAA
-     */
-.LOP_NEW_INSTANCE_JUMBO_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    mov     r2, #0                      @ r2<- false
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_NEW_INSTANCE_JUMBO_resolved        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-/* continuation for OP_NEW_ARRAY_JUMBO */
-
-
-    /*
-     * Resolve class.  (This is an uncommon case.)
-     *
-     *  r1 holds array length
-     *  r2 holds class ref AAAAAAAA
-     */
-.LOP_NEW_ARRAY_JUMBO_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    mov     r9, r1                      @ r9<- length (save)
-    mov     r1, r2                      @ r1<- AAAAAAAA
-    mov     r2, #0                      @ r2<- false
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- call(clazz, ref)
-    cmp     r0, #0                      @ got null?
-    mov     r1, r9                      @ r1<- length (restore)
-    beq     common_exceptionThrown      @ yes, handle exception
-    @ fall through to OP_NEW_ARRAY_JUMBO_finish
-
-    /*
-     * Finish allocation.
-     *
-     *  r0 holds class
-     *  r1 holds array length
-     */
-.LOP_NEW_ARRAY_JUMBO_finish:
-    mov     r2, #ALLOC_DONT_TRACK       @ don't track in local refs table
-    bl      dvmAllocArrayByClass        @ r0<- call(clazz, length, flags)
-    cmp     r0, #0                      @ failed?
-    FETCH(r2, 3)                        @ r2<- vBBBB
-    beq     common_exceptionThrown      @ yes, handle the exception
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ vBBBB<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_FILLED_NEW_ARRAY_JUMBO */
-
-    /*
-     * On entry:
-     *  r0 holds array class
-     */
-.LOP_FILLED_NEW_ARRAY_JUMBO_continue:
-    ldr     r3, [r0, #offClassObject_descriptor] @ r3<- arrayClass->descriptor
-    mov     r2, #ALLOC_DONT_TRACK       @ r2<- alloc flags
-    ldrb    rINST, [r3, #1]             @ rINST<- descriptor[1]
-    FETCH(r1, 3)                        @ r1<- BBBB (length)
-    cmp     rINST, #'I'                 @ array of ints?
-    cmpne   rINST, #'L'                 @ array of objects?
-    cmpne   rINST, #'['                 @ array of arrays?
-    mov     r9, r1                      @ save length in r9
-    bne     .LOP_FILLED_NEW_ARRAY_JUMBO_notimpl         @ no, not handled yet
-    bl      dvmAllocArrayByClass        @ r0<- call(arClass, length, flags)
-    cmp     r0, #0                      @ null return?
-    beq     common_exceptionThrown      @ alloc failed, handle exception
-
-    FETCH(r1, 4)                        @ r1<- CCCC
-    str     r0, [rSELF, #offThread_retval]      @ retval.l <- new array
-    str     rINST, [rSELF, #offThread_retval+4] @ retval.h <- type
-    add     r0, r0, #offArrayObject_contents @ r0<- newArray->contents
-    subs    r9, r9, #1                  @ length--, check for neg
-    FETCH_ADVANCE_INST(5)               @ advance to next instr, load rINST
-    bmi     2f                          @ was zero, bail
-
-    @ copy values from registers into the array
-    @ r0=array, r1=CCCC, r9=BBBB (length)
-    add     r2, rFP, r1, lsl #2         @ r2<- &fp[CCCC]
-1:  ldr     r3, [r2], #4                @ r3<- *r2++
-    subs    r9, r9, #1                  @ count--
-    str     r3, [r0], #4                @ *contents++ = vX
-    bpl     1b
-
-2:  ldr     r0, [rSELF, #offThread_retval]     @ r0<- object
-    ldr     r1, [rSELF, #offThread_retval+4]   @ r1<- type
-    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
-    GET_INST_OPCODE(ip)                      @ ip<- opcode from rINST
-    cmp     r1, #'I'                         @ Is int array?
-    strneb  r2, [r2, r0, lsr #GC_CARD_SHIFT] @ Mark card based on object head
-    GOTO_OPCODE(ip)                          @ execute it
-
-    /*
-     * Throw an exception indicating that we have not implemented this
-     * mode of filled-new-array.
-     */
-.LOP_FILLED_NEW_ARRAY_JUMBO_notimpl:
-    ldr     r0, .L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY_JUMBO
-    bl      dvmThrowInternalError
-    b       common_exceptionThrown
-
-    /*
-     * Ideally we'd only define this once, but depending on layout we can
-     * exceed the range of the load above.
-     */
-
-.L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY_JUMBO:
-    .word   .LstrFilledNewArrayNotImpl
-
-/* continuation for OP_IGET_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_JUMBO_finish:
-    @bl      common_squeak0
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r2)                    @ fp[BBBB]<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_WIDE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_WIDE_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_WIDE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_WIDE_JUMBO_finish:
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    .if     0
-    add     r0, r9, r3                  @ r0<- address of field
-    bl      dvmQuasiAtomicRead64        @ r0/r1<- contents of field
-    .else
-    ldrd    r0, [r9, r3]                @ r0/r1<- obj.field (64-bit align ok)
-    .endif
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    add     r3, rFP, r2, lsl #2         @ r3<- &fp[BBBB]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ fp[BBBB]<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_OBJECT_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_OBJECT_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_OBJECT_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_OBJECT_JUMBO_finish:
-    @bl      common_squeak0
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r2)                    @ fp[BBBB]<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_BOOLEAN_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_BOOLEAN_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_BOOLEAN_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_BOOLEAN_JUMBO_finish:
-    @bl      common_squeak1
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r2)                    @ fp[BBBB]<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_BYTE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_BYTE_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_BYTE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_BYTE_JUMBO_finish:
-    @bl      common_squeak2
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r2)                    @ fp[BBBB]<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_CHAR_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_CHAR_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_CHAR_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_CHAR_JUMBO_finish:
-    @bl      common_squeak3
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r2)                    @ fp[BBBB]<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_SHORT_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_SHORT_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_SHORT_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_SHORT_JUMBO_finish:
-    @bl      common_squeak4
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r2)                    @ fp[BBBB]<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_JUMBO_finish:
-    @bl      common_squeak0
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    FETCH(r1, 3)                        @ r1<- BBBB
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[BBBB]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                          @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_WIDE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_WIDE_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_WIDE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_WIDE_JUMBO_finish:
-    cmp     r9, #0                      @ check object for null
-    FETCH(r2, 3)                        @ r1<- BBBB
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    add     r2, rFP, r2, lsl #2         @ r3<- &fp[BBBB]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[BBBB]
-    GET_INST_OPCODE(r10)                @ extract opcode from rINST
-    .if     0
-    add     r2, r9, r3                  @ r2<- target address
-    bl      dvmQuasiAtomicSwap64Sync    @ stores r0/r1 into addr r2
-    .else
-    strd    r0, [r9, r3]                @ obj.field (64 bits, aligned)<- r0/r1
-    .endif
-    GOTO_OPCODE(r10)                    @ jump to next instruction
-
-/* continuation for OP_IPUT_OBJECT_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_OBJECT_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_OBJECT_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_OBJECT_JUMBO_finish:
-    @bl      common_squeak0
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    FETCH(r1, 3)                        @ r1<- BBBB
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[BBBB]
-    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                         @ releasing store
-    str     r0, [r9, r3]                @ obj.field (32 bits)<- r0
-    @ no-op 
-    cmp     r0, #0                      @ stored a null reference?
-    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card if not
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_BOOLEAN_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_BOOLEAN_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_BOOLEAN_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_BOOLEAN_JUMBO_finish:
-    @bl      common_squeak1
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    FETCH(r1, 3)                        @ r1<- BBBB
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[BBBB]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                          @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_BYTE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_BYTE_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_BYTE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_BYTE_JUMBO_finish:
-    @bl      common_squeak2
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    FETCH(r1, 3)                        @ r1<- BBBB
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[BBBB]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                          @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_CHAR_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_CHAR_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_CHAR_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_CHAR_JUMBO_finish:
-    @bl      common_squeak3
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    FETCH(r1, 3)                        @ r1<- BBBB
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[BBBB]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                          @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_SHORT_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_SHORT_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_SHORT_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_SHORT_JUMBO_finish:
-    @bl      common_squeak4
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    FETCH(r1, 3)                        @ r1<- BBBB
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[BBBB]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                          @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_SGET_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_JUMBO_finish          @ resume
-
-/* continuation for OP_SGET_WIDE_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1: AAAAAAAA field ref
-     *
-     * Returns StaticField pointer in r0.
-     */
-.LOP_SGET_WIDE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    bne     .LOP_SGET_WIDE_JUMBO_finish          @ yes, finish
-    b       common_exceptionThrown      @ no, handle exception
-
-/* continuation for OP_SGET_OBJECT_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_OBJECT_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_OBJECT_JUMBO_finish          @ resume
-
-/* continuation for OP_SGET_BOOLEAN_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_BOOLEAN_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_BOOLEAN_JUMBO_finish          @ resume
-
-/* continuation for OP_SGET_BYTE_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_BYTE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_BYTE_JUMBO_finish          @ resume
-
-/* continuation for OP_SGET_CHAR_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_CHAR_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_CHAR_JUMBO_finish          @ resume
-
-/* continuation for OP_SGET_SHORT_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_SHORT_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_SHORT_JUMBO_finish          @ resume
-
-/* continuation for OP_SPUT_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_JUMBO_finish          @ resume
-
-/* continuation for OP_SPUT_WIDE_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r9:  &fp[BBBB]
-     *  r10: dvmDex->pResFields
-     *
-     * Returns StaticField pointer in r2.
-     */
-.LOP_SPUT_WIDE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    mov     r2, r0                      @ copy to r2
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_WIDE_JUMBO_finish          @ resume
-
-/* continuation for OP_SPUT_OBJECT_JUMBO */
-
-
-.LOP_SPUT_OBJECT_JUMBO_end:
-    str     r1, [r0, #offStaticField_value]  @ field<- vBBBB
-    @ no-op 
-    cmp     r1, #0                      @ stored a null object?
-    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card based on obj head
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /* Continuation if the field has not yet been resolved.
-     * r1:  AAAAaaaa field ref
-     * r10: dvmDex->pResFields
-     */
-.LOP_SPUT_OBJECT_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r9<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_OBJECT_JUMBO_finish          @ resume
-
-
-/* continuation for OP_SPUT_BOOLEAN_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_BOOLEAN_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_BOOLEAN_JUMBO_finish          @ resume
-
-/* continuation for OP_SPUT_BYTE_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_BYTE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_BYTE_JUMBO_finish          @ resume
-
-/* continuation for OP_SPUT_CHAR_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_CHAR_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_CHAR_JUMBO_finish          @ resume
-
-/* continuation for OP_SPUT_SHORT_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_SHORT_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_SHORT_JUMBO_finish          @ resume
-
-/* continuation for OP_INVOKE_VIRTUAL_JUMBO */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     */
-.LOP_INVOKE_VIRTUAL_JUMBO_continue:
-    FETCH(r10, 4)                       @ r10<- CCCC
-    GET_VREG(r9, r10)                   @ r9<- "this" ptr
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    cmp     r9, #0                      @ is "this" null?
-    beq     common_errNullObject        @ null "this", throw exception
-    ldr     r3, [r9, #offObject_clazz]  @ r3<- thisPtr->clazz
-    ldr     r3, [r3, #offClassObject_vtable]    @ r3<- thisPtr->clazz->vtable
-    ldr     r0, [r3, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodJumbo    @ (r0=method, r9="this")
-
-/* continuation for OP_INVOKE_SUPER_JUMBO */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r10 = method->clazz
-     */
-.LOP_INVOKE_SUPER_JUMBO_continue:
-    ldr     r1, [r10, #offClassObject_super]    @ r1<- method->clazz->super
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    ldr     r3, [r1, #offClassObject_vtableCount]   @ r3<- super->vtableCount
-    EXPORT_PC()                         @ must export for invoke
-    cmp     r2, r3                      @ compare (methodIndex, vtableCount)
-    bcs     .LOP_INVOKE_SUPER_JUMBO_nsm             @ method not present in superclass
-    ldr     r1, [r1, #offClassObject_vtable]    @ r1<- ...clazz->super->vtable
-    ldr     r0, [r1, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodJumbo    @ (r0=method, r9="this")
-
-.LOP_INVOKE_SUPER_JUMBO_resolve:
-    mov     r0, r10                     @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_SUPER_JUMBO_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-    /*
-     * Throw a NoSuchMethodError with the method name as the message.
-     *  r0 = resolved base method
-     */
-.LOP_INVOKE_SUPER_JUMBO_nsm:
-    ldr     r1, [r0, #offMethod_name]   @ r1<- method name
-    b       common_errNoSuchMethod
-
-/* continuation for OP_INVOKE_DIRECT_JUMBO */
-
-    /*
-     * On entry:
-     *  r1 = reference (CCCC)
-     *  r10 = "this" register
-     */
-.LOP_INVOKE_DIRECT_JUMBO_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_DIRECT          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_DIRECT_JUMBO_finish          @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-/* continuation for OP_INVOKE_STATIC_JUMBO */
-
-
-.LOP_INVOKE_STATIC_JUMBO_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_STATIC          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-#if defined(WITH_JIT)
-    /*
-     * Check to see if we're actively building a trace.  If so,
-     * we need to keep this instruction out of it.
-     * r10: &resolved_methodToCall
-     */
-    ldrh    r2, [rSELF, #offThread_subMode]
-    beq     common_exceptionThrown            @ null, handle exception
-    ands    r2, #kSubModeJitTraceBuild        @ trace under construction?
-    beq     common_invokeMethodJumboNoThis    @ no (r0=method, r9="this")
-    ldr     r1, [r10]                         @ reload resolved method
-    cmp     r1, #0                            @ finished resolving?
-    bne     common_invokeMethodJumboNoThis    @ yes (r0=method, r9="this")
-    mov     r10, r0                           @ preserve method
-    mov     r0, rSELF
-    mov     r1, rPC
-    bl      dvmJitEndTraceSelect              @ (self, pc)
-    mov     r0, r10
-    b       common_invokeMethodJumboNoThis    @ whew, finally!
-#else
-    bne     common_invokeMethodJumboNoThis    @ (r0=method, r9="this")
-    b       common_exceptionThrown            @ yes, handle exception
-#endif
-
-/* continuation for OP_INVOKE_OBJECT_INIT_JUMBO */
-
-.LOP_INVOKE_OBJECT_INIT_JUMBO_setFinal:
-    EXPORT_PC()                         @ can throw
-    bl      dvmSetFinalizable           @ call dvmSetFinalizable(obj)
-    ldr     r0, [rSELF, #offThread_exception] @ r0<- self->exception
-    cmp     r0, #0                      @ exception pending?
-    bne     common_exceptionThrown      @ yes, handle it
-    b       .LOP_INVOKE_OBJECT_INIT_JUMBO_finish
-
-    /*
-     * A debugger is attached, so we need to go ahead and do
-     * this.  For simplicity, we'll just jump directly to the
-     * corresponding handler.  Note that we can't use
-     * rIBASE here because it may be in single-step mode.
-     * Load the primary table base directly.
-     */
-.LOP_INVOKE_OBJECT_INIT_JUMBO_debugger:
-    ldr     r1, [rSELF, #offThread_mainHandlerTable]
-    .if 1
-    mov     ip, #OP_INVOKE_DIRECT_JUMBO
-    .else
-    mov     ip, #OP_INVOKE_DIRECT_RANGE
-    .endif
-    GOTO_OPCODE_BASE(r1,ip)             @ execute it
-
-/* continuation for OP_IGET_VOLATILE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_VOLATILE_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_VOLATILE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_VOLATILE_JUMBO_finish:
-    @bl      common_squeak0
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    SMP_DMB                            @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r2)                    @ fp[BBBB]<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_WIDE_VOLATILE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_WIDE_VOLATILE_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_WIDE_VOLATILE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_WIDE_VOLATILE_JUMBO_finish:
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    .if     1
-    add     r0, r9, r3                  @ r0<- address of field
-    bl      dvmQuasiAtomicRead64        @ r0/r1<- contents of field
-    .else
-    ldrd    r0, [r9, r3]                @ r0/r1<- obj.field (64-bit align ok)
-    .endif
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    add     r3, rFP, r2, lsl #2         @ r3<- &fp[BBBB]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ fp[BBBB]<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_OBJECT_VOLATILE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_OBJECT_VOLATILE_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_OBJECT_VOLATILE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_OBJECT_VOLATILE_JUMBO_finish:
-    @bl      common_squeak0
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    SMP_DMB                            @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r2)                    @ fp[BBBB]<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_VOLATILE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_VOLATILE_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_VOLATILE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_VOLATILE_JUMBO_finish:
-    @bl      common_squeak0
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    FETCH(r1, 3)                        @ r1<- BBBB
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[BBBB]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SMP_DMB_ST                         @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    SMP_DMB
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_WIDE_VOLATILE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_WIDE_VOLATILE_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_WIDE_VOLATILE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_WIDE_VOLATILE_JUMBO_finish:
-    cmp     r9, #0                      @ check object for null
-    FETCH(r2, 3)                        @ r1<- BBBB
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    add     r2, rFP, r2, lsl #2         @ r3<- &fp[BBBB]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[BBBB]
-    GET_INST_OPCODE(r10)                @ extract opcode from rINST
-    .if     1
-    add     r2, r9, r3                  @ r2<- target address
-    bl      dvmQuasiAtomicSwap64Sync    @ stores r0/r1 into addr r2
-    .else
-    strd    r0, [r9, r3]                @ obj.field (64 bits, aligned)<- r0/r1
-    .endif
-    GOTO_OPCODE(r10)                    @ jump to next instruction
-
-/* continuation for OP_IPUT_OBJECT_VOLATILE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_OBJECT_VOLATILE_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_OBJECT_VOLATILE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_OBJECT_VOLATILE_JUMBO_finish:
-    @bl      common_squeak0
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    FETCH(r1, 3)                        @ r1<- BBBB
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[BBBB]
-    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SMP_DMB_ST                        @ releasing store
-    str     r0, [r9, r3]                @ obj.field (32 bits)<- r0
-    SMP_DMB
-    cmp     r0, #0                      @ stored a null reference?
-    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card if not
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_SGET_VOLATILE_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_VOLATILE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_VOLATILE_JUMBO_finish          @ resume
-
-/* continuation for OP_SGET_WIDE_VOLATILE_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1: AAAAAAAA field ref
-     *
-     * Returns StaticField pointer in r0.
-     */
-.LOP_SGET_WIDE_VOLATILE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    bne     .LOP_SGET_WIDE_VOLATILE_JUMBO_finish          @ yes, finish
-    b       common_exceptionThrown      @ no, handle exception
-
-/* continuation for OP_SGET_OBJECT_VOLATILE_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_OBJECT_VOLATILE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_OBJECT_VOLATILE_JUMBO_finish          @ resume
-
-/* continuation for OP_SPUT_VOLATILE_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_VOLATILE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_VOLATILE_JUMBO_finish          @ resume
-
-/* continuation for OP_SPUT_WIDE_VOLATILE_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r9:  &fp[BBBB]
-     *  r10: dvmDex->pResFields
-     *
-     * Returns StaticField pointer in r2.
-     */
-.LOP_SPUT_WIDE_VOLATILE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    mov     r2, r0                      @ copy to r2
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_WIDE_VOLATILE_JUMBO_finish          @ resume
-
-/* continuation for OP_SPUT_OBJECT_VOLATILE_JUMBO */
-
-
-.LOP_SPUT_OBJECT_VOLATILE_JUMBO_end:
-    str     r1, [r0, #offStaticField_value]  @ field<- vBBBB
-    SMP_DMB
-    cmp     r1, #0                      @ stored a null object?
-    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card based on obj head
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /* Continuation if the field has not yet been resolved.
-     * r1:  AAAAaaaa field ref
-     * r10: dvmDex->pResFields
-     */
-.LOP_SPUT_OBJECT_VOLATILE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r9<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_OBJECT_VOLATILE_JUMBO_finish          @ resume
-
-
-    .size   dvmAsmSisterStart, .-dvmAsmSisterStart
-    .global dvmAsmSisterEnd
-dvmAsmSisterEnd:
-
-
-    .global dvmAsmAltInstructionStart
-    .type   dvmAsmAltInstructionStart, %function
-    .text
-
-dvmAsmAltInstructionStart = .L_ALT_OP_NOP
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_NOP: /* 0x00 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (0 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE: /* 0x01 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (1 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_FROM16: /* 0x02 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (2 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_16: /* 0x03 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (3 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_WIDE: /* 0x04 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (4 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_WIDE_FROM16: /* 0x05 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (5 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_WIDE_16: /* 0x06 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (6 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_OBJECT: /* 0x07 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (7 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_OBJECT_FROM16: /* 0x08 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (8 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_OBJECT_16: /* 0x09 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (9 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_RESULT: /* 0x0a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (10 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_RESULT_WIDE: /* 0x0b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (11 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_RESULT_OBJECT: /* 0x0c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (12 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_EXCEPTION: /* 0x0d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (13 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_RETURN_VOID: /* 0x0e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (14 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_RETURN: /* 0x0f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (15 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_RETURN_WIDE: /* 0x10 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (16 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_RETURN_OBJECT: /* 0x11 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (17 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_4: /* 0x12 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (18 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_16: /* 0x13 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (19 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST: /* 0x14 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (20 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_HIGH16: /* 0x15 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (21 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_WIDE_16: /* 0x16 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (22 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_WIDE_32: /* 0x17 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (23 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_WIDE: /* 0x18 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (24 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_WIDE_HIGH16: /* 0x19 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (25 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_STRING: /* 0x1a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (26 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_STRING_JUMBO: /* 0x1b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (27 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_CLASS: /* 0x1c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (28 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MONITOR_ENTER: /* 0x1d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (29 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MONITOR_EXIT: /* 0x1e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (30 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CHECK_CAST: /* 0x1f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (31 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INSTANCE_OF: /* 0x20 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (32 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ARRAY_LENGTH: /* 0x21 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (33 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_NEW_INSTANCE: /* 0x22 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (34 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_NEW_ARRAY: /* 0x23 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (35 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_FILLED_NEW_ARRAY: /* 0x24 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (36 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_FILLED_NEW_ARRAY_RANGE: /* 0x25 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (37 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_FILL_ARRAY_DATA: /* 0x26 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (38 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_THROW: /* 0x27 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (39 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_GOTO: /* 0x28 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (40 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_GOTO_16: /* 0x29 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (41 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_GOTO_32: /* 0x2a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (42 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_PACKED_SWITCH: /* 0x2b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (43 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPARSE_SWITCH: /* 0x2c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (44 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CMPL_FLOAT: /* 0x2d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (45 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CMPG_FLOAT: /* 0x2e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (46 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CMPL_DOUBLE: /* 0x2f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (47 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CMPG_DOUBLE: /* 0x30 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (48 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CMP_LONG: /* 0x31 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (49 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_EQ: /* 0x32 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (50 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_NE: /* 0x33 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (51 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_LT: /* 0x34 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (52 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_GE: /* 0x35 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (53 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_GT: /* 0x36 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (54 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_LE: /* 0x37 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (55 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_EQZ: /* 0x38 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (56 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_NEZ: /* 0x39 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (57 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_LTZ: /* 0x3a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (58 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_GEZ: /* 0x3b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (59 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_GTZ: /* 0x3c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (60 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_LEZ: /* 0x3d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (61 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_UNUSED_3E: /* 0x3e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (62 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_UNUSED_3F: /* 0x3f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (63 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_UNUSED_40: /* 0x40 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (64 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_UNUSED_41: /* 0x41 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (65 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_UNUSED_42: /* 0x42 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (66 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_UNUSED_43: /* 0x43 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (67 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AGET: /* 0x44 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (68 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AGET_WIDE: /* 0x45 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (69 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AGET_OBJECT: /* 0x46 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (70 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AGET_BOOLEAN: /* 0x47 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (71 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AGET_BYTE: /* 0x48 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (72 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AGET_CHAR: /* 0x49 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (73 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AGET_SHORT: /* 0x4a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (74 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_APUT: /* 0x4b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (75 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_APUT_WIDE: /* 0x4c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (76 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_APUT_OBJECT: /* 0x4d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (77 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_APUT_BOOLEAN: /* 0x4e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (78 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_APUT_BYTE: /* 0x4f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (79 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_APUT_CHAR: /* 0x50 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (80 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_APUT_SHORT: /* 0x51 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (81 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET: /* 0x52 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (82 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_WIDE: /* 0x53 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (83 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_OBJECT: /* 0x54 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (84 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_BOOLEAN: /* 0x55 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (85 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_BYTE: /* 0x56 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (86 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_CHAR: /* 0x57 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (87 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_SHORT: /* 0x58 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (88 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT: /* 0x59 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (89 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_WIDE: /* 0x5a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (90 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_OBJECT: /* 0x5b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (91 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_BOOLEAN: /* 0x5c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (92 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_BYTE: /* 0x5d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (93 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_CHAR: /* 0x5e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (94 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_SHORT: /* 0x5f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (95 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET: /* 0x60 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (96 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET_WIDE: /* 0x61 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (97 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET_OBJECT: /* 0x62 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (98 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET_BOOLEAN: /* 0x63 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (99 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET_BYTE: /* 0x64 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (100 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET_CHAR: /* 0x65 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (101 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET_SHORT: /* 0x66 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (102 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT: /* 0x67 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (103 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT_WIDE: /* 0x68 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (104 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT_OBJECT: /* 0x69 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (105 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT_BOOLEAN: /* 0x6a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (106 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT_BYTE: /* 0x6b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (107 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT_CHAR: /* 0x6c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (108 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT_SHORT: /* 0x6d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (109 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_VIRTUAL: /* 0x6e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (110 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_SUPER: /* 0x6f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (111 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_DIRECT: /* 0x70 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (112 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_STATIC: /* 0x71 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (113 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_INTERFACE: /* 0x72 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (114 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_UNUSED_73: /* 0x73 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (115 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_VIRTUAL_RANGE: /* 0x74 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (116 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_SUPER_RANGE: /* 0x75 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (117 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_DIRECT_RANGE: /* 0x76 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (118 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_STATIC_RANGE: /* 0x77 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (119 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_INTERFACE_RANGE: /* 0x78 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (120 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_UNUSED_79: /* 0x79 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (121 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_UNUSED_7A: /* 0x7a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (122 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_NEG_INT: /* 0x7b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (123 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_NOT_INT: /* 0x7c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (124 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_NEG_LONG: /* 0x7d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (125 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_NOT_LONG: /* 0x7e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (126 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_NEG_FLOAT: /* 0x7f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (127 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_NEG_DOUBLE: /* 0x80 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (128 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INT_TO_LONG: /* 0x81 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (129 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INT_TO_FLOAT: /* 0x82 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (130 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INT_TO_DOUBLE: /* 0x83 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (131 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_LONG_TO_INT: /* 0x84 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (132 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_LONG_TO_FLOAT: /* 0x85 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (133 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_LONG_TO_DOUBLE: /* 0x86 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (134 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_FLOAT_TO_INT: /* 0x87 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (135 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_FLOAT_TO_LONG: /* 0x88 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (136 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_FLOAT_TO_DOUBLE: /* 0x89 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (137 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DOUBLE_TO_INT: /* 0x8a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (138 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DOUBLE_TO_LONG: /* 0x8b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (139 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DOUBLE_TO_FLOAT: /* 0x8c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (140 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INT_TO_BYTE: /* 0x8d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (141 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INT_TO_CHAR: /* 0x8e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (142 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INT_TO_SHORT: /* 0x8f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (143 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_INT: /* 0x90 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (144 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SUB_INT: /* 0x91 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (145 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_INT: /* 0x92 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (146 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_INT: /* 0x93 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (147 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_INT: /* 0x94 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (148 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AND_INT: /* 0x95 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (149 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_OR_INT: /* 0x96 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (150 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_XOR_INT: /* 0x97 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (151 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHL_INT: /* 0x98 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (152 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHR_INT: /* 0x99 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (153 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_USHR_INT: /* 0x9a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (154 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_LONG: /* 0x9b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (155 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SUB_LONG: /* 0x9c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (156 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_LONG: /* 0x9d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (157 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_LONG: /* 0x9e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (158 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_LONG: /* 0x9f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (159 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AND_LONG: /* 0xa0 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (160 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_OR_LONG: /* 0xa1 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (161 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_XOR_LONG: /* 0xa2 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (162 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHL_LONG: /* 0xa3 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (163 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHR_LONG: /* 0xa4 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (164 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_USHR_LONG: /* 0xa5 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (165 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_FLOAT: /* 0xa6 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (166 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SUB_FLOAT: /* 0xa7 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (167 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_FLOAT: /* 0xa8 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (168 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_FLOAT: /* 0xa9 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (169 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_FLOAT: /* 0xaa */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (170 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_DOUBLE: /* 0xab */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (171 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SUB_DOUBLE: /* 0xac */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (172 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_DOUBLE: /* 0xad */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (173 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_DOUBLE: /* 0xae */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (174 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_DOUBLE: /* 0xaf */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (175 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_INT_2ADDR: /* 0xb0 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (176 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SUB_INT_2ADDR: /* 0xb1 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (177 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_INT_2ADDR: /* 0xb2 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (178 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_INT_2ADDR: /* 0xb3 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (179 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_INT_2ADDR: /* 0xb4 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (180 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AND_INT_2ADDR: /* 0xb5 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (181 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_OR_INT_2ADDR: /* 0xb6 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (182 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_XOR_INT_2ADDR: /* 0xb7 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (183 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHL_INT_2ADDR: /* 0xb8 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (184 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHR_INT_2ADDR: /* 0xb9 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (185 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_USHR_INT_2ADDR: /* 0xba */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (186 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_LONG_2ADDR: /* 0xbb */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (187 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SUB_LONG_2ADDR: /* 0xbc */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (188 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_LONG_2ADDR: /* 0xbd */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (189 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_LONG_2ADDR: /* 0xbe */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (190 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_LONG_2ADDR: /* 0xbf */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (191 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AND_LONG_2ADDR: /* 0xc0 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (192 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_OR_LONG_2ADDR: /* 0xc1 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (193 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_XOR_LONG_2ADDR: /* 0xc2 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (194 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHL_LONG_2ADDR: /* 0xc3 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (195 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHR_LONG_2ADDR: /* 0xc4 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (196 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_USHR_LONG_2ADDR: /* 0xc5 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (197 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_FLOAT_2ADDR: /* 0xc6 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (198 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SUB_FLOAT_2ADDR: /* 0xc7 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (199 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_FLOAT_2ADDR: /* 0xc8 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (200 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_FLOAT_2ADDR: /* 0xc9 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (201 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_FLOAT_2ADDR: /* 0xca */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (202 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_DOUBLE_2ADDR: /* 0xcb */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (203 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SUB_DOUBLE_2ADDR: /* 0xcc */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (204 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_DOUBLE_2ADDR: /* 0xcd */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (205 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_DOUBLE_2ADDR: /* 0xce */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (206 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_DOUBLE_2ADDR: /* 0xcf */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (207 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_INT_LIT16: /* 0xd0 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (208 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_RSUB_INT: /* 0xd1 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (209 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_INT_LIT16: /* 0xd2 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (210 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_INT_LIT16: /* 0xd3 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (211 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_INT_LIT16: /* 0xd4 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (212 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AND_INT_LIT16: /* 0xd5 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (213 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_OR_INT_LIT16: /* 0xd6 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (214 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_XOR_INT_LIT16: /* 0xd7 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (215 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_INT_LIT8: /* 0xd8 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (216 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_RSUB_INT_LIT8: /* 0xd9 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (217 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_INT_LIT8: /* 0xda */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (218 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_INT_LIT8: /* 0xdb */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (219 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_INT_LIT8: /* 0xdc */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (220 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AND_INT_LIT8: /* 0xdd */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (221 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_OR_INT_LIT8: /* 0xde */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (222 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_XOR_INT_LIT8: /* 0xdf */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (223 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHL_INT_LIT8: /* 0xe0 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (224 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHR_INT_LIT8: /* 0xe1 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (225 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_USHR_INT_LIT8: /* 0xe2 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (226 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_VOLATILE: /* 0xe3 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (227 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_VOLATILE: /* 0xe4 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (228 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET_VOLATILE: /* 0xe5 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (229 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT_VOLATILE: /* 0xe6 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (230 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_OBJECT_VOLATILE: /* 0xe7 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (231 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_WIDE_VOLATILE: /* 0xe8 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (232 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_WIDE_VOLATILE: /* 0xe9 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (233 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET_WIDE_VOLATILE: /* 0xea */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (234 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT_WIDE_VOLATILE: /* 0xeb */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (235 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_BREAKPOINT: /* 0xec */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (236 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_THROW_VERIFICATION_ERROR: /* 0xed */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (237 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_EXECUTE_INLINE: /* 0xee */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (238 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_EXECUTE_INLINE_RANGE: /* 0xef */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (239 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_OBJECT_INIT_RANGE: /* 0xf0 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (240 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_RETURN_VOID_BARRIER: /* 0xf1 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (241 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_QUICK: /* 0xf2 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (242 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_WIDE_QUICK: /* 0xf3 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (243 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_OBJECT_QUICK: /* 0xf4 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (244 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_QUICK: /* 0xf5 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (245 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_WIDE_QUICK: /* 0xf6 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (246 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_OBJECT_VOLATILE_finish:
+    @bl      common_squeak0
+    mov     r1, rINST, lsr #8           @ r1<- A+
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    and     r1, r1, #15                 @ r1<- A
+    cmp     r9, #0                      @ check object for null
+    GET_VREG(r0, r1)                    @ r0<- fp[A]
+    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SMP_DMB_ST                        @ releasing store
+    str     r0, [r9, r3]                @ obj.field (32 bits)<- r0
+    SMP_DMB
+    cmp     r0, #0                      @ stored a null reference?
+    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card if not
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_OBJECT_QUICK: /* 0xf7 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (247 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
+/* continuation for OP_SGET_OBJECT_VOLATILE */
 
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_VIRTUAL_QUICK: /* 0xf8 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (248 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SGET_OBJECT_VOLATILE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_OBJECT_VOLATILE_finish
 
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_VIRTUAL_QUICK_RANGE: /* 0xf9 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (249 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
+/* continuation for OP_SPUT_OBJECT_VOLATILE */
 
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_SUPER_QUICK: /* 0xfa */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (250 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
 
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_SUPER_QUICK_RANGE: /* 0xfb */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (251 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
+.LOP_SPUT_OBJECT_VOLATILE_end:
+    str     r1, [r0, #offStaticField_value]  @ field<- vAA
+    SMP_DMB
+    cmp     r1, #0                      @ stored a null object?
+    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card based on obj head
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_OBJECT_VOLATILE: /* 0xfc */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (252 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
+    /* Continuation if the field has not yet been resolved.
+     * r1:  BBBB field ref
+     * r10: dvmDex->pResFields
+     */
+.LOP_SPUT_OBJECT_VOLATILE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_OBJECT_VOLATILE_finish          @ resume
 
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET_OBJECT_VOLATILE: /* 0xfd */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (253 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
 
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT_OBJECT_VOLATILE: /* 0xfe */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (254 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
+    .size   dvmAsmSisterStart, .-dvmAsmSisterStart
+    .global dvmAsmSisterEnd
+dvmAsmSisterEnd:
 
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DISPATCH_FF: /* 0xff */
-/* File: armv5te/ALT_OP_DISPATCH_FF.S */
-/*
- * Unlike other alt stubs, we don't want to call dvmCheckBefore() here.
- * Instead, just treat this as a trampoline to reach the real alt
- * handler (which will do the dvmCheckBefore() call.
- */
-    mov     ip, rINST, lsr #8           @ ip<- extended opcode
-    add     ip, ip, #256                @ add offset for extended opcodes
-    GOTO_OPCODE(ip)                     @ go to proper extended handler
 
+    .global dvmAsmAltInstructionStart
+    .type   dvmAsmAltInstructionStart, %function
+    .text
 
+dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_CONST_CLASS_JUMBO: /* 0x100 */
+.L_ALT_OP_NOP: /* 0x00 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20346,7 +9761,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (256 * 64)
+    adrl   lr, dvmAsmInstructionStart + (0 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20358,7 +9773,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_CHECK_CAST_JUMBO: /* 0x101 */
+.L_ALT_OP_MOVE: /* 0x01 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20369,7 +9784,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (257 * 64)
+    adrl   lr, dvmAsmInstructionStart + (1 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20381,7 +9796,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_INSTANCE_OF_JUMBO: /* 0x102 */
+.L_ALT_OP_MOVE_FROM16: /* 0x02 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20392,7 +9807,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (258 * 64)
+    adrl   lr, dvmAsmInstructionStart + (2 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20404,7 +9819,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_NEW_INSTANCE_JUMBO: /* 0x103 */
+.L_ALT_OP_MOVE_16: /* 0x03 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20415,7 +9830,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (259 * 64)
+    adrl   lr, dvmAsmInstructionStart + (3 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20427,7 +9842,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_NEW_ARRAY_JUMBO: /* 0x104 */
+.L_ALT_OP_MOVE_WIDE: /* 0x04 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20438,7 +9853,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (260 * 64)
+    adrl   lr, dvmAsmInstructionStart + (4 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20450,7 +9865,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_FILLED_NEW_ARRAY_JUMBO: /* 0x105 */
+.L_ALT_OP_MOVE_WIDE_FROM16: /* 0x05 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20461,7 +9876,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (261 * 64)
+    adrl   lr, dvmAsmInstructionStart + (5 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20473,7 +9888,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_JUMBO: /* 0x106 */
+.L_ALT_OP_MOVE_WIDE_16: /* 0x06 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20484,7 +9899,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (262 * 64)
+    adrl   lr, dvmAsmInstructionStart + (6 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20496,7 +9911,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_WIDE_JUMBO: /* 0x107 */
+.L_ALT_OP_MOVE_OBJECT: /* 0x07 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20507,7 +9922,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (263 * 64)
+    adrl   lr, dvmAsmInstructionStart + (7 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20519,7 +9934,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_OBJECT_JUMBO: /* 0x108 */
+.L_ALT_OP_MOVE_OBJECT_FROM16: /* 0x08 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20530,7 +9945,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (264 * 64)
+    adrl   lr, dvmAsmInstructionStart + (8 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20542,7 +9957,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_BOOLEAN_JUMBO: /* 0x109 */
+.L_ALT_OP_MOVE_OBJECT_16: /* 0x09 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20553,7 +9968,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (265 * 64)
+    adrl   lr, dvmAsmInstructionStart + (9 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20565,7 +9980,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_BYTE_JUMBO: /* 0x10a */
+.L_ALT_OP_MOVE_RESULT: /* 0x0a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20576,7 +9991,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (266 * 64)
+    adrl   lr, dvmAsmInstructionStart + (10 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20588,7 +10003,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_CHAR_JUMBO: /* 0x10b */
+.L_ALT_OP_MOVE_RESULT_WIDE: /* 0x0b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20599,7 +10014,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (267 * 64)
+    adrl   lr, dvmAsmInstructionStart + (11 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20611,7 +10026,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_SHORT_JUMBO: /* 0x10c */
+.L_ALT_OP_MOVE_RESULT_OBJECT: /* 0x0c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20622,7 +10037,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (268 * 64)
+    adrl   lr, dvmAsmInstructionStart + (12 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20634,7 +10049,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_JUMBO: /* 0x10d */
+.L_ALT_OP_MOVE_EXCEPTION: /* 0x0d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20645,7 +10060,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (269 * 64)
+    adrl   lr, dvmAsmInstructionStart + (13 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20657,7 +10072,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_WIDE_JUMBO: /* 0x10e */
+.L_ALT_OP_RETURN_VOID: /* 0x0e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20668,7 +10083,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (270 * 64)
+    adrl   lr, dvmAsmInstructionStart + (14 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20680,7 +10095,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_OBJECT_JUMBO: /* 0x10f */
+.L_ALT_OP_RETURN: /* 0x0f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20691,7 +10106,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (271 * 64)
+    adrl   lr, dvmAsmInstructionStart + (15 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20703,7 +10118,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_BOOLEAN_JUMBO: /* 0x110 */
+.L_ALT_OP_RETURN_WIDE: /* 0x10 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20714,7 +10129,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (272 * 64)
+    adrl   lr, dvmAsmInstructionStart + (16 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20726,7 +10141,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_BYTE_JUMBO: /* 0x111 */
+.L_ALT_OP_RETURN_OBJECT: /* 0x11 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20737,7 +10152,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (273 * 64)
+    adrl   lr, dvmAsmInstructionStart + (17 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20749,7 +10164,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_CHAR_JUMBO: /* 0x112 */
+.L_ALT_OP_CONST_4: /* 0x12 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20760,7 +10175,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (274 * 64)
+    adrl   lr, dvmAsmInstructionStart + (18 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20772,7 +10187,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_SHORT_JUMBO: /* 0x113 */
+.L_ALT_OP_CONST_16: /* 0x13 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20783,7 +10198,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (275 * 64)
+    adrl   lr, dvmAsmInstructionStart + (19 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20795,7 +10210,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_JUMBO: /* 0x114 */
+.L_ALT_OP_CONST: /* 0x14 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20806,7 +10221,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (276 * 64)
+    adrl   lr, dvmAsmInstructionStart + (20 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20818,7 +10233,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_WIDE_JUMBO: /* 0x115 */
+.L_ALT_OP_CONST_HIGH16: /* 0x15 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20829,7 +10244,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (277 * 64)
+    adrl   lr, dvmAsmInstructionStart + (21 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20841,7 +10256,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_OBJECT_JUMBO: /* 0x116 */
+.L_ALT_OP_CONST_WIDE_16: /* 0x16 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20852,7 +10267,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (278 * 64)
+    adrl   lr, dvmAsmInstructionStart + (22 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20864,7 +10279,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_BOOLEAN_JUMBO: /* 0x117 */
+.L_ALT_OP_CONST_WIDE_32: /* 0x17 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20875,7 +10290,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (279 * 64)
+    adrl   lr, dvmAsmInstructionStart + (23 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20887,7 +10302,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_BYTE_JUMBO: /* 0x118 */
+.L_ALT_OP_CONST_WIDE: /* 0x18 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20898,7 +10313,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (280 * 64)
+    adrl   lr, dvmAsmInstructionStart + (24 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20910,7 +10325,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_CHAR_JUMBO: /* 0x119 */
+.L_ALT_OP_CONST_WIDE_HIGH16: /* 0x19 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20921,7 +10336,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (281 * 64)
+    adrl   lr, dvmAsmInstructionStart + (25 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20933,7 +10348,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_SHORT_JUMBO: /* 0x11a */
+.L_ALT_OP_CONST_STRING: /* 0x1a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20944,7 +10359,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (282 * 64)
+    adrl   lr, dvmAsmInstructionStart + (26 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20956,7 +10371,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_JUMBO: /* 0x11b */
+.L_ALT_OP_CONST_STRING_JUMBO: /* 0x1b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20967,7 +10382,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (283 * 64)
+    adrl   lr, dvmAsmInstructionStart + (27 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20979,7 +10394,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_WIDE_JUMBO: /* 0x11c */
+.L_ALT_OP_CONST_CLASS: /* 0x1c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20990,7 +10405,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (284 * 64)
+    adrl   lr, dvmAsmInstructionStart + (28 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21002,7 +10417,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_OBJECT_JUMBO: /* 0x11d */
+.L_ALT_OP_MONITOR_ENTER: /* 0x1d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21013,7 +10428,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (285 * 64)
+    adrl   lr, dvmAsmInstructionStart + (29 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21025,7 +10440,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_BOOLEAN_JUMBO: /* 0x11e */
+.L_ALT_OP_MONITOR_EXIT: /* 0x1e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21036,7 +10451,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (286 * 64)
+    adrl   lr, dvmAsmInstructionStart + (30 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21048,7 +10463,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_BYTE_JUMBO: /* 0x11f */
+.L_ALT_OP_CHECK_CAST: /* 0x1f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21059,7 +10474,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (287 * 64)
+    adrl   lr, dvmAsmInstructionStart + (31 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21071,7 +10486,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_CHAR_JUMBO: /* 0x120 */
+.L_ALT_OP_INSTANCE_OF: /* 0x20 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21082,7 +10497,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (288 * 64)
+    adrl   lr, dvmAsmInstructionStart + (32 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21094,7 +10509,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_SHORT_JUMBO: /* 0x121 */
+.L_ALT_OP_ARRAY_LENGTH: /* 0x21 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21105,7 +10520,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (289 * 64)
+    adrl   lr, dvmAsmInstructionStart + (33 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21117,7 +10532,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_INVOKE_VIRTUAL_JUMBO: /* 0x122 */
+.L_ALT_OP_NEW_INSTANCE: /* 0x22 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21128,7 +10543,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (290 * 64)
+    adrl   lr, dvmAsmInstructionStart + (34 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21140,7 +10555,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_INVOKE_SUPER_JUMBO: /* 0x123 */
+.L_ALT_OP_NEW_ARRAY: /* 0x23 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21151,7 +10566,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (291 * 64)
+    adrl   lr, dvmAsmInstructionStart + (35 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21163,7 +10578,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_INVOKE_DIRECT_JUMBO: /* 0x124 */
+.L_ALT_OP_FILLED_NEW_ARRAY: /* 0x24 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21174,7 +10589,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (292 * 64)
+    adrl   lr, dvmAsmInstructionStart + (36 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21186,7 +10601,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_INVOKE_STATIC_JUMBO: /* 0x125 */
+.L_ALT_OP_FILLED_NEW_ARRAY_RANGE: /* 0x25 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21197,7 +10612,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (293 * 64)
+    adrl   lr, dvmAsmInstructionStart + (37 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21209,7 +10624,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_INVOKE_INTERFACE_JUMBO: /* 0x126 */
+.L_ALT_OP_FILL_ARRAY_DATA: /* 0x26 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21220,7 +10635,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (294 * 64)
+    adrl   lr, dvmAsmInstructionStart + (38 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21232,7 +10647,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_27FF: /* 0x127 */
+.L_ALT_OP_THROW: /* 0x27 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21243,7 +10658,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (295 * 64)
+    adrl   lr, dvmAsmInstructionStart + (39 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21255,7 +10670,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_28FF: /* 0x128 */
+.L_ALT_OP_GOTO: /* 0x28 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21266,7 +10681,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (296 * 64)
+    adrl   lr, dvmAsmInstructionStart + (40 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21278,7 +10693,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_29FF: /* 0x129 */
+.L_ALT_OP_GOTO_16: /* 0x29 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21289,7 +10704,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (297 * 64)
+    adrl   lr, dvmAsmInstructionStart + (41 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21301,7 +10716,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_2AFF: /* 0x12a */
+.L_ALT_OP_GOTO_32: /* 0x2a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21312,7 +10727,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (298 * 64)
+    adrl   lr, dvmAsmInstructionStart + (42 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21324,7 +10739,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_2BFF: /* 0x12b */
+.L_ALT_OP_PACKED_SWITCH: /* 0x2b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21335,7 +10750,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (299 * 64)
+    adrl   lr, dvmAsmInstructionStart + (43 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21347,7 +10762,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_2CFF: /* 0x12c */
+.L_ALT_OP_SPARSE_SWITCH: /* 0x2c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21358,7 +10773,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (300 * 64)
+    adrl   lr, dvmAsmInstructionStart + (44 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21370,7 +10785,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_2DFF: /* 0x12d */
+.L_ALT_OP_CMPL_FLOAT: /* 0x2d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21381,7 +10796,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (301 * 64)
+    adrl   lr, dvmAsmInstructionStart + (45 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21393,7 +10808,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_2EFF: /* 0x12e */
+.L_ALT_OP_CMPG_FLOAT: /* 0x2e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21404,7 +10819,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (302 * 64)
+    adrl   lr, dvmAsmInstructionStart + (46 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21416,7 +10831,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_2FFF: /* 0x12f */
+.L_ALT_OP_CMPL_DOUBLE: /* 0x2f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21427,7 +10842,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (303 * 64)
+    adrl   lr, dvmAsmInstructionStart + (47 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21439,7 +10854,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_30FF: /* 0x130 */
+.L_ALT_OP_CMPG_DOUBLE: /* 0x30 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21450,7 +10865,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (304 * 64)
+    adrl   lr, dvmAsmInstructionStart + (48 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21462,7 +10877,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_31FF: /* 0x131 */
+.L_ALT_OP_CMP_LONG: /* 0x31 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21473,7 +10888,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (305 * 64)
+    adrl   lr, dvmAsmInstructionStart + (49 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21485,7 +10900,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_32FF: /* 0x132 */
+.L_ALT_OP_IF_EQ: /* 0x32 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21496,7 +10911,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (306 * 64)
+    adrl   lr, dvmAsmInstructionStart + (50 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21508,7 +10923,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_33FF: /* 0x133 */
+.L_ALT_OP_IF_NE: /* 0x33 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21519,7 +10934,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (307 * 64)
+    adrl   lr, dvmAsmInstructionStart + (51 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21531,7 +10946,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_34FF: /* 0x134 */
+.L_ALT_OP_IF_LT: /* 0x34 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21542,7 +10957,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (308 * 64)
+    adrl   lr, dvmAsmInstructionStart + (52 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21554,7 +10969,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_35FF: /* 0x135 */
+.L_ALT_OP_IF_GE: /* 0x35 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21565,7 +10980,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (309 * 64)
+    adrl   lr, dvmAsmInstructionStart + (53 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21577,7 +10992,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_36FF: /* 0x136 */
+.L_ALT_OP_IF_GT: /* 0x36 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21588,7 +11003,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (310 * 64)
+    adrl   lr, dvmAsmInstructionStart + (54 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21600,7 +11015,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_37FF: /* 0x137 */
+.L_ALT_OP_IF_LE: /* 0x37 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21611,7 +11026,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (311 * 64)
+    adrl   lr, dvmAsmInstructionStart + (55 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21623,7 +11038,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_38FF: /* 0x138 */
+.L_ALT_OP_IF_EQZ: /* 0x38 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21634,7 +11049,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (312 * 64)
+    adrl   lr, dvmAsmInstructionStart + (56 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21646,7 +11061,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_39FF: /* 0x139 */
+.L_ALT_OP_IF_NEZ: /* 0x39 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21657,7 +11072,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (313 * 64)
+    adrl   lr, dvmAsmInstructionStart + (57 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21669,7 +11084,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_3AFF: /* 0x13a */
+.L_ALT_OP_IF_LTZ: /* 0x3a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21680,7 +11095,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (314 * 64)
+    adrl   lr, dvmAsmInstructionStart + (58 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21692,7 +11107,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_3BFF: /* 0x13b */
+.L_ALT_OP_IF_GEZ: /* 0x3b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21703,7 +11118,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (315 * 64)
+    adrl   lr, dvmAsmInstructionStart + (59 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21715,7 +11130,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_3CFF: /* 0x13c */
+.L_ALT_OP_IF_GTZ: /* 0x3c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21726,7 +11141,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (316 * 64)
+    adrl   lr, dvmAsmInstructionStart + (60 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21738,7 +11153,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_3DFF: /* 0x13d */
+.L_ALT_OP_IF_LEZ: /* 0x3d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21749,7 +11164,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (317 * 64)
+    adrl   lr, dvmAsmInstructionStart + (61 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21761,7 +11176,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_3EFF: /* 0x13e */
+.L_ALT_OP_UNUSED_3E: /* 0x3e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21772,7 +11187,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (318 * 64)
+    adrl   lr, dvmAsmInstructionStart + (62 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21784,7 +11199,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_3FFF: /* 0x13f */
+.L_ALT_OP_UNUSED_3F: /* 0x3f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21795,7 +11210,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (319 * 64)
+    adrl   lr, dvmAsmInstructionStart + (63 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21807,7 +11222,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_40FF: /* 0x140 */
+.L_ALT_OP_UNUSED_40: /* 0x40 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21818,7 +11233,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (320 * 64)
+    adrl   lr, dvmAsmInstructionStart + (64 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21830,7 +11245,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_41FF: /* 0x141 */
+.L_ALT_OP_UNUSED_41: /* 0x41 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21841,7 +11256,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (321 * 64)
+    adrl   lr, dvmAsmInstructionStart + (65 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21853,7 +11268,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_42FF: /* 0x142 */
+.L_ALT_OP_UNUSED_42: /* 0x42 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21864,7 +11279,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (322 * 64)
+    adrl   lr, dvmAsmInstructionStart + (66 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21876,7 +11291,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_43FF: /* 0x143 */
+.L_ALT_OP_UNUSED_43: /* 0x43 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21887,7 +11302,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (323 * 64)
+    adrl   lr, dvmAsmInstructionStart + (67 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21899,7 +11314,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_44FF: /* 0x144 */
+.L_ALT_OP_AGET: /* 0x44 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21910,7 +11325,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (324 * 64)
+    adrl   lr, dvmAsmInstructionStart + (68 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21922,7 +11337,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_45FF: /* 0x145 */
+.L_ALT_OP_AGET_WIDE: /* 0x45 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21933,7 +11348,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (325 * 64)
+    adrl   lr, dvmAsmInstructionStart + (69 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21945,7 +11360,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_46FF: /* 0x146 */
+.L_ALT_OP_AGET_OBJECT: /* 0x46 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21956,7 +11371,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (326 * 64)
+    adrl   lr, dvmAsmInstructionStart + (70 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21968,7 +11383,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_47FF: /* 0x147 */
+.L_ALT_OP_AGET_BOOLEAN: /* 0x47 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21979,7 +11394,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (327 * 64)
+    adrl   lr, dvmAsmInstructionStart + (71 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21991,7 +11406,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_48FF: /* 0x148 */
+.L_ALT_OP_AGET_BYTE: /* 0x48 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22002,7 +11417,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (328 * 64)
+    adrl   lr, dvmAsmInstructionStart + (72 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22014,7 +11429,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_49FF: /* 0x149 */
+.L_ALT_OP_AGET_CHAR: /* 0x49 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22025,7 +11440,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (329 * 64)
+    adrl   lr, dvmAsmInstructionStart + (73 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22037,7 +11452,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_4AFF: /* 0x14a */
+.L_ALT_OP_AGET_SHORT: /* 0x4a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22048,7 +11463,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (330 * 64)
+    adrl   lr, dvmAsmInstructionStart + (74 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22060,7 +11475,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_4BFF: /* 0x14b */
+.L_ALT_OP_APUT: /* 0x4b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22071,7 +11486,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (331 * 64)
+    adrl   lr, dvmAsmInstructionStart + (75 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22083,7 +11498,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_4CFF: /* 0x14c */
+.L_ALT_OP_APUT_WIDE: /* 0x4c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22094,7 +11509,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (332 * 64)
+    adrl   lr, dvmAsmInstructionStart + (76 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22106,7 +11521,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_4DFF: /* 0x14d */
+.L_ALT_OP_APUT_OBJECT: /* 0x4d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22117,7 +11532,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (333 * 64)
+    adrl   lr, dvmAsmInstructionStart + (77 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22129,7 +11544,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_4EFF: /* 0x14e */
+.L_ALT_OP_APUT_BOOLEAN: /* 0x4e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22140,7 +11555,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (334 * 64)
+    adrl   lr, dvmAsmInstructionStart + (78 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22152,7 +11567,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_4FFF: /* 0x14f */
+.L_ALT_OP_APUT_BYTE: /* 0x4f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22163,7 +11578,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (335 * 64)
+    adrl   lr, dvmAsmInstructionStart + (79 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22175,7 +11590,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_50FF: /* 0x150 */
+.L_ALT_OP_APUT_CHAR: /* 0x50 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22186,7 +11601,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (336 * 64)
+    adrl   lr, dvmAsmInstructionStart + (80 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22198,7 +11613,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_51FF: /* 0x151 */
+.L_ALT_OP_APUT_SHORT: /* 0x51 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22209,7 +11624,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (337 * 64)
+    adrl   lr, dvmAsmInstructionStart + (81 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22221,7 +11636,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_52FF: /* 0x152 */
+.L_ALT_OP_IGET: /* 0x52 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22232,7 +11647,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (338 * 64)
+    adrl   lr, dvmAsmInstructionStart + (82 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22244,7 +11659,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_53FF: /* 0x153 */
+.L_ALT_OP_IGET_WIDE: /* 0x53 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22255,7 +11670,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (339 * 64)
+    adrl   lr, dvmAsmInstructionStart + (83 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22267,7 +11682,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_54FF: /* 0x154 */
+.L_ALT_OP_IGET_OBJECT: /* 0x54 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22278,7 +11693,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (340 * 64)
+    adrl   lr, dvmAsmInstructionStart + (84 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22290,7 +11705,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_55FF: /* 0x155 */
+.L_ALT_OP_IGET_BOOLEAN: /* 0x55 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22301,7 +11716,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (341 * 64)
+    adrl   lr, dvmAsmInstructionStart + (85 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22313,7 +11728,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_56FF: /* 0x156 */
+.L_ALT_OP_IGET_BYTE: /* 0x56 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22324,7 +11739,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (342 * 64)
+    adrl   lr, dvmAsmInstructionStart + (86 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22336,7 +11751,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_57FF: /* 0x157 */
+.L_ALT_OP_IGET_CHAR: /* 0x57 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22347,7 +11762,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (343 * 64)
+    adrl   lr, dvmAsmInstructionStart + (87 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22359,7 +11774,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_58FF: /* 0x158 */
+.L_ALT_OP_IGET_SHORT: /* 0x58 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22370,7 +11785,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (344 * 64)
+    adrl   lr, dvmAsmInstructionStart + (88 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22382,7 +11797,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_59FF: /* 0x159 */
+.L_ALT_OP_IPUT: /* 0x59 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22393,7 +11808,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (345 * 64)
+    adrl   lr, dvmAsmInstructionStart + (89 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22405,7 +11820,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_5AFF: /* 0x15a */
+.L_ALT_OP_IPUT_WIDE: /* 0x5a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22416,7 +11831,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (346 * 64)
+    adrl   lr, dvmAsmInstructionStart + (90 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22428,7 +11843,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_5BFF: /* 0x15b */
+.L_ALT_OP_IPUT_OBJECT: /* 0x5b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22439,7 +11854,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (347 * 64)
+    adrl   lr, dvmAsmInstructionStart + (91 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22451,7 +11866,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_5CFF: /* 0x15c */
+.L_ALT_OP_IPUT_BOOLEAN: /* 0x5c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22462,7 +11877,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (348 * 64)
+    adrl   lr, dvmAsmInstructionStart + (92 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22474,7 +11889,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_5DFF: /* 0x15d */
+.L_ALT_OP_IPUT_BYTE: /* 0x5d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22485,7 +11900,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (349 * 64)
+    adrl   lr, dvmAsmInstructionStart + (93 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22497,7 +11912,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_5EFF: /* 0x15e */
+.L_ALT_OP_IPUT_CHAR: /* 0x5e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22508,7 +11923,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (350 * 64)
+    adrl   lr, dvmAsmInstructionStart + (94 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22520,7 +11935,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_5FFF: /* 0x15f */
+.L_ALT_OP_IPUT_SHORT: /* 0x5f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22531,7 +11946,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (351 * 64)
+    adrl   lr, dvmAsmInstructionStart + (95 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22543,7 +11958,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_60FF: /* 0x160 */
+.L_ALT_OP_SGET: /* 0x60 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22554,7 +11969,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (352 * 64)
+    adrl   lr, dvmAsmInstructionStart + (96 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22566,7 +11981,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_61FF: /* 0x161 */
+.L_ALT_OP_SGET_WIDE: /* 0x61 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22577,7 +11992,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (353 * 64)
+    adrl   lr, dvmAsmInstructionStart + (97 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22589,7 +12004,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_62FF: /* 0x162 */
+.L_ALT_OP_SGET_OBJECT: /* 0x62 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22600,7 +12015,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (354 * 64)
+    adrl   lr, dvmAsmInstructionStart + (98 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22612,7 +12027,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_63FF: /* 0x163 */
+.L_ALT_OP_SGET_BOOLEAN: /* 0x63 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22623,7 +12038,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (355 * 64)
+    adrl   lr, dvmAsmInstructionStart + (99 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22635,7 +12050,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_64FF: /* 0x164 */
+.L_ALT_OP_SGET_BYTE: /* 0x64 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22646,7 +12061,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (356 * 64)
+    adrl   lr, dvmAsmInstructionStart + (100 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22658,7 +12073,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_65FF: /* 0x165 */
+.L_ALT_OP_SGET_CHAR: /* 0x65 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22669,7 +12084,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (357 * 64)
+    adrl   lr, dvmAsmInstructionStart + (101 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22681,7 +12096,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_66FF: /* 0x166 */
+.L_ALT_OP_SGET_SHORT: /* 0x66 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22692,7 +12107,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (358 * 64)
+    adrl   lr, dvmAsmInstructionStart + (102 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22704,7 +12119,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_67FF: /* 0x167 */
+.L_ALT_OP_SPUT: /* 0x67 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22715,7 +12130,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (359 * 64)
+    adrl   lr, dvmAsmInstructionStart + (103 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22727,7 +12142,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_68FF: /* 0x168 */
+.L_ALT_OP_SPUT_WIDE: /* 0x68 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22738,7 +12153,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (360 * 64)
+    adrl   lr, dvmAsmInstructionStart + (104 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22750,7 +12165,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_69FF: /* 0x169 */
+.L_ALT_OP_SPUT_OBJECT: /* 0x69 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22761,7 +12176,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (361 * 64)
+    adrl   lr, dvmAsmInstructionStart + (105 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22773,7 +12188,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_6AFF: /* 0x16a */
+.L_ALT_OP_SPUT_BOOLEAN: /* 0x6a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22784,7 +12199,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (362 * 64)
+    adrl   lr, dvmAsmInstructionStart + (106 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22796,7 +12211,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_6BFF: /* 0x16b */
+.L_ALT_OP_SPUT_BYTE: /* 0x6b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22807,7 +12222,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (363 * 64)
+    adrl   lr, dvmAsmInstructionStart + (107 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22819,7 +12234,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_6CFF: /* 0x16c */
+.L_ALT_OP_SPUT_CHAR: /* 0x6c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22830,7 +12245,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (364 * 64)
+    adrl   lr, dvmAsmInstructionStart + (108 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22842,7 +12257,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_6DFF: /* 0x16d */
+.L_ALT_OP_SPUT_SHORT: /* 0x6d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22853,7 +12268,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (365 * 64)
+    adrl   lr, dvmAsmInstructionStart + (109 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22865,7 +12280,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_6EFF: /* 0x16e */
+.L_ALT_OP_INVOKE_VIRTUAL: /* 0x6e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22876,7 +12291,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (366 * 64)
+    adrl   lr, dvmAsmInstructionStart + (110 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22888,7 +12303,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_6FFF: /* 0x16f */
+.L_ALT_OP_INVOKE_SUPER: /* 0x6f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22899,7 +12314,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (367 * 64)
+    adrl   lr, dvmAsmInstructionStart + (111 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22911,7 +12326,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_70FF: /* 0x170 */
+.L_ALT_OP_INVOKE_DIRECT: /* 0x70 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22922,7 +12337,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (368 * 64)
+    adrl   lr, dvmAsmInstructionStart + (112 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22934,7 +12349,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_71FF: /* 0x171 */
+.L_ALT_OP_INVOKE_STATIC: /* 0x71 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22945,7 +12360,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (369 * 64)
+    adrl   lr, dvmAsmInstructionStart + (113 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22957,7 +12372,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_72FF: /* 0x172 */
+.L_ALT_OP_INVOKE_INTERFACE: /* 0x72 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22968,7 +12383,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (370 * 64)
+    adrl   lr, dvmAsmInstructionStart + (114 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22980,7 +12395,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_73FF: /* 0x173 */
+.L_ALT_OP_UNUSED_73: /* 0x73 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22991,7 +12406,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (371 * 64)
+    adrl   lr, dvmAsmInstructionStart + (115 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23003,7 +12418,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_74FF: /* 0x174 */
+.L_ALT_OP_INVOKE_VIRTUAL_RANGE: /* 0x74 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23014,7 +12429,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (372 * 64)
+    adrl   lr, dvmAsmInstructionStart + (116 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23026,7 +12441,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_75FF: /* 0x175 */
+.L_ALT_OP_INVOKE_SUPER_RANGE: /* 0x75 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23037,7 +12452,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (373 * 64)
+    adrl   lr, dvmAsmInstructionStart + (117 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23049,7 +12464,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_76FF: /* 0x176 */
+.L_ALT_OP_INVOKE_DIRECT_RANGE: /* 0x76 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23060,7 +12475,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (374 * 64)
+    adrl   lr, dvmAsmInstructionStart + (118 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23072,7 +12487,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_77FF: /* 0x177 */
+.L_ALT_OP_INVOKE_STATIC_RANGE: /* 0x77 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23083,7 +12498,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (375 * 64)
+    adrl   lr, dvmAsmInstructionStart + (119 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23095,7 +12510,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_78FF: /* 0x178 */
+.L_ALT_OP_INVOKE_INTERFACE_RANGE: /* 0x78 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23106,7 +12521,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (376 * 64)
+    adrl   lr, dvmAsmInstructionStart + (120 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23118,7 +12533,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_79FF: /* 0x179 */
+.L_ALT_OP_UNUSED_79: /* 0x79 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23129,7 +12544,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (377 * 64)
+    adrl   lr, dvmAsmInstructionStart + (121 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23141,7 +12556,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_7AFF: /* 0x17a */
+.L_ALT_OP_UNUSED_7A: /* 0x7a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23152,7 +12567,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (378 * 64)
+    adrl   lr, dvmAsmInstructionStart + (122 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23164,7 +12579,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_7BFF: /* 0x17b */
+.L_ALT_OP_NEG_INT: /* 0x7b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23175,7 +12590,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (379 * 64)
+    adrl   lr, dvmAsmInstructionStart + (123 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23187,7 +12602,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_7CFF: /* 0x17c */
+.L_ALT_OP_NOT_INT: /* 0x7c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23198,7 +12613,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (380 * 64)
+    adrl   lr, dvmAsmInstructionStart + (124 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23210,7 +12625,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_7DFF: /* 0x17d */
+.L_ALT_OP_NEG_LONG: /* 0x7d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23221,7 +12636,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (381 * 64)
+    adrl   lr, dvmAsmInstructionStart + (125 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23233,7 +12648,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_7EFF: /* 0x17e */
+.L_ALT_OP_NOT_LONG: /* 0x7e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23244,7 +12659,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (382 * 64)
+    adrl   lr, dvmAsmInstructionStart + (126 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23256,7 +12671,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_7FFF: /* 0x17f */
+.L_ALT_OP_NEG_FLOAT: /* 0x7f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23267,7 +12682,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (383 * 64)
+    adrl   lr, dvmAsmInstructionStart + (127 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23279,7 +12694,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_80FF: /* 0x180 */
+.L_ALT_OP_NEG_DOUBLE: /* 0x80 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23290,7 +12705,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (384 * 64)
+    adrl   lr, dvmAsmInstructionStart + (128 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23302,7 +12717,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_81FF: /* 0x181 */
+.L_ALT_OP_INT_TO_LONG: /* 0x81 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23313,7 +12728,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (385 * 64)
+    adrl   lr, dvmAsmInstructionStart + (129 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23325,7 +12740,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_82FF: /* 0x182 */
+.L_ALT_OP_INT_TO_FLOAT: /* 0x82 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23336,7 +12751,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (386 * 64)
+    adrl   lr, dvmAsmInstructionStart + (130 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23348,7 +12763,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_83FF: /* 0x183 */
+.L_ALT_OP_INT_TO_DOUBLE: /* 0x83 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23359,7 +12774,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (387 * 64)
+    adrl   lr, dvmAsmInstructionStart + (131 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23371,7 +12786,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_84FF: /* 0x184 */
+.L_ALT_OP_LONG_TO_INT: /* 0x84 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23382,7 +12797,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (388 * 64)
+    adrl   lr, dvmAsmInstructionStart + (132 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23394,7 +12809,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_85FF: /* 0x185 */
+.L_ALT_OP_LONG_TO_FLOAT: /* 0x85 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23405,7 +12820,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (389 * 64)
+    adrl   lr, dvmAsmInstructionStart + (133 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23417,7 +12832,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_86FF: /* 0x186 */
+.L_ALT_OP_LONG_TO_DOUBLE: /* 0x86 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23428,7 +12843,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (390 * 64)
+    adrl   lr, dvmAsmInstructionStart + (134 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23440,7 +12855,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_87FF: /* 0x187 */
+.L_ALT_OP_FLOAT_TO_INT: /* 0x87 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23451,7 +12866,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (391 * 64)
+    adrl   lr, dvmAsmInstructionStart + (135 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23463,7 +12878,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_88FF: /* 0x188 */
+.L_ALT_OP_FLOAT_TO_LONG: /* 0x88 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23474,7 +12889,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (392 * 64)
+    adrl   lr, dvmAsmInstructionStart + (136 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23486,7 +12901,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_89FF: /* 0x189 */
+.L_ALT_OP_FLOAT_TO_DOUBLE: /* 0x89 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23497,7 +12912,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (393 * 64)
+    adrl   lr, dvmAsmInstructionStart + (137 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23509,7 +12924,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_8AFF: /* 0x18a */
+.L_ALT_OP_DOUBLE_TO_INT: /* 0x8a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23520,7 +12935,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (394 * 64)
+    adrl   lr, dvmAsmInstructionStart + (138 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23532,7 +12947,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_8BFF: /* 0x18b */
+.L_ALT_OP_DOUBLE_TO_LONG: /* 0x8b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23543,7 +12958,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (395 * 64)
+    adrl   lr, dvmAsmInstructionStart + (139 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23555,7 +12970,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_8CFF: /* 0x18c */
+.L_ALT_OP_DOUBLE_TO_FLOAT: /* 0x8c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23566,7 +12981,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (396 * 64)
+    adrl   lr, dvmAsmInstructionStart + (140 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23578,7 +12993,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_8DFF: /* 0x18d */
+.L_ALT_OP_INT_TO_BYTE: /* 0x8d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23589,7 +13004,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (397 * 64)
+    adrl   lr, dvmAsmInstructionStart + (141 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23601,7 +13016,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_8EFF: /* 0x18e */
+.L_ALT_OP_INT_TO_CHAR: /* 0x8e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23612,7 +13027,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (398 * 64)
+    adrl   lr, dvmAsmInstructionStart + (142 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23624,7 +13039,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_8FFF: /* 0x18f */
+.L_ALT_OP_INT_TO_SHORT: /* 0x8f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23635,7 +13050,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (399 * 64)
+    adrl   lr, dvmAsmInstructionStart + (143 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23647,7 +13062,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_90FF: /* 0x190 */
+.L_ALT_OP_ADD_INT: /* 0x90 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23658,7 +13073,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (400 * 64)
+    adrl   lr, dvmAsmInstructionStart + (144 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23670,7 +13085,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_91FF: /* 0x191 */
+.L_ALT_OP_SUB_INT: /* 0x91 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23681,7 +13096,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (401 * 64)
+    adrl   lr, dvmAsmInstructionStart + (145 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23693,7 +13108,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_92FF: /* 0x192 */
+.L_ALT_OP_MUL_INT: /* 0x92 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23704,7 +13119,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (402 * 64)
+    adrl   lr, dvmAsmInstructionStart + (146 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23716,7 +13131,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_93FF: /* 0x193 */
+.L_ALT_OP_DIV_INT: /* 0x93 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23727,7 +13142,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (403 * 64)
+    adrl   lr, dvmAsmInstructionStart + (147 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23739,7 +13154,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_94FF: /* 0x194 */
+.L_ALT_OP_REM_INT: /* 0x94 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23750,7 +13165,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (404 * 64)
+    adrl   lr, dvmAsmInstructionStart + (148 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23762,7 +13177,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_95FF: /* 0x195 */
+.L_ALT_OP_AND_INT: /* 0x95 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23773,7 +13188,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (405 * 64)
+    adrl   lr, dvmAsmInstructionStart + (149 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23785,7 +13200,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_96FF: /* 0x196 */
+.L_ALT_OP_OR_INT: /* 0x96 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23796,7 +13211,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (406 * 64)
+    adrl   lr, dvmAsmInstructionStart + (150 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23808,7 +13223,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_97FF: /* 0x197 */
+.L_ALT_OP_XOR_INT: /* 0x97 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23819,7 +13234,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (407 * 64)
+    adrl   lr, dvmAsmInstructionStart + (151 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23831,7 +13246,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_98FF: /* 0x198 */
+.L_ALT_OP_SHL_INT: /* 0x98 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23842,7 +13257,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (408 * 64)
+    adrl   lr, dvmAsmInstructionStart + (152 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23854,7 +13269,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_99FF: /* 0x199 */
+.L_ALT_OP_SHR_INT: /* 0x99 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23865,7 +13280,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (409 * 64)
+    adrl   lr, dvmAsmInstructionStart + (153 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23877,7 +13292,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_9AFF: /* 0x19a */
+.L_ALT_OP_USHR_INT: /* 0x9a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23888,7 +13303,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (410 * 64)
+    adrl   lr, dvmAsmInstructionStart + (154 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23900,7 +13315,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_9BFF: /* 0x19b */
+.L_ALT_OP_ADD_LONG: /* 0x9b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23911,7 +13326,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (411 * 64)
+    adrl   lr, dvmAsmInstructionStart + (155 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23923,7 +13338,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_9CFF: /* 0x19c */
+.L_ALT_OP_SUB_LONG: /* 0x9c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23934,7 +13349,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (412 * 64)
+    adrl   lr, dvmAsmInstructionStart + (156 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23946,7 +13361,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_9DFF: /* 0x19d */
+.L_ALT_OP_MUL_LONG: /* 0x9d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23957,7 +13372,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (413 * 64)
+    adrl   lr, dvmAsmInstructionStart + (157 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23969,7 +13384,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_9EFF: /* 0x19e */
+.L_ALT_OP_DIV_LONG: /* 0x9e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23980,7 +13395,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (414 * 64)
+    adrl   lr, dvmAsmInstructionStart + (158 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23992,7 +13407,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_9FFF: /* 0x19f */
+.L_ALT_OP_REM_LONG: /* 0x9f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24003,7 +13418,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (415 * 64)
+    adrl   lr, dvmAsmInstructionStart + (159 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24015,7 +13430,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A0FF: /* 0x1a0 */
+.L_ALT_OP_AND_LONG: /* 0xa0 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24026,7 +13441,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (416 * 64)
+    adrl   lr, dvmAsmInstructionStart + (160 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24038,7 +13453,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A1FF: /* 0x1a1 */
+.L_ALT_OP_OR_LONG: /* 0xa1 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24049,7 +13464,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (417 * 64)
+    adrl   lr, dvmAsmInstructionStart + (161 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24061,7 +13476,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A2FF: /* 0x1a2 */
+.L_ALT_OP_XOR_LONG: /* 0xa2 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24072,7 +13487,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (418 * 64)
+    adrl   lr, dvmAsmInstructionStart + (162 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24084,7 +13499,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A3FF: /* 0x1a3 */
+.L_ALT_OP_SHL_LONG: /* 0xa3 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24095,7 +13510,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (419 * 64)
+    adrl   lr, dvmAsmInstructionStart + (163 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24107,7 +13522,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A4FF: /* 0x1a4 */
+.L_ALT_OP_SHR_LONG: /* 0xa4 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24118,7 +13533,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (420 * 64)
+    adrl   lr, dvmAsmInstructionStart + (164 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24130,7 +13545,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A5FF: /* 0x1a5 */
+.L_ALT_OP_USHR_LONG: /* 0xa5 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24141,7 +13556,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (421 * 64)
+    adrl   lr, dvmAsmInstructionStart + (165 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24153,7 +13568,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A6FF: /* 0x1a6 */
+.L_ALT_OP_ADD_FLOAT: /* 0xa6 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24164,7 +13579,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (422 * 64)
+    adrl   lr, dvmAsmInstructionStart + (166 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24176,7 +13591,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A7FF: /* 0x1a7 */
+.L_ALT_OP_SUB_FLOAT: /* 0xa7 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24187,7 +13602,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (423 * 64)
+    adrl   lr, dvmAsmInstructionStart + (167 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24199,7 +13614,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A8FF: /* 0x1a8 */
+.L_ALT_OP_MUL_FLOAT: /* 0xa8 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24210,7 +13625,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (424 * 64)
+    adrl   lr, dvmAsmInstructionStart + (168 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24222,7 +13637,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A9FF: /* 0x1a9 */
+.L_ALT_OP_DIV_FLOAT: /* 0xa9 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24233,7 +13648,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (425 * 64)
+    adrl   lr, dvmAsmInstructionStart + (169 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24245,7 +13660,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_AAFF: /* 0x1aa */
+.L_ALT_OP_REM_FLOAT: /* 0xaa */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24256,7 +13671,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (426 * 64)
+    adrl   lr, dvmAsmInstructionStart + (170 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24268,7 +13683,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_ABFF: /* 0x1ab */
+.L_ALT_OP_ADD_DOUBLE: /* 0xab */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24279,7 +13694,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (427 * 64)
+    adrl   lr, dvmAsmInstructionStart + (171 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24291,7 +13706,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_ACFF: /* 0x1ac */
+.L_ALT_OP_SUB_DOUBLE: /* 0xac */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24302,7 +13717,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (428 * 64)
+    adrl   lr, dvmAsmInstructionStart + (172 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24314,7 +13729,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_ADFF: /* 0x1ad */
+.L_ALT_OP_MUL_DOUBLE: /* 0xad */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24325,7 +13740,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (429 * 64)
+    adrl   lr, dvmAsmInstructionStart + (173 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24337,7 +13752,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_AEFF: /* 0x1ae */
+.L_ALT_OP_DIV_DOUBLE: /* 0xae */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24348,7 +13763,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (430 * 64)
+    adrl   lr, dvmAsmInstructionStart + (174 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24360,7 +13775,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_AFFF: /* 0x1af */
+.L_ALT_OP_REM_DOUBLE: /* 0xaf */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24371,7 +13786,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (431 * 64)
+    adrl   lr, dvmAsmInstructionStart + (175 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24383,7 +13798,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B0FF: /* 0x1b0 */
+.L_ALT_OP_ADD_INT_2ADDR: /* 0xb0 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24394,7 +13809,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (432 * 64)
+    adrl   lr, dvmAsmInstructionStart + (176 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24406,7 +13821,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B1FF: /* 0x1b1 */
+.L_ALT_OP_SUB_INT_2ADDR: /* 0xb1 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24417,7 +13832,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (433 * 64)
+    adrl   lr, dvmAsmInstructionStart + (177 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24429,7 +13844,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B2FF: /* 0x1b2 */
+.L_ALT_OP_MUL_INT_2ADDR: /* 0xb2 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24440,7 +13855,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (434 * 64)
+    adrl   lr, dvmAsmInstructionStart + (178 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24452,7 +13867,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B3FF: /* 0x1b3 */
+.L_ALT_OP_DIV_INT_2ADDR: /* 0xb3 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24463,7 +13878,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (435 * 64)
+    adrl   lr, dvmAsmInstructionStart + (179 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24475,7 +13890,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B4FF: /* 0x1b4 */
+.L_ALT_OP_REM_INT_2ADDR: /* 0xb4 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24486,7 +13901,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (436 * 64)
+    adrl   lr, dvmAsmInstructionStart + (180 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24498,7 +13913,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B5FF: /* 0x1b5 */
+.L_ALT_OP_AND_INT_2ADDR: /* 0xb5 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24509,7 +13924,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (437 * 64)
+    adrl   lr, dvmAsmInstructionStart + (181 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24521,7 +13936,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B6FF: /* 0x1b6 */
+.L_ALT_OP_OR_INT_2ADDR: /* 0xb6 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24532,7 +13947,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (438 * 64)
+    adrl   lr, dvmAsmInstructionStart + (182 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24544,7 +13959,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B7FF: /* 0x1b7 */
+.L_ALT_OP_XOR_INT_2ADDR: /* 0xb7 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24555,7 +13970,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (439 * 64)
+    adrl   lr, dvmAsmInstructionStart + (183 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24567,7 +13982,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B8FF: /* 0x1b8 */
+.L_ALT_OP_SHL_INT_2ADDR: /* 0xb8 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24578,7 +13993,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (440 * 64)
+    adrl   lr, dvmAsmInstructionStart + (184 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24590,7 +14005,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B9FF: /* 0x1b9 */
+.L_ALT_OP_SHR_INT_2ADDR: /* 0xb9 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24601,7 +14016,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (441 * 64)
+    adrl   lr, dvmAsmInstructionStart + (185 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24613,7 +14028,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_BAFF: /* 0x1ba */
+.L_ALT_OP_USHR_INT_2ADDR: /* 0xba */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24624,7 +14039,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (442 * 64)
+    adrl   lr, dvmAsmInstructionStart + (186 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24636,7 +14051,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_BBFF: /* 0x1bb */
+.L_ALT_OP_ADD_LONG_2ADDR: /* 0xbb */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24647,7 +14062,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (443 * 64)
+    adrl   lr, dvmAsmInstructionStart + (187 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24659,7 +14074,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_BCFF: /* 0x1bc */
+.L_ALT_OP_SUB_LONG_2ADDR: /* 0xbc */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24670,7 +14085,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (444 * 64)
+    adrl   lr, dvmAsmInstructionStart + (188 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24682,7 +14097,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_BDFF: /* 0x1bd */
+.L_ALT_OP_MUL_LONG_2ADDR: /* 0xbd */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24693,7 +14108,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (445 * 64)
+    adrl   lr, dvmAsmInstructionStart + (189 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24705,7 +14120,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_BEFF: /* 0x1be */
+.L_ALT_OP_DIV_LONG_2ADDR: /* 0xbe */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24716,7 +14131,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (446 * 64)
+    adrl   lr, dvmAsmInstructionStart + (190 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24728,7 +14143,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_BFFF: /* 0x1bf */
+.L_ALT_OP_REM_LONG_2ADDR: /* 0xbf */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24739,7 +14154,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (447 * 64)
+    adrl   lr, dvmAsmInstructionStart + (191 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24751,7 +14166,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C0FF: /* 0x1c0 */
+.L_ALT_OP_AND_LONG_2ADDR: /* 0xc0 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24762,7 +14177,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (448 * 64)
+    adrl   lr, dvmAsmInstructionStart + (192 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24774,7 +14189,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C1FF: /* 0x1c1 */
+.L_ALT_OP_OR_LONG_2ADDR: /* 0xc1 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24785,7 +14200,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (449 * 64)
+    adrl   lr, dvmAsmInstructionStart + (193 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24797,7 +14212,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C2FF: /* 0x1c2 */
+.L_ALT_OP_XOR_LONG_2ADDR: /* 0xc2 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24808,7 +14223,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (450 * 64)
+    adrl   lr, dvmAsmInstructionStart + (194 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24820,7 +14235,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C3FF: /* 0x1c3 */
+.L_ALT_OP_SHL_LONG_2ADDR: /* 0xc3 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24831,7 +14246,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (451 * 64)
+    adrl   lr, dvmAsmInstructionStart + (195 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24843,7 +14258,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C4FF: /* 0x1c4 */
+.L_ALT_OP_SHR_LONG_2ADDR: /* 0xc4 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24854,7 +14269,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (452 * 64)
+    adrl   lr, dvmAsmInstructionStart + (196 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24866,7 +14281,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C5FF: /* 0x1c5 */
+.L_ALT_OP_USHR_LONG_2ADDR: /* 0xc5 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24877,7 +14292,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (453 * 64)
+    adrl   lr, dvmAsmInstructionStart + (197 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24889,7 +14304,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C6FF: /* 0x1c6 */
+.L_ALT_OP_ADD_FLOAT_2ADDR: /* 0xc6 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24900,7 +14315,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (454 * 64)
+    adrl   lr, dvmAsmInstructionStart + (198 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24912,7 +14327,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C7FF: /* 0x1c7 */
+.L_ALT_OP_SUB_FLOAT_2ADDR: /* 0xc7 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24923,7 +14338,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (455 * 64)
+    adrl   lr, dvmAsmInstructionStart + (199 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24935,7 +14350,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C8FF: /* 0x1c8 */
+.L_ALT_OP_MUL_FLOAT_2ADDR: /* 0xc8 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24946,7 +14361,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (456 * 64)
+    adrl   lr, dvmAsmInstructionStart + (200 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24958,7 +14373,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C9FF: /* 0x1c9 */
+.L_ALT_OP_DIV_FLOAT_2ADDR: /* 0xc9 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24969,7 +14384,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (457 * 64)
+    adrl   lr, dvmAsmInstructionStart + (201 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24981,7 +14396,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_CAFF: /* 0x1ca */
+.L_ALT_OP_REM_FLOAT_2ADDR: /* 0xca */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24992,7 +14407,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (458 * 64)
+    adrl   lr, dvmAsmInstructionStart + (202 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25004,7 +14419,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_CBFF: /* 0x1cb */
+.L_ALT_OP_ADD_DOUBLE_2ADDR: /* 0xcb */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25015,7 +14430,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (459 * 64)
+    adrl   lr, dvmAsmInstructionStart + (203 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25027,7 +14442,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_CCFF: /* 0x1cc */
+.L_ALT_OP_SUB_DOUBLE_2ADDR: /* 0xcc */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25038,7 +14453,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (460 * 64)
+    adrl   lr, dvmAsmInstructionStart + (204 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25050,7 +14465,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_CDFF: /* 0x1cd */
+.L_ALT_OP_MUL_DOUBLE_2ADDR: /* 0xcd */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25061,7 +14476,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (461 * 64)
+    adrl   lr, dvmAsmInstructionStart + (205 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25073,7 +14488,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_CEFF: /* 0x1ce */
+.L_ALT_OP_DIV_DOUBLE_2ADDR: /* 0xce */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25084,7 +14499,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (462 * 64)
+    adrl   lr, dvmAsmInstructionStart + (206 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25096,7 +14511,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_CFFF: /* 0x1cf */
+.L_ALT_OP_REM_DOUBLE_2ADDR: /* 0xcf */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25107,7 +14522,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (463 * 64)
+    adrl   lr, dvmAsmInstructionStart + (207 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25119,7 +14534,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D0FF: /* 0x1d0 */
+.L_ALT_OP_ADD_INT_LIT16: /* 0xd0 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25130,7 +14545,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (464 * 64)
+    adrl   lr, dvmAsmInstructionStart + (208 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25142,7 +14557,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D1FF: /* 0x1d1 */
+.L_ALT_OP_RSUB_INT: /* 0xd1 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25153,7 +14568,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (465 * 64)
+    adrl   lr, dvmAsmInstructionStart + (209 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25165,7 +14580,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D2FF: /* 0x1d2 */
+.L_ALT_OP_MUL_INT_LIT16: /* 0xd2 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25176,7 +14591,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (466 * 64)
+    adrl   lr, dvmAsmInstructionStart + (210 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25188,7 +14603,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D3FF: /* 0x1d3 */
+.L_ALT_OP_DIV_INT_LIT16: /* 0xd3 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25199,7 +14614,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (467 * 64)
+    adrl   lr, dvmAsmInstructionStart + (211 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25211,7 +14626,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D4FF: /* 0x1d4 */
+.L_ALT_OP_REM_INT_LIT16: /* 0xd4 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25222,7 +14637,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (468 * 64)
+    adrl   lr, dvmAsmInstructionStart + (212 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25234,7 +14649,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D5FF: /* 0x1d5 */
+.L_ALT_OP_AND_INT_LIT16: /* 0xd5 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25245,7 +14660,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (469 * 64)
+    adrl   lr, dvmAsmInstructionStart + (213 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25257,7 +14672,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D6FF: /* 0x1d6 */
+.L_ALT_OP_OR_INT_LIT16: /* 0xd6 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25268,7 +14683,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (470 * 64)
+    adrl   lr, dvmAsmInstructionStart + (214 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25280,7 +14695,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D7FF: /* 0x1d7 */
+.L_ALT_OP_XOR_INT_LIT16: /* 0xd7 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25291,7 +14706,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (471 * 64)
+    adrl   lr, dvmAsmInstructionStart + (215 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25303,7 +14718,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D8FF: /* 0x1d8 */
+.L_ALT_OP_ADD_INT_LIT8: /* 0xd8 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25314,7 +14729,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (472 * 64)
+    adrl   lr, dvmAsmInstructionStart + (216 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25326,7 +14741,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D9FF: /* 0x1d9 */
+.L_ALT_OP_RSUB_INT_LIT8: /* 0xd9 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25337,7 +14752,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (473 * 64)
+    adrl   lr, dvmAsmInstructionStart + (217 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25349,7 +14764,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_DAFF: /* 0x1da */
+.L_ALT_OP_MUL_INT_LIT8: /* 0xda */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25360,7 +14775,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (474 * 64)
+    adrl   lr, dvmAsmInstructionStart + (218 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25372,7 +14787,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_DBFF: /* 0x1db */
+.L_ALT_OP_DIV_INT_LIT8: /* 0xdb */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25383,7 +14798,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (475 * 64)
+    adrl   lr, dvmAsmInstructionStart + (219 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25395,7 +14810,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_DCFF: /* 0x1dc */
+.L_ALT_OP_REM_INT_LIT8: /* 0xdc */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25406,7 +14821,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (476 * 64)
+    adrl   lr, dvmAsmInstructionStart + (220 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25418,7 +14833,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_DDFF: /* 0x1dd */
+.L_ALT_OP_AND_INT_LIT8: /* 0xdd */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25429,7 +14844,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (477 * 64)
+    adrl   lr, dvmAsmInstructionStart + (221 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25441,7 +14856,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_DEFF: /* 0x1de */
+.L_ALT_OP_OR_INT_LIT8: /* 0xde */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25452,7 +14867,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (478 * 64)
+    adrl   lr, dvmAsmInstructionStart + (222 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25464,7 +14879,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_DFFF: /* 0x1df */
+.L_ALT_OP_XOR_INT_LIT8: /* 0xdf */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25475,7 +14890,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (479 * 64)
+    adrl   lr, dvmAsmInstructionStart + (223 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25487,7 +14902,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E0FF: /* 0x1e0 */
+.L_ALT_OP_SHL_INT_LIT8: /* 0xe0 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25498,7 +14913,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (480 * 64)
+    adrl   lr, dvmAsmInstructionStart + (224 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25510,7 +14925,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E1FF: /* 0x1e1 */
+.L_ALT_OP_SHR_INT_LIT8: /* 0xe1 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25521,7 +14936,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (481 * 64)
+    adrl   lr, dvmAsmInstructionStart + (225 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25533,7 +14948,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E2FF: /* 0x1e2 */
+.L_ALT_OP_USHR_INT_LIT8: /* 0xe2 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25544,7 +14959,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (482 * 64)
+    adrl   lr, dvmAsmInstructionStart + (226 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25556,7 +14971,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E3FF: /* 0x1e3 */
+.L_ALT_OP_IGET_VOLATILE: /* 0xe3 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25567,7 +14982,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (483 * 64)
+    adrl   lr, dvmAsmInstructionStart + (227 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25579,7 +14994,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E4FF: /* 0x1e4 */
+.L_ALT_OP_IPUT_VOLATILE: /* 0xe4 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25590,7 +15005,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (484 * 64)
+    adrl   lr, dvmAsmInstructionStart + (228 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25602,7 +15017,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E5FF: /* 0x1e5 */
+.L_ALT_OP_SGET_VOLATILE: /* 0xe5 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25613,7 +15028,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (485 * 64)
+    adrl   lr, dvmAsmInstructionStart + (229 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25625,7 +15040,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E6FF: /* 0x1e6 */
+.L_ALT_OP_SPUT_VOLATILE: /* 0xe6 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25636,7 +15051,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (486 * 64)
+    adrl   lr, dvmAsmInstructionStart + (230 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25648,7 +15063,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E7FF: /* 0x1e7 */
+.L_ALT_OP_IGET_OBJECT_VOLATILE: /* 0xe7 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25659,7 +15074,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (487 * 64)
+    adrl   lr, dvmAsmInstructionStart + (231 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25671,7 +15086,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E8FF: /* 0x1e8 */
+.L_ALT_OP_IGET_WIDE_VOLATILE: /* 0xe8 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25682,7 +15097,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (488 * 64)
+    adrl   lr, dvmAsmInstructionStart + (232 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25694,7 +15109,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E9FF: /* 0x1e9 */
+.L_ALT_OP_IPUT_WIDE_VOLATILE: /* 0xe9 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25705,7 +15120,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (489 * 64)
+    adrl   lr, dvmAsmInstructionStart + (233 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25717,7 +15132,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_EAFF: /* 0x1ea */
+.L_ALT_OP_SGET_WIDE_VOLATILE: /* 0xea */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25728,7 +15143,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (490 * 64)
+    adrl   lr, dvmAsmInstructionStart + (234 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25740,7 +15155,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_EBFF: /* 0x1eb */
+.L_ALT_OP_SPUT_WIDE_VOLATILE: /* 0xeb */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25751,7 +15166,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (491 * 64)
+    adrl   lr, dvmAsmInstructionStart + (235 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25763,7 +15178,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_ECFF: /* 0x1ec */
+.L_ALT_OP_BREAKPOINT: /* 0xec */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25774,7 +15189,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (492 * 64)
+    adrl   lr, dvmAsmInstructionStart + (236 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25786,7 +15201,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_EDFF: /* 0x1ed */
+.L_ALT_OP_THROW_VERIFICATION_ERROR: /* 0xed */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25797,7 +15212,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (493 * 64)
+    adrl   lr, dvmAsmInstructionStart + (237 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25809,7 +15224,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_EEFF: /* 0x1ee */
+.L_ALT_OP_EXECUTE_INLINE: /* 0xee */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25820,7 +15235,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (494 * 64)
+    adrl   lr, dvmAsmInstructionStart + (238 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25832,7 +15247,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_EFFF: /* 0x1ef */
+.L_ALT_OP_EXECUTE_INLINE_RANGE: /* 0xef */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25843,7 +15258,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (495 * 64)
+    adrl   lr, dvmAsmInstructionStart + (239 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25855,7 +15270,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_F0FF: /* 0x1f0 */
+.L_ALT_OP_INVOKE_OBJECT_INIT_RANGE: /* 0xf0 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25866,7 +15281,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (496 * 64)
+    adrl   lr, dvmAsmInstructionStart + (240 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25878,7 +15293,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_F1FF: /* 0x1f1 */
+.L_ALT_OP_RETURN_VOID_BARRIER: /* 0xf1 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25889,7 +15304,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (497 * 64)
+    adrl   lr, dvmAsmInstructionStart + (241 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25901,7 +15316,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_INVOKE_OBJECT_INIT_JUMBO: /* 0x1f2 */
+.L_ALT_OP_IGET_QUICK: /* 0xf2 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25912,7 +15327,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (498 * 64)
+    adrl   lr, dvmAsmInstructionStart + (242 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25924,7 +15339,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_VOLATILE_JUMBO: /* 0x1f3 */
+.L_ALT_OP_IGET_WIDE_QUICK: /* 0xf3 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25935,7 +15350,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (499 * 64)
+    adrl   lr, dvmAsmInstructionStart + (243 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25947,7 +15362,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_WIDE_VOLATILE_JUMBO: /* 0x1f4 */
+.L_ALT_OP_IGET_OBJECT_QUICK: /* 0xf4 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25958,7 +15373,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (500 * 64)
+    adrl   lr, dvmAsmInstructionStart + (244 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25970,7 +15385,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_OBJECT_VOLATILE_JUMBO: /* 0x1f5 */
+.L_ALT_OP_IPUT_QUICK: /* 0xf5 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25981,7 +15396,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (501 * 64)
+    adrl   lr, dvmAsmInstructionStart + (245 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25993,7 +15408,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_VOLATILE_JUMBO: /* 0x1f6 */
+.L_ALT_OP_IPUT_WIDE_QUICK: /* 0xf6 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26004,7 +15419,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (502 * 64)
+    adrl   lr, dvmAsmInstructionStart + (246 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26016,7 +15431,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_WIDE_VOLATILE_JUMBO: /* 0x1f7 */
+.L_ALT_OP_IPUT_OBJECT_QUICK: /* 0xf7 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26027,7 +15442,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (503 * 64)
+    adrl   lr, dvmAsmInstructionStart + (247 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26039,7 +15454,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_OBJECT_VOLATILE_JUMBO: /* 0x1f8 */
+.L_ALT_OP_INVOKE_VIRTUAL_QUICK: /* 0xf8 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26050,7 +15465,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (504 * 64)
+    adrl   lr, dvmAsmInstructionStart + (248 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26062,7 +15477,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_VOLATILE_JUMBO: /* 0x1f9 */
+.L_ALT_OP_INVOKE_VIRTUAL_QUICK_RANGE: /* 0xf9 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26073,7 +15488,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (505 * 64)
+    adrl   lr, dvmAsmInstructionStart + (249 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26085,7 +15500,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_WIDE_VOLATILE_JUMBO: /* 0x1fa */
+.L_ALT_OP_INVOKE_SUPER_QUICK: /* 0xfa */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26096,7 +15511,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (506 * 64)
+    adrl   lr, dvmAsmInstructionStart + (250 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26108,7 +15523,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_OBJECT_VOLATILE_JUMBO: /* 0x1fb */
+.L_ALT_OP_INVOKE_SUPER_QUICK_RANGE: /* 0xfb */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26119,7 +15534,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (507 * 64)
+    adrl   lr, dvmAsmInstructionStart + (251 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26131,7 +15546,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_VOLATILE_JUMBO: /* 0x1fc */
+.L_ALT_OP_IPUT_OBJECT_VOLATILE: /* 0xfc */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26142,7 +15557,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (508 * 64)
+    adrl   lr, dvmAsmInstructionStart + (252 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26154,7 +15569,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_WIDE_VOLATILE_JUMBO: /* 0x1fd */
+.L_ALT_OP_SGET_OBJECT_VOLATILE: /* 0xfd */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26165,7 +15580,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (509 * 64)
+    adrl   lr, dvmAsmInstructionStart + (253 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26177,7 +15592,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_OBJECT_VOLATILE_JUMBO: /* 0x1fe */
+.L_ALT_OP_SPUT_OBJECT_VOLATILE: /* 0xfe */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26188,7 +15603,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (510 * 64)
+    adrl   lr, dvmAsmInstructionStart + (254 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26200,7 +15615,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_THROW_VERIFICATION_ERROR_JUMBO: /* 0x1ff */
+.L_ALT_OP_UNUSED_FF: /* 0xff */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26211,7 +15626,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (511 * 64)
+    adrl   lr, dvmAsmInstructionStart + (255 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26694,35 +16109,6 @@ save_callsiteinfo:
 #endif
 
 /*
- * Common code for jumbo method invocation.
- * NOTE: this adjusts rPC to account for the difference in instruction width.
- * As a result, the savedPc in the stack frame will not be wholly accurate. So
- * long as that is only used for source file line number calculations, we're
- * okay.
- */
-common_invokeMethodJumboNoThis:
-#if defined(WITH_JIT)
- /* On entry: r0 is "Method* methodToCall */
-    mov     r9, #0                      @ clear "this"
-#endif
-common_invokeMethodJumbo:
- /* On entry: r0 is "Method* methodToCall, r9 is "this" */
-.LinvokeNewJumbo:
-#if defined(WITH_JIT)
-    ldrh    r1, [rSELF, #offThread_subMode]
-    ands    r1, #kSubModeJitTraceBuild
-    blne    save_callsiteinfo
-#endif
-    @ prepare to copy args to "outs" area of current frame
-    add     rPC, rPC, #4                @ adjust pc to make return consistent
-    FETCH(r2, 1)                        @ r2<- BBBB (arg count)
-    SAVEAREA_FROM_FP(r10, rFP)          @ r10<- stack save area
-    cmp     r2, #0                      @ no args?
-    beq     .LinvokeArgsDone            @ if no args, skip the rest
-    FETCH(r1, 2)                        @ r1<- CCCC
-    b       .LinvokeRangeArgs           @ handle args like invoke range
-
-/*
  * Common code for method invocation with range.
  *
  * On entry:
diff --git a/vm/mterp/out/InterpAsm-armv6j.S b/vm/mterp/out/InterpAsm-armv6j.S
index 0f765cf..4a9a52f 100644
--- a/vm/mterp/out/InterpAsm-armv6j.S
+++ b/vm/mterp/out/InterpAsm-armv6j.S
@@ -8022,12778 +8022,2193 @@ d2i_doconv:
 
 /* ------------------------------ */
     .balign 64
-.L_OP_DISPATCH_FF: /* 0xff */
-/* File: armv5te/OP_DISPATCH_FF.S */
-    mov     ip, rINST, lsr #8           @ ip<- extended opcode
-    add     ip, ip, #256                @ add offset for extended opcodes
-    GOTO_OPCODE(ip)                     @ go to proper extended handler
+.L_OP_UNUSED_FF: /* 0xff */
+/* File: armv5te/OP_UNUSED_FF.S */
+/* File: armv5te/unused.S */
+    bl      common_abort
 
 
-/* ------------------------------ */
     .balign 64
-.L_OP_CONST_CLASS_JUMBO: /* 0x100 */
-/* File: armv5te/OP_CONST_CLASS_JUMBO.S */
-    /* const-class/jumbo vBBBB, Class@AAAAAAAA */
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<-self>methodClassDex
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r2, [r2, #offDvmDex_pResClasses]   @ r2<- dvmDex->pResClasses
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    FETCH(r9, 3)                        @ r9<- BBBB
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- pResClasses[AAAAaaaa]
-    cmp     r0, #0                      @ not yet resolved?
-    beq     .LOP_CONST_CLASS_JUMBO_resolve
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r9)                    @ vBBBB<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+    .size   dvmAsmInstructionStart, .-dvmAsmInstructionStart
+    .global dvmAsmInstructionEnd
+dvmAsmInstructionEnd:
+
+/*
+ * ===========================================================================
+ *  Sister implementations
+ * ===========================================================================
+ */
+    .global dvmAsmSisterStart
+    .type   dvmAsmSisterStart, %function
+    .text
+    .balign 4
+dvmAsmSisterStart:
+
+/* continuation for OP_CONST_STRING */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_CHECK_CAST_JUMBO: /* 0x101 */
-/* File: armv5te/OP_CHECK_CAST_JUMBO.S */
     /*
-     * Check to see if a cast from one class to another is allowed.
+     * Continuation if the String has not yet been resolved.
+     *  r1: BBBB (String ref)
+     *  r9: target register
      */
-    /* check-cast/jumbo vBBBB, class@AAAAAAAA */
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r3, 3)                        @ r3<- BBBB
-    orr     r2, r0, r2, lsl #16         @ r2<- AAAAaaaa
-    GET_VREG(r9, r3)                    @ r9<- object
-    ldr     r0, [rSELF, #offThread_methodClassDex]    @ r0<- pDvmDex
-    cmp     r9, #0                      @ is object null?
-    ldr     r0, [r0, #offDvmDex_pResClasses]    @ r0<- pDvmDex->pResClasses
-    beq     .LOP_CHECK_CAST_JUMBO_okay            @ null obj, cast always succeeds
-    ldr     r1, [r0, r2, lsl #2]        @ r1<- resolved class
-    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz
-    cmp     r1, #0                      @ have we resolved this before?
-    beq     .LOP_CHECK_CAST_JUMBO_resolve         @ not resolved, do it now
-.LOP_CHECK_CAST_JUMBO_resolved:
-    cmp     r0, r1                      @ same class (trivial success)?
-    bne     .LOP_CHECK_CAST_JUMBO_fullcheck       @ no, do full check
-    b       .LOP_CHECK_CAST_JUMBO_okay            @ yes, finish up
+.LOP_CONST_STRING_resolve:
+    EXPORT_PC()
+    ldr     r0, [rSELF, #offThread_method] @ r0<- self->method
+    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveString            @ r0<- String reference
+    cmp     r0, #0                      @ failed?
+    beq     common_exceptionThrown      @ yup, handle the exception
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r9)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_CONST_STRING_JUMBO */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_INSTANCE_OF_JUMBO: /* 0x102 */
-/* File: armv5te/OP_INSTANCE_OF_JUMBO.S */
     /*
-     * Check to see if an object reference is an instance of a class.
-     *
-     * Most common situation is a non-null object, being compared against
-     * an already-resolved class.
-     *
-     * TODO: convert most of this into a common subroutine, shared with
-     *       OP_INSTANCE_OF.S.
+     * Continuation if the String has not yet been resolved.
+     *  r1: BBBBBBBB (String ref)
+     *  r9: target register
      */
-    /* instance-of/jumbo vBBBB, vCCCC, class@AAAAAAAA */
-    FETCH(r3, 4)                        @ r3<- vCCCC
-    FETCH(r9, 3)                        @ r9<- vBBBB
-    GET_VREG(r0, r3)                    @ r0<- vCCCC (object)
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- pDvmDex
-    cmp     r0, #0                      @ is object null?
-    beq     .LOP_INSTANCE_OF_JUMBO_store           @ null obj, not an instance, store r0
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r3, 2)                        @ r3<- AAAA (hi)
-    ldr     r2, [r2, #offDvmDex_pResClasses]    @ r2<- pDvmDex->pResClasses
-    orr     r3, r1, r3, lsl #16         @ r3<- AAAAaaaa
-    ldr     r1, [r2, r3, lsl #2]        @ r1<- resolved class
-    ldr     r0, [r0, #offObject_clazz]  @ r0<- obj->clazz
-    cmp     r1, #0                      @ have we resolved this before?
-    beq     .LOP_INSTANCE_OF_JUMBO_resolve         @ not resolved, do it now
-    b       .LOP_INSTANCE_OF_JUMBO_resolved        @ resolved, continue
+.LOP_CONST_STRING_JUMBO_resolve:
+    EXPORT_PC()
+    ldr     r0, [rSELF, #offThread_method] @ r0<- self->method
+    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveString            @ r0<- String reference
+    cmp     r0, #0                      @ failed?
+    beq     common_exceptionThrown      @ yup, handle the exception
+    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r9)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_CONST_CLASS */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_NEW_INSTANCE_JUMBO: /* 0x103 */
-/* File: armv5te/OP_NEW_INSTANCE_JUMBO.S */
     /*
-     * Create a new instance of a class.
+     * Continuation if the Class has not yet been resolved.
+     *  r1: BBBB (Class ref)
+     *  r9: target register
      */
-    /* new-instance/jumbo vBBBB, class@AAAAAAAA */
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- pDvmDex
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r3, [r3, #offDvmDex_pResClasses]    @ r3<- pDvmDex->pResClasses
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved class
-#if defined(WITH_JIT)
-    add     r10, r3, r1, lsl #2         @ r10<- &resolved_class
-#endif
-    EXPORT_PC()                         @ req'd for init, resolve, alloc
-    cmp     r0, #0                      @ already resolved?
-    beq     .LOP_NEW_INSTANCE_JUMBO_resolve         @ no, resolve it now
-.LOP_NEW_INSTANCE_JUMBO_resolved:   @ r0=class
-    ldrb    r1, [r0, #offClassObject_status]    @ r1<- ClassStatus enum
-    cmp     r1, #CLASS_INITIALIZED      @ has class been initialized?
-    bne     .LOP_NEW_INSTANCE_JUMBO_needinit        @ no, init class now
-.LOP_NEW_INSTANCE_JUMBO_initialized: @ r0=class
-    mov     r1, #ALLOC_DONT_TRACK       @ flags for alloc call
-    bl      dvmAllocObject              @ r0<- new object
-    b       .LOP_NEW_INSTANCE_JUMBO_finish          @ continue
+.LOP_CONST_CLASS_resolve:
+    EXPORT_PC()
+    ldr     r0, [rSELF, #offThread_method] @ r0<- self->method
+    mov     r2, #1                      @ r2<- true
+    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveClass             @ r0<- Class reference
+    cmp     r0, #0                      @ failed?
+    beq     common_exceptionThrown      @ yup, handle the exception
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r9)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_CHECK_CAST */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_NEW_ARRAY_JUMBO: /* 0x104 */
-/* File: armv5te/OP_NEW_ARRAY_JUMBO.S */
     /*
-     * Allocate an array of objects, specified with the array class
-     * and a count.
-     *
-     * The verifier guarantees that this is an array class, so we don't
-     * check for it here.
+     * Trivial test failed, need to perform full check.  This is common.
+     *  r0 holds obj->clazz
+     *  r1 holds desired class resolved from BBBB
+     *  r9 holds object
      */
-    /* new-array/jumbo vBBBB, vCCCC, class@AAAAAAAA */
-    FETCH(r2, 1)                        @ r2<- aaaa (lo)
-    FETCH(r3, 2)                        @ r3<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- vCCCC
-    orr     r2, r2, r3, lsl #16         @ r2<- AAAAaaaa
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- pDvmDex
-    GET_VREG(r1, r0)                    @ r1<- vCCCC (array length)
-    ldr     r3, [r3, #offDvmDex_pResClasses]    @ r3<- pDvmDex->pResClasses
-    cmp     r1, #0                      @ check length
-    ldr     r0, [r3, r2, lsl #2]        @ r0<- resolved class
-    bmi     common_errNegativeArraySize @ negative length, bail - len in r1
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ req'd for resolve, alloc
-    bne     .LOP_NEW_ARRAY_JUMBO_finish          @ resolved, continue
-    b       .LOP_NEW_ARRAY_JUMBO_resolve         @ do resolve now
+.LOP_CHECK_CAST_fullcheck:
+    mov     r10, r1                     @ avoid ClassObject getting clobbered
+    bl      dvmInstanceofNonTrivial     @ r0<- boolean result
+    cmp     r0, #0                      @ failed?
+    bne     .LOP_CHECK_CAST_okay            @ no, success
+
+    @ A cast has failed.  We need to throw a ClassCastException.
+    EXPORT_PC()                         @ about to throw
+    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz (actual class)
+    mov     r1, r10                     @ r1<- desired class
+    bl      dvmThrowClassCastException
+    b       common_exceptionThrown
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_FILLED_NEW_ARRAY_JUMBO: /* 0x105 */
-/* File: armv5te/OP_FILLED_NEW_ARRAY_JUMBO.S */
     /*
-     * Create a new array with elements filled from registers.
+     * Resolution required.  This is the least-likely path.
      *
-     * TODO: convert most of this into a common subroutine, shared with
-     *       OP_FILLED_NEW_ARRAY.S.
+     *  r2 holds BBBB
+     *  r9 holds object
      */
-    /* filled-new-array/jumbo {vCCCC..v(CCCC+BBBB-1)}, type@AAAAAAAA */
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r3, [r3, #offDvmDex_pResClasses]    @ r3<- pDvmDex->pResClasses
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved class
-    EXPORT_PC()                         @ need for resolve and alloc
-    cmp     r0, #0                      @ already resolved?
-    bne     .LOP_FILLED_NEW_ARRAY_JUMBO_continue        @ yes, continue on
-8:  ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
+.LOP_CHECK_CAST_resolve:
+    EXPORT_PC()                         @ resolve() could throw
+    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
+    mov     r1, r2                      @ r1<- BBBB
     mov     r2, #0                      @ r2<- false
     ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- call(clazz, ref)
+    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
     cmp     r0, #0                      @ got null?
     beq     common_exceptionThrown      @ yes, handle exception
-    b       .LOP_FILLED_NEW_ARRAY_JUMBO_continue
+    mov     r1, r0                      @ r1<- class resolved from BBB
+    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz
+    b       .LOP_CHECK_CAST_resolved        @ pick up where we left off
+
+/* continuation for OP_INSTANCE_OF */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_JUMBO: /* 0x106 */
-/* File: armv5te/OP_IGET_JUMBO.S */
     /*
-     * Jumbo 32-bit instance field get.
-     *
-     * for: iget/jumbo, iget-object/jumbo, iget-boolean/jumbo, iget-byte/jumbo,
-     *      iget-char/jumbo, iget-short/jumbo
+     * Trivial test failed, need to perform full check.  This is common.
+     *  r0 holds obj->clazz
+     *  r1 holds class resolved from BBBB
+     *  r9 holds A
      */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_JUMBO_resolved        @ resolved, continue
+.LOP_INSTANCE_OF_fullcheck:
+    bl      dvmInstanceofNonTrivial     @ r0<- boolean result
+    @ fall through to OP_INSTANCE_OF_store
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_WIDE_JUMBO: /* 0x107 */
-/* File: armv5te/OP_IGET_WIDE_JUMBO.S */
     /*
-     * Jumbo 64-bit instance field get.
+     * r0 holds boolean result
+     * r9 holds A
      */
-    /* iget-wide/jumbo vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_WIDE_JUMBO_finish          @ no, already resolved
-    ldr     r2, [rSELF, #offThread_method] @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_WIDE_JUMBO_resolved        @ resolved, continue
+.LOP_INSTANCE_OF_store:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    SET_VREG(r0, r9)                    @ vA<- r0
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_OBJECT_JUMBO: /* 0x108 */
-/* File: armv5te/OP_IGET_OBJECT_JUMBO.S */
-/* File: armv5te/OP_IGET_JUMBO.S */
     /*
-     * Jumbo 32-bit instance field get.
-     *
-     * for: iget/jumbo, iget-object/jumbo, iget-boolean/jumbo, iget-byte/jumbo,
-     *      iget-char/jumbo, iget-short/jumbo
+     * Trivial test succeeded, save and bail.
+     *  r9 holds A
      */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_OBJECT_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_OBJECT_JUMBO_resolved        @ resolved, continue
-
+.LOP_INSTANCE_OF_trivial:
+    mov     r0, #1                      @ indicate success
+    @ could b OP_INSTANCE_OF_store, but copying is faster and cheaper
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    SET_VREG(r0, r9)                    @ vA<- r0
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_BOOLEAN_JUMBO: /* 0x109 */
-/* File: armv5te/OP_IGET_BOOLEAN_JUMBO.S */
-@include "armv5te/OP_IGET_JUMBO.S" { "load":"ldrb", "sqnum":"1" }
-/* File: armv5te/OP_IGET_JUMBO.S */
     /*
-     * Jumbo 32-bit instance field get.
+     * Resolution required.  This is the least-likely path.
      *
-     * for: iget/jumbo, iget-object/jumbo, iget-boolean/jumbo, iget-byte/jumbo,
-     *      iget-char/jumbo, iget-short/jumbo
+     *  r3 holds BBBB
+     *  r9 holds A
      */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_BOOLEAN_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+.LOP_INSTANCE_OF_resolve:
     EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_BOOLEAN_JUMBO_resolved        @ resolved, continue
+    ldr     r0, [rSELF, #offThread_method]    @ r0<- self->method
+    mov     r1, r3                      @ r1<- BBBB
+    mov     r2, #1                      @ r2<- true
+    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
+    cmp     r0, #0                      @ got null?
+    beq     common_exceptionThrown      @ yes, handle exception
+    mov     r1, r0                      @ r1<- class resolved from BBB
+    mov     r3, rINST, lsr #12          @ r3<- B
+    GET_VREG(r0, r3)                    @ r0<- vB (object)
+    ldr     r0, [r0, #offObject_clazz]  @ r0<- obj->clazz
+    b       .LOP_INSTANCE_OF_resolved        @ pick up where we left off
 
+/* continuation for OP_NEW_INSTANCE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_BYTE_JUMBO: /* 0x10a */
-/* File: armv5te/OP_IGET_BYTE_JUMBO.S */
-@include "armv5te/OP_IGET_JUMBO.S" { "load":"ldrsb", "sqnum":"2" }
-/* File: armv5te/OP_IGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit instance field get.
-     *
-     * for: iget/jumbo, iget-object/jumbo, iget-boolean/jumbo, iget-byte/jumbo,
-     *      iget-char/jumbo, iget-short/jumbo
-     */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_BYTE_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_BYTE_JUMBO_resolved        @ resolved, continue
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_CHAR_JUMBO: /* 0x10b */
-/* File: armv5te/OP_IGET_CHAR_JUMBO.S */
-@include "armv5te/OP_IGET_JUMBO.S" { "load":"ldrh", "sqnum":"3" }
-/* File: armv5te/OP_IGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit instance field get.
-     *
-     * for: iget/jumbo, iget-object/jumbo, iget-boolean/jumbo, iget-byte/jumbo,
-     *      iget-char/jumbo, iget-short/jumbo
-     */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_CHAR_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_CHAR_JUMBO_resolved        @ resolved, continue
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_SHORT_JUMBO: /* 0x10c */
-/* File: armv5te/OP_IGET_SHORT_JUMBO.S */
-@include "armv5te/OP_IGET_JUMBO.S" { "load":"ldrsh", "sqnum":"4" }
-/* File: armv5te/OP_IGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit instance field get.
-     *
-     * for: iget/jumbo, iget-object/jumbo, iget-boolean/jumbo, iget-byte/jumbo,
-     *      iget-char/jumbo, iget-short/jumbo
-     */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_SHORT_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_SHORT_JUMBO_resolved        @ resolved, continue
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_JUMBO: /* 0x10d */
-/* File: armv5te/OP_IPUT_JUMBO.S */
+    .balign 32                          @ minimize cache lines
+.LOP_NEW_INSTANCE_finish: @ r0=new object
+    mov     r3, rINST, lsr #8           @ r3<- AA
+    cmp     r0, #0                      @ failed?
+#if defined(WITH_JIT)
     /*
-     * Jumbo 32-bit instance field put.
-     *
-     * for: iput/jumbo, iput-boolean/jumbo, iput-byte/jumbo, iput-char/jumbo,
-     *      iput-short/jumbo
+     * The JIT needs the class to be fully resolved before it can
+     * include this instruction in a trace.
      */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_JUMBO_resolved        @ resolved, continue
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_WIDE_JUMBO: /* 0x10e */
-/* File: armv5te/OP_IPUT_WIDE_JUMBO.S */
-    /* iput-wide/jumbo vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_WIDE_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method] @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_WIDE_JUMBO_resolved        @ resolved, continue
+    ldrh    r1, [rSELF, #offThread_subMode]
+    beq     common_exceptionThrown      @ yes, handle the exception
+    ands    r1, #kSubModeJitTraceBuild  @ under construction?
+    bne     .LOP_NEW_INSTANCE_jitCheck
+#else
+    beq     common_exceptionThrown      @ yes, handle the exception
+#endif
+.LOP_NEW_INSTANCE_end:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r3)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_OBJECT_JUMBO: /* 0x10f */
-/* File: armv5te/OP_IPUT_OBJECT_JUMBO.S */
+#if defined(WITH_JIT)
     /*
-     * Jumbo 32-bit instance field put.
+     * Check to see if we need to stop the trace building early.
+     * r0: new object
+     * r3: vAA
      */
-    /* iput-object/jumbo vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_OBJECT_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_OBJECT_JUMBO_resolved        @ resolved, continue
+.LOP_NEW_INSTANCE_jitCheck:
+    ldr     r1, [r10]                   @ reload resolved class
+    cmp     r1, #0                      @ okay?
+    bne     .LOP_NEW_INSTANCE_end             @ yes, finish
+    mov     r9, r0                      @ preserve new object
+    mov     r10, r3                     @ preserve vAA
+    mov     r0, rSELF
+    mov     r1, rPC
+    bl      dvmJitEndTraceSelect        @ (self, pc)
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r9, r10)                   @ vAA<- new object
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#endif
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_BOOLEAN_JUMBO: /* 0x110 */
-/* File: armv5te/OP_IPUT_BOOLEAN_JUMBO.S */
-@include "armv5te/OP_IPUT_JUMBO.S" { "store":"strb", "sqnum":"1" }
-/* File: armv5te/OP_IPUT_JUMBO.S */
     /*
-     * Jumbo 32-bit instance field put.
+     * Class initialization required.
      *
-     * for: iput/jumbo, iput-boolean/jumbo, iput-byte/jumbo, iput-char/jumbo,
-     *      iput-short/jumbo
+     *  r0 holds class object
      */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_BOOLEAN_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_BOOLEAN_JUMBO_resolved        @ resolved, continue
-
+.LOP_NEW_INSTANCE_needinit:
+    mov     r9, r0                      @ save r0
+    bl      dvmInitClass                @ initialize class
+    cmp     r0, #0                      @ check boolean result
+    mov     r0, r9                      @ restore r0
+    bne     .LOP_NEW_INSTANCE_initialized     @ success, continue
+    b       common_exceptionThrown      @ failed, deal with init exception
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_BYTE_JUMBO: /* 0x111 */
-/* File: armv5te/OP_IPUT_BYTE_JUMBO.S */
-@include "armv5te/OP_IPUT_JUMBO.S" { "store":"strb", "sqnum":"2" }
-/* File: armv5te/OP_IPUT_JUMBO.S */
     /*
-     * Jumbo 32-bit instance field put.
+     * Resolution required.  This is the least-likely path.
      *
-     * for: iput/jumbo, iput-boolean/jumbo, iput-byte/jumbo, iput-char/jumbo,
-     *      iput-short/jumbo
+     *  r1 holds BBBB
      */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_BYTE_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_BYTE_JUMBO_resolved        @ resolved, continue
-
+.LOP_NEW_INSTANCE_resolve:
+    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
+    mov     r2, #0                      @ r2<- false
+    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
+    cmp     r0, #0                      @ got null?
+    bne     .LOP_NEW_INSTANCE_resolved        @ no, continue
+    b       common_exceptionThrown      @ yes, handle exception
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_CHAR_JUMBO: /* 0x112 */
-/* File: armv5te/OP_IPUT_CHAR_JUMBO.S */
-@include "armv5te/OP_IPUT_JUMBO.S" { "store":"strh", "sqnum":"3" }
-/* File: armv5te/OP_IPUT_JUMBO.S */
-    /*
-     * Jumbo 32-bit instance field put.
-     *
-     * for: iput/jumbo, iput-boolean/jumbo, iput-byte/jumbo, iput-char/jumbo,
-     *      iput-short/jumbo
-     */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_CHAR_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_CHAR_JUMBO_resolved        @ resolved, continue
+/* continuation for OP_NEW_ARRAY */
 
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_SHORT_JUMBO: /* 0x113 */
-/* File: armv5te/OP_IPUT_SHORT_JUMBO.S */
-@include "armv5te/OP_IPUT_JUMBO.S" { "store":"strh", "sqnum":"4" }
-/* File: armv5te/OP_IPUT_JUMBO.S */
     /*
-     * Jumbo 32-bit instance field put.
+     * Resolve class.  (This is an uncommon case.)
      *
-     * for: iput/jumbo, iput-boolean/jumbo, iput-byte/jumbo, iput-char/jumbo,
-     *      iput-short/jumbo
+     *  r1 holds array length
+     *  r2 holds class ref CCCC
      */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_SHORT_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_SHORT_JUMBO_resolved        @ resolved, continue
-
+.LOP_NEW_ARRAY_resolve:
+    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
+    mov     r9, r1                      @ r9<- length (save)
+    mov     r1, r2                      @ r1<- CCCC
+    mov     r2, #0                      @ r2<- false
+    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveClass             @ r0<- call(clazz, ref)
+    cmp     r0, #0                      @ got null?
+    mov     r1, r9                      @ r1<- length (restore)
+    beq     common_exceptionThrown      @ yes, handle exception
+    @ fall through to OP_NEW_ARRAY_finish
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_JUMBO: /* 0x114 */
-/* File: armv5te/OP_SGET_JUMBO.S */
     /*
-     * Jumbo 32-bit SGET handler.
+     * Finish allocation.
      *
-     * for: sget/jumbo, sget-object/jumbo, sget-boolean/jumbo, sget-byte/jumbo,
-     *      sget-char/jumbo, sget-short/jumbo
+     *  r0 holds class
+     *  r1 holds array length
      */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_JUMBO_finish: @ field ptr in r0
-    ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    SET_VREG(r1, r2)                    @ fp[BBBB]<- r1
+.LOP_NEW_ARRAY_finish:
+    mov     r2, #ALLOC_DONT_TRACK       @ don't track in local refs table
+    bl      dvmAllocArrayByClass        @ r0<- call(clazz, length, flags)
+    cmp     r0, #0                      @ failed?
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    beq     common_exceptionThrown      @ yes, handle the exception
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ vA<- r0
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_WIDE_JUMBO: /* 0x115 */
-/* File: armv5te/OP_SGET_WIDE_JUMBO.S */
+/* continuation for OP_FILLED_NEW_ARRAY */
+
     /*
-     * Jumbo 64-bit SGET handler.
+     * On entry:
+     *  r0 holds array class
+     *  r10 holds AA or BA
      */
-    /* sget-wide/jumbo vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r2, [r2, #offDvmDex_pResFields] @ r2<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_WIDE_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_WIDE_JUMBO_finish:
-    FETCH(r9, 3)                        @ r9<- BBBB
-    .if 0
-    add     r0, r0, #offStaticField_value @ r0<- pointer to data
-    bl      dvmQuasiAtomicRead64        @ r0/r1<- contents of field
+.LOP_FILLED_NEW_ARRAY_continue:
+    ldr     r3, [r0, #offClassObject_descriptor] @ r3<- arrayClass->descriptor
+    mov     r2, #ALLOC_DONT_TRACK       @ r2<- alloc flags
+    ldrb    rINST, [r3, #1]             @ rINST<- descriptor[1]
+    .if     0
+    mov     r1, r10                     @ r1<- AA (length)
     .else
-    ldrd    r0, [r0, #offStaticField_value] @ r0/r1<- field value (aligned)
+    mov     r1, r10, lsr #4             @ r1<- B (length)
     .endif
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[BBBB]
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    stmia   r9, {r0-r1}                 @ vBBBB/vBBBB+1<- r0/r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_OBJECT_JUMBO: /* 0x116 */
-/* File: armv5te/OP_SGET_OBJECT_JUMBO.S */
-/* File: armv5te/OP_SGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit SGET handler.
-     *
-     * for: sget/jumbo, sget-object/jumbo, sget-boolean/jumbo, sget-byte/jumbo,
-     *      sget-char/jumbo, sget-short/jumbo
-     */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_OBJECT_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_OBJECT_JUMBO_finish: @ field ptr in r0
-    ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    SET_VREG(r1, r2)                    @ fp[BBBB]<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+    cmp     rINST, #'I'                 @ array of ints?
+    cmpne   rINST, #'L'                 @ array of objects?
+    cmpne   rINST, #'['                 @ array of arrays?
+    mov     r9, r1                      @ save length in r9
+    bne     .LOP_FILLED_NEW_ARRAY_notimpl         @ no, not handled yet
+    bl      dvmAllocArrayByClass        @ r0<- call(arClass, length, flags)
+    cmp     r0, #0                      @ null return?
+    beq     common_exceptionThrown      @ alloc failed, handle exception
 
+    FETCH(r1, 2)                        @ r1<- FEDC or CCCC
+    str     r0, [rSELF, #offThread_retval]      @ retval.l <- new array
+    str     rINST, [rSELF, #offThread_retval+4] @ retval.h <- type
+    add     r0, r0, #offArrayObject_contents @ r0<- newArray->contents
+    subs    r9, r9, #1                  @ length--, check for neg
+    FETCH_ADVANCE_INST(3)               @ advance to next instr, load rINST
+    bmi     2f                          @ was zero, bail
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_BOOLEAN_JUMBO: /* 0x117 */
-/* File: armv5te/OP_SGET_BOOLEAN_JUMBO.S */
-/* File: armv5te/OP_SGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit SGET handler.
-     *
-     * for: sget/jumbo, sget-object/jumbo, sget-boolean/jumbo, sget-byte/jumbo,
-     *      sget-char/jumbo, sget-short/jumbo
-     */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_BOOLEAN_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_BOOLEAN_JUMBO_finish: @ field ptr in r0
-    ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    SET_VREG(r1, r2)                    @ fp[BBBB]<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+    @ copy values from registers into the array
+    @ r0=array, r1=CCCC/FEDC, r9=length (from AA or B), r10=AA/BA
+    .if     0
+    add     r2, rFP, r1, lsl #2         @ r2<- &fp[CCCC]
+1:  ldr     r3, [r2], #4                @ r3<- *r2++
+    subs    r9, r9, #1                  @ count--
+    str     r3, [r0], #4                @ *contents++ = vX
+    bpl     1b
+    @ continue at 2
+    .else
+    cmp     r9, #4                      @ length was initially 5?
+    and     r2, r10, #15                @ r2<- A
+    bne     1f                          @ <= 4 args, branch
+    GET_VREG(r3, r2)                    @ r3<- vA
+    sub     r9, r9, #1                  @ count--
+    str     r3, [r0, #16]               @ contents[4] = vA
+1:  and     r2, r1, #15                 @ r2<- F/E/D/C
+    GET_VREG(r3, r2)                    @ r3<- vF/vE/vD/vC
+    mov     r1, r1, lsr #4              @ r1<- next reg in low 4
+    subs    r9, r9, #1                  @ count--
+    str     r3, [r0], #4                @ *contents++ = vX
+    bpl     1b
+    @ continue at 2
+    .endif
 
+2:
+    ldr     r0, [rSELF, #offThread_retval]     @ r0<- object
+    ldr     r1, [rSELF, #offThread_retval+4]   @ r1<- type
+    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
+    GET_INST_OPCODE(ip)                      @ ip<- opcode from rINST
+    cmp     r1, #'I'                         @ Is int array?
+    strneb  r2, [r2, r0, lsr #GC_CARD_SHIFT] @ Mark card based on object head
+    GOTO_OPCODE(ip)                          @ execute it
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_BYTE_JUMBO: /* 0x118 */
-/* File: armv5te/OP_SGET_BYTE_JUMBO.S */
-/* File: armv5te/OP_SGET_JUMBO.S */
     /*
-     * Jumbo 32-bit SGET handler.
-     *
-     * for: sget/jumbo, sget-object/jumbo, sget-boolean/jumbo, sget-byte/jumbo,
-     *      sget-char/jumbo, sget-short/jumbo
+     * Throw an exception indicating that we have not implemented this
+     * mode of filled-new-array.
      */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_BYTE_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_BYTE_JUMBO_finish: @ field ptr in r0
-    ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    SET_VREG(r1, r2)                    @ fp[BBBB]<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
+.LOP_FILLED_NEW_ARRAY_notimpl:
+    ldr     r0, .L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY
+    bl      dvmThrowInternalError
+    b       common_exceptionThrown
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_CHAR_JUMBO: /* 0x119 */
-/* File: armv5te/OP_SGET_CHAR_JUMBO.S */
-/* File: armv5te/OP_SGET_JUMBO.S */
     /*
-     * Jumbo 32-bit SGET handler.
-     *
-     * for: sget/jumbo, sget-object/jumbo, sget-boolean/jumbo, sget-byte/jumbo,
-     *      sget-char/jumbo, sget-short/jumbo
+     * Ideally we'd only define this once, but depending on layout we can
+     * exceed the range of the load above.
      */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_CHAR_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_CHAR_JUMBO_finish: @ field ptr in r0
-    ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    SET_VREG(r1, r2)                    @ fp[BBBB]<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY:
+    .word   .LstrFilledNewArrayNotImpl
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_SHORT_JUMBO: /* 0x11a */
-/* File: armv5te/OP_SGET_SHORT_JUMBO.S */
-/* File: armv5te/OP_SGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit SGET handler.
-     *
-     * for: sget/jumbo, sget-object/jumbo, sget-boolean/jumbo, sget-byte/jumbo,
-     *      sget-char/jumbo, sget-short/jumbo
-     */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_SHORT_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_SHORT_JUMBO_finish: @ field ptr in r0
-    ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    SET_VREG(r1, r2)                    @ fp[BBBB]<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
+/* continuation for OP_FILLED_NEW_ARRAY_RANGE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_JUMBO: /* 0x11b */
-/* File: armv5te/OP_SPUT_JUMBO.S */
     /*
-     * Jumbo 32-bit SPUT handler.
-     *
-     * for: sput/jumbo, sput-boolean/jumbo, sput-byte/jumbo, sput-char/jumbo,
-     *      sput-short/jumbo
+     * On entry:
+     *  r0 holds array class
+     *  r10 holds AA or BA
      */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]        @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_JUMBO_finish:   @ field ptr in r0
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_VREG(r1, r2)                    @ r1<- fp[BBBB]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                        @ releasing store
-    str     r1, [r0, #offStaticField_value] @ field<- vBBBB
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+.LOP_FILLED_NEW_ARRAY_RANGE_continue:
+    ldr     r3, [r0, #offClassObject_descriptor] @ r3<- arrayClass->descriptor
+    mov     r2, #ALLOC_DONT_TRACK       @ r2<- alloc flags
+    ldrb    rINST, [r3, #1]             @ rINST<- descriptor[1]
+    .if     1
+    mov     r1, r10                     @ r1<- AA (length)
+    .else
+    mov     r1, r10, lsr #4             @ r1<- B (length)
+    .endif
+    cmp     rINST, #'I'                 @ array of ints?
+    cmpne   rINST, #'L'                 @ array of objects?
+    cmpne   rINST, #'['                 @ array of arrays?
+    mov     r9, r1                      @ save length in r9
+    bne     .LOP_FILLED_NEW_ARRAY_RANGE_notimpl         @ no, not handled yet
+    bl      dvmAllocArrayByClass        @ r0<- call(arClass, length, flags)
+    cmp     r0, #0                      @ null return?
+    beq     common_exceptionThrown      @ alloc failed, handle exception
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_WIDE_JUMBO: /* 0x11c */
-/* File: armv5te/OP_SPUT_WIDE_JUMBO.S */
-    /*
-     * Jumbo 64-bit SPUT handler.
-     */
-    /* sput-wide/jumbo vBBBB, field@AAAAAAAA */
-    ldr     r0, [rSELF, #offThread_methodClassDex]  @ r0<- DvmDex
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    ldr     r10, [r0, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    FETCH(r9, 3)                        @ r9<- BBBB
-    ldr     r2, [r10, r1, lsl #2]       @ r2<- resolved StaticField ptr
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[BBBB]
-    cmp     r2, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_WIDE_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_WIDE_JUMBO_finish: @ field ptr in r2, BBBB in r9
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vBBBB/vBBBB+1
-    GET_INST_OPCODE(r10)                @ extract opcode from rINST
-    .if 0
-    add     r2, r2, #offStaticField_value @ r2<- pointer to data
-    bl      dvmQuasiAtomicSwap64Sync    @ stores r0/r1 into addr r2
+    FETCH(r1, 2)                        @ r1<- FEDC or CCCC
+    str     r0, [rSELF, #offThread_retval]      @ retval.l <- new array
+    str     rINST, [rSELF, #offThread_retval+4] @ retval.h <- type
+    add     r0, r0, #offArrayObject_contents @ r0<- newArray->contents
+    subs    r9, r9, #1                  @ length--, check for neg
+    FETCH_ADVANCE_INST(3)               @ advance to next instr, load rINST
+    bmi     2f                          @ was zero, bail
+
+    @ copy values from registers into the array
+    @ r0=array, r1=CCCC/FEDC, r9=length (from AA or B), r10=AA/BA
+    .if     1
+    add     r2, rFP, r1, lsl #2         @ r2<- &fp[CCCC]
+1:  ldr     r3, [r2], #4                @ r3<- *r2++
+    subs    r9, r9, #1                  @ count--
+    str     r3, [r0], #4                @ *contents++ = vX
+    bpl     1b
+    @ continue at 2
     .else
-    strd    r0, [r2, #offStaticField_value] @ field<- vBBBB/vBBBB+1
+    cmp     r9, #4                      @ length was initially 5?
+    and     r2, r10, #15                @ r2<- A
+    bne     1f                          @ <= 4 args, branch
+    GET_VREG(r3, r2)                    @ r3<- vA
+    sub     r9, r9, #1                  @ count--
+    str     r3, [r0, #16]               @ contents[4] = vA
+1:  and     r2, r1, #15                 @ r2<- F/E/D/C
+    GET_VREG(r3, r2)                    @ r3<- vF/vE/vD/vC
+    mov     r1, r1, lsr #4              @ r1<- next reg in low 4
+    subs    r9, r9, #1                  @ count--
+    str     r3, [r0], #4                @ *contents++ = vX
+    bpl     1b
+    @ continue at 2
     .endif
-    GOTO_OPCODE(r10)                    @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_OBJECT_JUMBO: /* 0x11d */
-/* File: armv5te/OP_SPUT_OBJECT_JUMBO.S */
-    /*
-     * Jumbo 32-bit SPUT handler for objects
-     */
-    /* sput-object/jumbo vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_OBJECT_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_OBJECT_JUMBO_finish:   @ field ptr in r0
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_VREG(r1, r2)                    @ r1<- fp[BBBB]
+2:
+    ldr     r0, [rSELF, #offThread_retval]     @ r0<- object
+    ldr     r1, [rSELF, #offThread_retval+4]   @ r1<- type
     ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
-    ldr     r9, [r0, #offField_clazz]   @ r9<- field->clazz
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                         @ releasing store
-    b       .LOP_SPUT_OBJECT_JUMBO_end
+    GET_INST_OPCODE(ip)                      @ ip<- opcode from rINST
+    cmp     r1, #'I'                         @ Is int array?
+    strneb  r2, [r2, r0, lsr #GC_CARD_SHIFT] @ Mark card based on object head
+    GOTO_OPCODE(ip)                          @ execute it
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_BOOLEAN_JUMBO: /* 0x11e */
-/* File: armv5te/OP_SPUT_BOOLEAN_JUMBO.S */
-/* File: armv5te/OP_SPUT_JUMBO.S */
     /*
-     * Jumbo 32-bit SPUT handler.
-     *
-     * for: sput/jumbo, sput-boolean/jumbo, sput-byte/jumbo, sput-char/jumbo,
-     *      sput-short/jumbo
+     * Throw an exception indicating that we have not implemented this
+     * mode of filled-new-array.
      */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]        @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_BOOLEAN_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_BOOLEAN_JUMBO_finish:   @ field ptr in r0
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_VREG(r1, r2)                    @ r1<- fp[BBBB]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                        @ releasing store
-    str     r1, [r0, #offStaticField_value] @ field<- vBBBB
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
+.LOP_FILLED_NEW_ARRAY_RANGE_notimpl:
+    ldr     r0, .L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY_RANGE
+    bl      dvmThrowInternalError
+    b       common_exceptionThrown
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_BYTE_JUMBO: /* 0x11f */
-/* File: armv5te/OP_SPUT_BYTE_JUMBO.S */
-/* File: armv5te/OP_SPUT_JUMBO.S */
     /*
-     * Jumbo 32-bit SPUT handler.
-     *
-     * for: sput/jumbo, sput-boolean/jumbo, sput-byte/jumbo, sput-char/jumbo,
-     *      sput-short/jumbo
+     * Ideally we'd only define this once, but depending on layout we can
+     * exceed the range of the load above.
      */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]        @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_BYTE_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_BYTE_JUMBO_finish:   @ field ptr in r0
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_VREG(r1, r2)                    @ r1<- fp[BBBB]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                        @ releasing store
-    str     r1, [r0, #offStaticField_value] @ field<- vBBBB
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY_RANGE:
+    .word   .LstrFilledNewArrayNotImpl
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_CHAR_JUMBO: /* 0x120 */
-/* File: armv5te/OP_SPUT_CHAR_JUMBO.S */
-/* File: armv5te/OP_SPUT_JUMBO.S */
-    /*
-     * Jumbo 32-bit SPUT handler.
-     *
-     * for: sput/jumbo, sput-boolean/jumbo, sput-byte/jumbo, sput-char/jumbo,
-     *      sput-short/jumbo
-     */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]        @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_CHAR_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_CHAR_JUMBO_finish:   @ field ptr in r0
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_VREG(r1, r2)                    @ r1<- fp[BBBB]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                        @ releasing store
-    str     r1, [r0, #offStaticField_value] @ field<- vBBBB
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+/* continuation for OP_CMPL_FLOAT */
 
+    @ Test for NaN with a second comparison.  EABI forbids testing bit
+    @ patterns, and we can't represent 0x7fc00000 in immediate form, so
+    @ make the library call.
+.LOP_CMPL_FLOAT_gt_or_nan:
+    mov     r1, r9                      @ reverse order
+    mov     r0, r10
+    bl      __aeabi_cfcmple             @ r0<- Z set if eq, C clear if <
+    @bleq    common_abort
+    movcc   r1, #1                      @ (greater than) r1<- 1
+    bcc     .LOP_CMPL_FLOAT_finish
+    mvn     r1, #0                            @ r1<- 1 or -1 for NaN
+    b       .LOP_CMPL_FLOAT_finish
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_SHORT_JUMBO: /* 0x121 */
-/* File: armv5te/OP_SPUT_SHORT_JUMBO.S */
-/* File: armv5te/OP_SPUT_JUMBO.S */
-    /*
-     * Jumbo 32-bit SPUT handler.
-     *
-     * for: sput/jumbo, sput-boolean/jumbo, sput-byte/jumbo, sput-char/jumbo,
-     *      sput-short/jumbo
-     */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]        @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_SHORT_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_SHORT_JUMBO_finish:   @ field ptr in r0
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_VREG(r1, r2)                    @ r1<- fp[BBBB]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                        @ releasing store
-    str     r1, [r0, #offStaticField_value] @ field<- vBBBB
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+#if 0       /* "clasic" form */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    and     r2, r0, #255                @ r2<- BB
+    mov     r3, r0, lsr #8              @ r3<- CC
+    GET_VREG(r9, r2)                    @ r9<- vBB
+    GET_VREG(r10, r3)                   @ r10<- vCC
+    mov     r0, r9                      @ r0<- vBB
+    mov     r1, r10                     @ r1<- vCC
+    bl      __aeabi_fcmpeq              @ r0<- (vBB == vCC)
+    cmp     r0, #0                      @ equal?
+    movne   r1, #0                      @ yes, result is 0
+    bne     OP_CMPL_FLOAT_finish
+    mov     r0, r9                      @ r0<- vBB
+    mov     r1, r10                     @ r1<- vCC
+    bl      __aeabi_fcmplt              @ r0<- (vBB < vCC)
+    cmp     r0, #0                      @ less than?
+    b       OP_CMPL_FLOAT_continue
+@%break
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_INVOKE_VIRTUAL_JUMBO: /* 0x122 */
-/* File: armv5te/OP_INVOKE_VIRTUAL_JUMBO.S */
-    /*
-     * Handle a virtual method call.
-     */
-    /* invoke-virtual/jumbo {vCCCC..v(CCCC+BBBB-1)}, meth@AAAAAAAA */
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r0, 1)                        @ r1<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved baseMethod
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    bne     .LOP_INVOKE_VIRTUAL_JUMBO_continue        @ yes, continue on
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_VIRTUAL_JUMBO_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
+OP_CMPL_FLOAT_continue:
+    mvnne   r1, #0                      @ yes, result is -1
+    bne     OP_CMPL_FLOAT_finish
+    mov     r0, r9                      @ r0<- vBB
+    mov     r1, r10                     @ r1<- vCC
+    bl      __aeabi_fcmpgt              @ r0<- (vBB > vCC)
+    cmp     r0, #0                      @ greater than?
+    beq     OP_CMPL_FLOAT_nan               @ no, must be NaN
+    mov     r1, #1                      @ yes, result is 1
+    @ fall through to _finish
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_INVOKE_SUPER_JUMBO: /* 0x123 */
-/* File: armv5te/OP_INVOKE_SUPER_JUMBO.S */
-    /*
-     * Handle a "super" method call.
-     */
-    /* invoke-super/jumbo {vCCCC..v(CCCC+BBBB-1)}, meth@AAAAAAAA */
-    FETCH(r10, 4)                       @ r10<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r0, 1)                        @ r1<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    GET_VREG(r9, r10)                   @ r9<- "this" ptr
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved baseMethod
-    cmp     r9, #0                      @ null "this"?
-    ldr     r10, [rSELF, #offThread_method] @ r10<- current method
-    beq     common_errNullObject        @ null "this", throw exception
-    cmp     r0, #0                      @ already resolved?
-    ldr     r10, [r10, #offMethod_clazz]  @ r10<- method->clazz
-    EXPORT_PC()                         @ must export for invoke
-    bne     .LOP_INVOKE_SUPER_JUMBO_continue        @ resolved, continue on
-    b       .LOP_INVOKE_SUPER_JUMBO_resolve         @ do resolve now
+OP_CMPL_FLOAT_finish:
+    mov     r3, rINST, lsr #8           @ r3<- AA
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    SET_VREG(r1, r3)                    @ vAA<- r1
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_INVOKE_DIRECT_JUMBO: /* 0x124 */
-/* File: armv5te/OP_INVOKE_DIRECT_JUMBO.S */
     /*
-     * Handle a direct method call.
-     *
-     * (We could defer the "is 'this' pointer null" test to the common
-     * method invocation code, and use a flag to indicate that static
-     * calls don't count.  If we do this as part of copying the arguments
-     * out we could avoiding loading the first arg twice.)
-     *
+     * This is expected to be uncommon, so we double-branch (once to here,
+     * again back to _finish).
      */
-    /* invoke-direct/jumbo {vCCCC..v(CCCC+BBBB-1)}, meth@AAAAAAAA */
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r0, 1)                        @ r1<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    FETCH(r10, 4)                       @ r10<- CCCC
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved methodToCall
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    GET_VREG(r9, r10)                   @ r9<- "this" ptr
-    beq     .LOP_INVOKE_DIRECT_JUMBO_resolve         @ not resolved, do it now
-.LOP_INVOKE_DIRECT_JUMBO_finish:
-    cmp     r9, #0                      @ null "this" ref?
-    bne     common_invokeMethodJumbo    @ (r0=method, r9="this")
-    b       common_errNullObject        @ yes, throw exception
+OP_CMPL_FLOAT_nan:
+    mvn     r1, #0                            @ r1<- 1 or -1 for NaN
+    b       OP_CMPL_FLOAT_finish
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_INVOKE_STATIC_JUMBO: /* 0x125 */
-/* File: armv5te/OP_INVOKE_STATIC_JUMBO.S */
-    /*
-     * Handle a static method call.
-     */
-    /* invoke-static/jumbo {vCCCC..v(CCCC+BBBB-1)}, meth@AAAAAAAA */
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r0, 1)                        @ r1<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved methodToCall
-#if defined(WITH_JIT)
-    add     r10, r3, r1, lsl #2         @ r10<- &resolved_methodToCall
 #endif
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    bne     common_invokeMethodJumboNoThis   @ (r0=method)
-    b       .LOP_INVOKE_STATIC_JUMBO_resolve
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_INVOKE_INTERFACE_JUMBO: /* 0x126 */
-/* File: armv5te/OP_INVOKE_INTERFACE_JUMBO.S */
-    /*
-     * Handle an interface method call.
-     */
-    /* invoke-interface/jumbo {vCCCC..v(CCCC+BBBB-1)}, meth@AAAAAAAA */
-    FETCH(r2, 4)                        @ r2<- CCCC
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    EXPORT_PC()                         @ must export for invoke
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    GET_VREG(r9, r2)                    @ r9<- first arg ("this")
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- methodClassDex
-    cmp     r9, #0                      @ null obj?
-    ldr     r2, [rSELF, #offThread_method]  @ r2<- method
-    beq     common_errNullObject        @ yes, fail
-    ldr     r0, [r9, #offObject_clazz]  @ r0<- thisPtr->clazz
-    bl      dvmFindInterfaceMethodInCache @ r0<- call(class, ref, method, dex)
-    cmp     r0, #0                      @ failed?
-    beq     common_exceptionThrown      @ yes, handle exception
-    b       common_invokeMethodJumbo    @ (r0=method, r9="this")
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_27FF: /* 0x127 */
-/* File: armv5te/OP_UNUSED_27FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_28FF: /* 0x128 */
-/* File: armv5te/OP_UNUSED_28FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
 
+/* continuation for OP_CMPG_FLOAT */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_29FF: /* 0x129 */
-/* File: armv5te/OP_UNUSED_29FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    @ Test for NaN with a second comparison.  EABI forbids testing bit
+    @ patterns, and we can't represent 0x7fc00000 in immediate form, so
+    @ make the library call.
+.LOP_CMPG_FLOAT_gt_or_nan:
+    mov     r1, r9                      @ reverse order
+    mov     r0, r10
+    bl      __aeabi_cfcmple             @ r0<- Z set if eq, C clear if <
+    @bleq    common_abort
+    movcc   r1, #1                      @ (greater than) r1<- 1
+    bcc     .LOP_CMPG_FLOAT_finish
+    mov     r1, #1                            @ r1<- 1 or -1 for NaN
+    b       .LOP_CMPG_FLOAT_finish
 
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_2AFF: /* 0x12a */
-/* File: armv5te/OP_UNUSED_2AFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+#if 0       /* "clasic" form */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    and     r2, r0, #255                @ r2<- BB
+    mov     r3, r0, lsr #8              @ r3<- CC
+    GET_VREG(r9, r2)                    @ r9<- vBB
+    GET_VREG(r10, r3)                   @ r10<- vCC
+    mov     r0, r9                      @ r0<- vBB
+    mov     r1, r10                     @ r1<- vCC
+    bl      __aeabi_fcmpeq              @ r0<- (vBB == vCC)
+    cmp     r0, #0                      @ equal?
+    movne   r1, #0                      @ yes, result is 0
+    bne     OP_CMPG_FLOAT_finish
+    mov     r0, r9                      @ r0<- vBB
+    mov     r1, r10                     @ r1<- vCC
+    bl      __aeabi_fcmplt              @ r0<- (vBB < vCC)
+    cmp     r0, #0                      @ less than?
+    b       OP_CMPG_FLOAT_continue
+@%break
 
+OP_CMPG_FLOAT_continue:
+    mvnne   r1, #0                      @ yes, result is -1
+    bne     OP_CMPG_FLOAT_finish
+    mov     r0, r9                      @ r0<- vBB
+    mov     r1, r10                     @ r1<- vCC
+    bl      __aeabi_fcmpgt              @ r0<- (vBB > vCC)
+    cmp     r0, #0                      @ greater than?
+    beq     OP_CMPG_FLOAT_nan               @ no, must be NaN
+    mov     r1, #1                      @ yes, result is 1
+    @ fall through to _finish
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_2BFF: /* 0x12b */
-/* File: armv5te/OP_UNUSED_2BFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+OP_CMPG_FLOAT_finish:
+    mov     r3, rINST, lsr #8           @ r3<- AA
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    SET_VREG(r1, r3)                    @ vAA<- r1
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+    /*
+     * This is expected to be uncommon, so we double-branch (once to here,
+     * again back to _finish).
+     */
+OP_CMPG_FLOAT_nan:
+    mov     r1, #1                            @ r1<- 1 or -1 for NaN
+    b       OP_CMPG_FLOAT_finish
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_2CFF: /* 0x12c */
-/* File: armv5te/OP_UNUSED_2CFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+#endif
 
+/* continuation for OP_CMPL_DOUBLE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_2DFF: /* 0x12d */
-/* File: armv5te/OP_UNUSED_2DFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    @ Test for NaN with a second comparison.  EABI forbids testing bit
+    @ patterns, and we can't represent 0x7fc00000 in immediate form, so
+    @ make the library call.
+.LOP_CMPL_DOUBLE_gt_or_nan:
+    ldmia   r10, {r0-r1}                @ reverse order
+    ldmia   r9, {r2-r3}
+    bl      __aeabi_cdcmple             @ r0<- Z set if eq, C clear if <
+    @bleq    common_abort
+    movcc   r1, #1                      @ (greater than) r1<- 1
+    bcc     .LOP_CMPL_DOUBLE_finish
+    mvn     r1, #0                            @ r1<- 1 or -1 for NaN
+    b       .LOP_CMPL_DOUBLE_finish
 
+/* continuation for OP_CMPG_DOUBLE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_2EFF: /* 0x12e */
-/* File: armv5te/OP_UNUSED_2EFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_2FFF: /* 0x12f */
-/* File: armv5te/OP_UNUSED_2FFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_30FF: /* 0x130 */
-/* File: armv5te/OP_UNUSED_30FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
+    @ Test for NaN with a second comparison.  EABI forbids testing bit
+    @ patterns, and we can't represent 0x7fc00000 in immediate form, so
+    @ make the library call.
+.LOP_CMPG_DOUBLE_gt_or_nan:
+    ldmia   r10, {r0-r1}                @ reverse order
+    ldmia   r9, {r2-r3}
+    bl      __aeabi_cdcmple             @ r0<- Z set if eq, C clear if <
+    @bleq    common_abort
+    movcc   r1, #1                      @ (greater than) r1<- 1
+    bcc     .LOP_CMPG_DOUBLE_finish
+    mov     r1, #1                            @ r1<- 1 or -1 for NaN
+    b       .LOP_CMPG_DOUBLE_finish
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_31FF: /* 0x131 */
-/* File: armv5te/OP_UNUSED_31FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_CMP_LONG */
 
+.LOP_CMP_LONG_less:
+    mvn     r1, #0                      @ r1<- -1
+    @ Want to cond code the next mov so we can avoid branch, but don't see it;
+    @ instead, we just replicate the tail end.
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    SET_VREG(r1, r9)                    @ vAA<- r1
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_32FF: /* 0x132 */
-/* File: armv5te/OP_UNUSED_32FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+.LOP_CMP_LONG_greater:
+    mov     r1, #1                      @ r1<- 1
+    @ fall through to _finish
 
+.LOP_CMP_LONG_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    SET_VREG(r1, r9)                    @ vAA<- r1
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_33FF: /* 0x133 */
-/* File: armv5te/OP_UNUSED_33FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_AGET_WIDE */
 
+.LOP_AGET_WIDE_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    ldrd    r2, [r0, #offArrayObject_contents]  @ r2/r3<- vBB[vCC]
+    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r9, {r2-r3}                 @ vAA/vAA+1<- r2/r3
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_34FF: /* 0x134 */
-/* File: armv5te/OP_UNUSED_34FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_APUT_WIDE */
 
+.LOP_APUT_WIDE_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    ldmia   r9, {r2-r3}                 @ r2/r3<- vAA/vAA+1
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    strd    r2, [r0, #offArrayObject_contents]  @ r2/r3<- vBB[vCC]
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_35FF: /* 0x135 */
-/* File: armv5te/OP_UNUSED_35FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_APUT_OBJECT */
+    /*
+     * On entry:
+     *  rINST = vBB (arrayObj)
+     *  r9 = vAA (obj)
+     *  r10 = offset into array (vBB + vCC * width)
+     */
+.LOP_APUT_OBJECT_finish:
+    cmp     r9, #0                      @ storing null reference?
+    beq     .LOP_APUT_OBJECT_skip_check      @ yes, skip type checks
+    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz
+    ldr     r1, [rINST, #offObject_clazz]  @ r1<- arrayObj->clazz
+    bl      dvmCanPutArrayElement       @ test object type vs. array type
+    cmp     r0, #0                      @ okay?
+    beq     .LOP_APUT_OBJECT_throw           @ no
+    mov     r1, rINST                   @ r1<- arrayObj
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    ldr     r2, [rSELF, #offThread_cardTable]     @ get biased CT base
+    add     r10, #offArrayObject_contents   @ r0<- pointer to slot
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    str     r9, [r10]                   @ vBB[vCC]<- vAA
+    strb    r2, [r2, r1, lsr #GC_CARD_SHIFT] @ mark card using object head
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+.LOP_APUT_OBJECT_skip_check:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    str     r9, [r10, #offArrayObject_contents] @ vBB[vCC]<- vAA
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+.LOP_APUT_OBJECT_throw:
+    @ The types don't match.  We need to throw an ArrayStoreException.
+    ldr     r0, [r9, #offObject_clazz]
+    ldr     r1, [rINST, #offObject_clazz]
+    EXPORT_PC()
+    bl      dvmThrowArrayStoreExceptionIncompatibleElement
+    b       common_exceptionThrown
 
+/* continuation for OP_IGET */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_36FF: /* 0x136 */
-/* File: armv5te/OP_UNUSED_36FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IGET_finish:
+    @bl      common_squeak0
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+    @ no-op                             @ acquiring load
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IGET_WIDE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_37FF: /* 0x137 */
-/* File: armv5te/OP_UNUSED_37FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IGET_WIDE_finish:
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    .if     0
+    add     r0, r9, r3                  @ r0<- address of field
+    bl      dvmQuasiAtomicRead64        @ r0/r1<- contents of field
+    .else
+    ldrd    r0, [r9, r3]                @ r0/r1<- obj.field (64-bit align ok)
+    .endif
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    add     r3, rFP, r2, lsl #2         @ r3<- &fp[A]
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IGET_OBJECT */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_38FF: /* 0x138 */
-/* File: armv5te/OP_UNUSED_38FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IGET_OBJECT_finish:
+    @bl      common_squeak0
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+    @ no-op                             @ acquiring load
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IGET_BOOLEAN */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_39FF: /* 0x139 */
-/* File: armv5te/OP_UNUSED_39FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IGET_BOOLEAN_finish:
+    @bl      common_squeak1
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+    @ no-op                             @ acquiring load
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IGET_BYTE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_3AFF: /* 0x13a */
-/* File: armv5te/OP_UNUSED_3AFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IGET_BYTE_finish:
+    @bl      common_squeak2
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+    @ no-op                             @ acquiring load
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IGET_CHAR */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_3BFF: /* 0x13b */
-/* File: armv5te/OP_UNUSED_3BFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IGET_CHAR_finish:
+    @bl      common_squeak3
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+    @ no-op                             @ acquiring load
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IGET_SHORT */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_3CFF: /* 0x13c */
-/* File: armv5te/OP_UNUSED_3CFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IGET_SHORT_finish:
+    @bl      common_squeak4
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+    @ no-op                             @ acquiring load
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IPUT */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_3DFF: /* 0x13d */
-/* File: armv5te/OP_UNUSED_3DFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_finish:
+    @bl      common_squeak0
+    mov     r1, rINST, lsr #8           @ r1<- A+
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    and     r1, r1, #15                 @ r1<- A
+    cmp     r9, #0                      @ check object for null
+    GET_VREG(r0, r1)                    @ r0<- fp[A]
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    @ no-op                         @ releasing store
+    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+    @ no-op 
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IPUT_WIDE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_3EFF: /* 0x13e */
-/* File: armv5te/OP_UNUSED_3EFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_WIDE_finish:
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    cmp     r9, #0                      @ check object for null
+    and     r2, r2, #15                 @ r2<- A
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    add     r2, rFP, r2, lsl #2         @ r3<- &fp[A]
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[A]
+    GET_INST_OPCODE(r10)                @ extract opcode from rINST
+    .if     0
+    add     r2, r9, r3                  @ r2<- target address
+    bl      dvmQuasiAtomicSwap64Sync    @ stores r0/r1 into addr r2
+    .else
+    strd    r0, [r9, r3]                @ obj.field (64 bits, aligned)<- r0/r1
+    .endif
+    GOTO_OPCODE(r10)                    @ jump to next instruction
 
+/* continuation for OP_IPUT_OBJECT */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_3FFF: /* 0x13f */
-/* File: armv5te/OP_UNUSED_3FFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_OBJECT_finish:
+    @bl      common_squeak0
+    mov     r1, rINST, lsr #8           @ r1<- A+
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    and     r1, r1, #15                 @ r1<- A
+    cmp     r9, #0                      @ check object for null
+    GET_VREG(r0, r1)                    @ r0<- fp[A]
+    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    @ no-op                         @ releasing store
+    str     r0, [r9, r3]                @ obj.field (32 bits)<- r0
+    @ no-op 
+    cmp     r0, #0                      @ stored a null reference?
+    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card if not
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IPUT_BOOLEAN */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_40FF: /* 0x140 */
-/* File: armv5te/OP_UNUSED_40FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_BOOLEAN_finish:
+    @bl      common_squeak1
+    mov     r1, rINST, lsr #8           @ r1<- A+
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    and     r1, r1, #15                 @ r1<- A
+    cmp     r9, #0                      @ check object for null
+    GET_VREG(r0, r1)                    @ r0<- fp[A]
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    @ no-op                         @ releasing store
+    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+    @ no-op 
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IPUT_BYTE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_41FF: /* 0x141 */
-/* File: armv5te/OP_UNUSED_41FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_BYTE_finish:
+    @bl      common_squeak2
+    mov     r1, rINST, lsr #8           @ r1<- A+
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    and     r1, r1, #15                 @ r1<- A
+    cmp     r9, #0                      @ check object for null
+    GET_VREG(r0, r1)                    @ r0<- fp[A]
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    @ no-op                         @ releasing store
+    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+    @ no-op 
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IPUT_CHAR */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_42FF: /* 0x142 */
-/* File: armv5te/OP_UNUSED_42FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_CHAR_finish:
+    @bl      common_squeak3
+    mov     r1, rINST, lsr #8           @ r1<- A+
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    and     r1, r1, #15                 @ r1<- A
+    cmp     r9, #0                      @ check object for null
+    GET_VREG(r0, r1)                    @ r0<- fp[A]
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    @ no-op                         @ releasing store
+    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+    @ no-op 
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IPUT_SHORT */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_43FF: /* 0x143 */
-/* File: armv5te/OP_UNUSED_43FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_SHORT_finish:
+    @bl      common_squeak4
+    mov     r1, rINST, lsr #8           @ r1<- A+
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    and     r1, r1, #15                 @ r1<- A
+    cmp     r9, #0                      @ check object for null
+    GET_VREG(r0, r1)                    @ r0<- fp[A]
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    @ no-op                         @ releasing store
+    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+    @ no-op 
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_SGET */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_44FF: /* 0x144 */
-/* File: armv5te/OP_UNUSED_44FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SGET_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_finish
 
+/* continuation for OP_SGET_WIDE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_45FF: /* 0x145 */
-/* File: armv5te/OP_UNUSED_45FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     *
+     * Returns StaticField pointer in r0.
+     */
+.LOP_SGET_WIDE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r1<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_WIDE_finish          @ resume
 
+/* continuation for OP_SGET_OBJECT */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_46FF: /* 0x146 */
-/* File: armv5te/OP_UNUSED_46FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_47FF: /* 0x147 */
-/* File: armv5te/OP_UNUSED_47FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_48FF: /* 0x148 */
-/* File: armv5te/OP_UNUSED_48FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SGET_OBJECT_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_OBJECT_finish
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_49FF: /* 0x149 */
-/* File: armv5te/OP_UNUSED_49FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_SGET_BOOLEAN */
 
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SGET_BOOLEAN_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_BOOLEAN_finish
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_4AFF: /* 0x14a */
-/* File: armv5te/OP_UNUSED_4AFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_SGET_BYTE */
 
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SGET_BYTE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_BYTE_finish
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_4BFF: /* 0x14b */
-/* File: armv5te/OP_UNUSED_4BFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_SGET_CHAR */
 
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SGET_CHAR_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_CHAR_finish
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_4CFF: /* 0x14c */
-/* File: armv5te/OP_UNUSED_4CFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_SGET_SHORT */
 
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SGET_SHORT_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_SHORT_finish
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_4DFF: /* 0x14d */
-/* File: armv5te/OP_UNUSED_4DFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_SPUT */
 
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SPUT_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_finish          @ resume
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_4EFF: /* 0x14e */
-/* File: armv5te/OP_UNUSED_4EFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_SPUT_WIDE */
 
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r9:  &fp[AA]
+     *  r10: dvmDex->pResFields
+     *
+     * Returns StaticField pointer in r2.
+     */
+.LOP_SPUT_WIDE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    mov     r2, r0                      @ copy to r2
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_WIDE_finish          @ resume
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_4FFF: /* 0x14f */
-/* File: armv5te/OP_UNUSED_4FFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_SPUT_OBJECT */
 
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_50FF: /* 0x150 */
-/* File: armv5te/OP_UNUSED_50FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+.LOP_SPUT_OBJECT_end:
+    str     r1, [r0, #offStaticField_value]  @ field<- vAA
+    @ no-op 
+    cmp     r1, #0                      @ stored a null object?
+    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card based on obj head
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+    /* Continuation if the field has not yet been resolved.
+     * r1:  BBBB field ref
+     * r10: dvmDex->pResFields
+     */
+.LOP_SPUT_OBJECT_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_OBJECT_finish          @ resume
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_51FF: /* 0x151 */
-/* File: armv5te/OP_UNUSED_51FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
 
+/* continuation for OP_SPUT_BOOLEAN */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_52FF: /* 0x152 */
-/* File: armv5te/OP_UNUSED_52FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SPUT_BOOLEAN_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_BOOLEAN_finish          @ resume
 
+/* continuation for OP_SPUT_BYTE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_53FF: /* 0x153 */
-/* File: armv5te/OP_UNUSED_53FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SPUT_BYTE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_BYTE_finish          @ resume
 
+/* continuation for OP_SPUT_CHAR */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_54FF: /* 0x154 */
-/* File: armv5te/OP_UNUSED_54FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SPUT_CHAR_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_CHAR_finish          @ resume
 
+/* continuation for OP_SPUT_SHORT */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_55FF: /* 0x155 */
-/* File: armv5te/OP_UNUSED_55FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SPUT_SHORT_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_SHORT_finish          @ resume
 
+/* continuation for OP_INVOKE_VIRTUAL */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_56FF: /* 0x156 */
-/* File: armv5te/OP_UNUSED_56FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * At this point:
+     *  r0 = resolved base method
+     *  r10 = C or CCCC (index of first arg, which is the "this" ptr)
+     */
+.LOP_INVOKE_VIRTUAL_continue:
+    GET_VREG(r9, r10)                   @ r9<- "this" ptr
+    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
+    cmp     r9, #0                      @ is "this" null?
+    beq     common_errNullObject        @ null "this", throw exception
+    ldr     r3, [r9, #offObject_clazz]  @ r3<- thisPtr->clazz
+    ldr     r3, [r3, #offClassObject_vtable]    @ r3<- thisPtr->clazz->vtable
+    ldr     r0, [r3, r2, lsl #2]        @ r3<- vtable[methodIndex]
+    bl      common_invokeMethodNoRange @ (r0=method, r9="this")
 
+/* continuation for OP_INVOKE_SUPER */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_57FF: /* 0x157 */
-/* File: armv5te/OP_UNUSED_57FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * At this point:
+     *  r0 = resolved base method
+     *  r10 = method->clazz
+     */
+.LOP_INVOKE_SUPER_continue:
+    ldr     r1, [r10, #offClassObject_super]    @ r1<- method->clazz->super
+    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
+    ldr     r3, [r1, #offClassObject_vtableCount]   @ r3<- super->vtableCount
+    EXPORT_PC()                         @ must export for invoke
+    cmp     r2, r3                      @ compare (methodIndex, vtableCount)
+    bcs     .LOP_INVOKE_SUPER_nsm             @ method not present in superclass
+    ldr     r1, [r1, #offClassObject_vtable]    @ r1<- ...clazz->super->vtable
+    ldr     r0, [r1, r2, lsl #2]        @ r3<- vtable[methodIndex]
+    bl      common_invokeMethodNoRange @ continue on
 
+.LOP_INVOKE_SUPER_resolve:
+    mov     r0, r10                     @ r0<- method->clazz
+    mov     r2, #METHOD_VIRTUAL         @ resolver method type
+    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
+    cmp     r0, #0                      @ got null?
+    bne     .LOP_INVOKE_SUPER_continue        @ no, continue
+    b       common_exceptionThrown      @ yes, handle exception
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_58FF: /* 0x158 */
-/* File: armv5te/OP_UNUSED_58FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Throw a NoSuchMethodError with the method name as the message.
+     *  r0 = resolved base method
+     */
+.LOP_INVOKE_SUPER_nsm:
+    ldr     r1, [r0, #offMethod_name]   @ r1<- method name
+    b       common_errNoSuchMethod
 
+/* continuation for OP_INVOKE_DIRECT */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_59FF: /* 0x159 */
-/* File: armv5te/OP_UNUSED_59FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * On entry:
+     *  r1 = reference (BBBB or CCCC)
+     *  r10 = "this" register
+     */
+.LOP_INVOKE_DIRECT_resolve:
+    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
+    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
+    mov     r2, #METHOD_DIRECT          @ resolver method type
+    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
+    cmp     r0, #0                      @ got null?
+    bne     .LOP_INVOKE_DIRECT_finish          @ no, continue
+    b       common_exceptionThrown      @ yes, handle exception
 
+/* continuation for OP_INVOKE_STATIC */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_5AFF: /* 0x15a */
-/* File: armv5te/OP_UNUSED_5AFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
 
+.LOP_INVOKE_STATIC_resolve:
+    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
+    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
+    mov     r2, #METHOD_STATIC          @ resolver method type
+    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
+    cmp     r0, #0                      @ got null?
+#if defined(WITH_JIT)
+    /*
+     * Check to see if we're actively building a trace.  If so,
+     * we need to keep this instruction out of it.
+     * r10: &resolved_methodToCall
+     */
+    ldrh    r2, [rSELF, #offThread_subMode]
+    beq     common_exceptionThrown            @ null, handle exception
+    ands    r2, #kSubModeJitTraceBuild        @ trace under construction?
+    beq     common_invokeMethodNoRange     @ no (r0=method, r9="this")
+    ldr     r1, [r10]                         @ reload resolved method
+    cmp     r1, #0                            @ finished resolving?
+    bne     common_invokeMethodNoRange     @ yes (r0=method, r9="this")
+    mov     r10, r0                           @ preserve method
+    mov     r0, rSELF
+    mov     r1, rPC
+    bl      dvmJitEndTraceSelect              @ (self, pc)
+    mov     r0, r10
+    b       common_invokeMethodNoRange     @ whew, finally!
+#else
+    bne     common_invokeMethodNoRange     @ (r0=method, r9="this")
+    b       common_exceptionThrown            @ yes, handle exception
+#endif
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_5BFF: /* 0x15b */
-/* File: armv5te/OP_UNUSED_5BFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_INVOKE_VIRTUAL_RANGE */
 
+    /*
+     * At this point:
+     *  r0 = resolved base method
+     *  r10 = C or CCCC (index of first arg, which is the "this" ptr)
+     */
+.LOP_INVOKE_VIRTUAL_RANGE_continue:
+    GET_VREG(r9, r10)                   @ r9<- "this" ptr
+    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
+    cmp     r9, #0                      @ is "this" null?
+    beq     common_errNullObject        @ null "this", throw exception
+    ldr     r3, [r9, #offObject_clazz]  @ r3<- thisPtr->clazz
+    ldr     r3, [r3, #offClassObject_vtable]    @ r3<- thisPtr->clazz->vtable
+    ldr     r0, [r3, r2, lsl #2]        @ r3<- vtable[methodIndex]
+    bl      common_invokeMethodRange @ (r0=method, r9="this")
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_5CFF: /* 0x15c */
-/* File: armv5te/OP_UNUSED_5CFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_INVOKE_SUPER_RANGE */
 
+    /*
+     * At this point:
+     *  r0 = resolved base method
+     *  r10 = method->clazz
+     */
+.LOP_INVOKE_SUPER_RANGE_continue:
+    ldr     r1, [r10, #offClassObject_super]    @ r1<- method->clazz->super
+    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
+    ldr     r3, [r1, #offClassObject_vtableCount]   @ r3<- super->vtableCount
+    EXPORT_PC()                         @ must export for invoke
+    cmp     r2, r3                      @ compare (methodIndex, vtableCount)
+    bcs     .LOP_INVOKE_SUPER_RANGE_nsm             @ method not present in superclass
+    ldr     r1, [r1, #offClassObject_vtable]    @ r1<- ...clazz->super->vtable
+    ldr     r0, [r1, r2, lsl #2]        @ r3<- vtable[methodIndex]
+    bl      common_invokeMethodRange @ continue on
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_5DFF: /* 0x15d */
-/* File: armv5te/OP_UNUSED_5DFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_5EFF: /* 0x15e */
-/* File: armv5te/OP_UNUSED_5EFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_5FFF: /* 0x15f */
-/* File: armv5te/OP_UNUSED_5FFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
+.LOP_INVOKE_SUPER_RANGE_resolve:
+    mov     r0, r10                     @ r0<- method->clazz
+    mov     r2, #METHOD_VIRTUAL         @ resolver method type
+    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
+    cmp     r0, #0                      @ got null?
+    bne     .LOP_INVOKE_SUPER_RANGE_continue        @ no, continue
+    b       common_exceptionThrown      @ yes, handle exception
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_60FF: /* 0x160 */
-/* File: armv5te/OP_UNUSED_60FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Throw a NoSuchMethodError with the method name as the message.
+     *  r0 = resolved base method
+     */
+.LOP_INVOKE_SUPER_RANGE_nsm:
+    ldr     r1, [r0, #offMethod_name]   @ r1<- method name
+    b       common_errNoSuchMethod
 
+/* continuation for OP_INVOKE_DIRECT_RANGE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_61FF: /* 0x161 */
-/* File: armv5te/OP_UNUSED_61FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * On entry:
+     *  r1 = reference (BBBB or CCCC)
+     *  r10 = "this" register
+     */
+.LOP_INVOKE_DIRECT_RANGE_resolve:
+    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
+    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
+    mov     r2, #METHOD_DIRECT          @ resolver method type
+    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
+    cmp     r0, #0                      @ got null?
+    bne     .LOP_INVOKE_DIRECT_RANGE_finish          @ no, continue
+    b       common_exceptionThrown      @ yes, handle exception
 
+/* continuation for OP_INVOKE_STATIC_RANGE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_62FF: /* 0x162 */
-/* File: armv5te/OP_UNUSED_62FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
 
+.LOP_INVOKE_STATIC_RANGE_resolve:
+    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
+    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
+    mov     r2, #METHOD_STATIC          @ resolver method type
+    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
+    cmp     r0, #0                      @ got null?
+#if defined(WITH_JIT)
+    /*
+     * Check to see if we're actively building a trace.  If so,
+     * we need to keep this instruction out of it.
+     * r10: &resolved_methodToCall
+     */
+    ldrh    r2, [rSELF, #offThread_subMode]
+    beq     common_exceptionThrown            @ null, handle exception
+    ands    r2, #kSubModeJitTraceBuild        @ trace under construction?
+    beq     common_invokeMethodRange     @ no (r0=method, r9="this")
+    ldr     r1, [r10]                         @ reload resolved method
+    cmp     r1, #0                            @ finished resolving?
+    bne     common_invokeMethodRange     @ yes (r0=method, r9="this")
+    mov     r10, r0                           @ preserve method
+    mov     r0, rSELF
+    mov     r1, rPC
+    bl      dvmJitEndTraceSelect              @ (self, pc)
+    mov     r0, r10
+    b       common_invokeMethodRange     @ whew, finally!
+#else
+    bne     common_invokeMethodRange     @ (r0=method, r9="this")
+    b       common_exceptionThrown            @ yes, handle exception
+#endif
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_63FF: /* 0x163 */
-/* File: armv5te/OP_UNUSED_63FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_FLOAT_TO_LONG */
+/*
+ * Convert the float in r0 to a long in r0/r1.
+ *
+ * We have to clip values to long min/max per the specification.  The
+ * expected common case is a "reasonable" value that converts directly
+ * to modest integer.  The EABI convert function isn't doing this for us.
+ */
+f2l_doconv:
+    stmfd   sp!, {r4, lr}
+    mov     r1, #0x5f000000             @ (float)maxlong
+    mov     r4, r0
+    bl      __aeabi_fcmpge              @ is arg >= maxlong?
+    cmp     r0, #0                      @ nonzero == yes
+    mvnne   r0, #0                      @ return maxlong (7fffffff)
+    mvnne   r1, #0x80000000
+    ldmnefd sp!, {r4, pc}
 
+    mov     r0, r4                      @ recover arg
+    mov     r1, #0xdf000000             @ (float)minlong
+    bl      __aeabi_fcmple              @ is arg <= minlong?
+    cmp     r0, #0                      @ nonzero == yes
+    movne   r0, #0                      @ return minlong (80000000)
+    movne   r1, #0x80000000
+    ldmnefd sp!, {r4, pc}
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_64FF: /* 0x164 */
-/* File: armv5te/OP_UNUSED_64FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    mov     r0, r4                      @ recover arg
+    mov     r1, r4
+    bl      __aeabi_fcmpeq              @ is arg == self?
+    cmp     r0, #0                      @ zero == no
+    moveq   r1, #0                      @ return zero for NaN
+    ldmeqfd sp!, {r4, pc}
 
+    mov     r0, r4                      @ recover arg
+    bl      __aeabi_f2lz                @ convert float to long
+    ldmfd   sp!, {r4, pc}
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_65FF: /* 0x165 */
-/* File: armv5te/OP_UNUSED_65FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_DOUBLE_TO_LONG */
+/*
+ * Convert the double in r0/r1 to a long in r0/r1.
+ *
+ * We have to clip values to long min/max per the specification.  The
+ * expected common case is a "reasonable" value that converts directly
+ * to modest integer.  The EABI convert function isn't doing this for us.
+ */
+d2l_doconv:
+    stmfd   sp!, {r4, r5, lr}           @ save regs
+    mov     r3, #0x43000000             @ maxlong, as a double (high word)
+    add     r3, #0x00e00000             @  0x43e00000
+    mov     r2, #0                      @ maxlong, as a double (low word)
+    sub     sp, sp, #4                  @ align for EABI
+    mov     r4, r0                      @ save a copy of r0
+    mov     r5, r1                      @  and r1
+    bl      __aeabi_dcmpge              @ is arg >= maxlong?
+    cmp     r0, #0                      @ nonzero == yes
+    mvnne   r0, #0                      @ return maxlong (7fffffffffffffff)
+    mvnne   r1, #0x80000000
+    bne     1f
 
+    mov     r0, r4                      @ recover arg
+    mov     r1, r5
+    mov     r3, #0xc3000000             @ minlong, as a double (high word)
+    add     r3, #0x00e00000             @  0xc3e00000
+    mov     r2, #0                      @ minlong, as a double (low word)
+    bl      __aeabi_dcmple              @ is arg <= minlong?
+    cmp     r0, #0                      @ nonzero == yes
+    movne   r0, #0                      @ return minlong (8000000000000000)
+    movne   r1, #0x80000000
+    bne     1f
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_66FF: /* 0x166 */
-/* File: armv5te/OP_UNUSED_66FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    mov     r0, r4                      @ recover arg
+    mov     r1, r5
+    mov     r2, r4                      @ compare against self
+    mov     r3, r5
+    bl      __aeabi_dcmpeq              @ is arg == self?
+    cmp     r0, #0                      @ zero == no
+    moveq   r1, #0                      @ return zero for NaN
+    beq     1f
 
+    mov     r0, r4                      @ recover arg
+    mov     r1, r5
+    bl      __aeabi_d2lz                @ convert double to long
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_67FF: /* 0x167 */
-/* File: armv5te/OP_UNUSED_67FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+1:
+    add     sp, sp, #4
+    ldmfd   sp!, {r4, r5, pc}
 
+/* continuation for OP_MUL_LONG */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_68FF: /* 0x168 */
-/* File: armv5te/OP_UNUSED_68FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+.LOP_MUL_LONG_finish:
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r0, {r9-r10}                @ vAA/vAA+1<- r9/r10
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_SHL_LONG */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_69FF: /* 0x169 */
-/* File: armv5te/OP_UNUSED_69FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+.LOP_SHL_LONG_finish:
+    mov     r0, r0, asl r2              @  r0<- r0 << r2
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_SHR_LONG */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_6AFF: /* 0x16a */
-/* File: armv5te/OP_UNUSED_6AFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+.LOP_SHR_LONG_finish:
+    mov     r1, r1, asr r2              @  r1<- r1 >> r2
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_USHR_LONG */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_6BFF: /* 0x16b */
-/* File: armv5te/OP_UNUSED_6BFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+.LOP_USHR_LONG_finish:
+    mov     r1, r1, lsr r2              @  r1<- r1 >>> r2
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_SHL_LONG_2ADDR */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_6CFF: /* 0x16c */
-/* File: armv5te/OP_UNUSED_6CFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+.LOP_SHL_LONG_2ADDR_finish:
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_SHR_LONG_2ADDR */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_6DFF: /* 0x16d */
-/* File: armv5te/OP_UNUSED_6DFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+.LOP_SHR_LONG_2ADDR_finish:
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_USHR_LONG_2ADDR */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_6EFF: /* 0x16e */
-/* File: armv5te/OP_UNUSED_6EFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+.LOP_USHR_LONG_2ADDR_finish:
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IGET_VOLATILE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_6FFF: /* 0x16f */
-/* File: armv5te/OP_UNUSED_6FFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_70FF: /* 0x170 */
-/* File: armv5te/OP_UNUSED_70FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_71FF: /* 0x171 */
-/* File: armv5te/OP_UNUSED_71FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_72FF: /* 0x172 */
-/* File: armv5te/OP_UNUSED_72FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IGET_VOLATILE_finish:
+    @bl      common_squeak0
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+    SMP_DMB                            @ acquiring load
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IPUT_VOLATILE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_73FF: /* 0x173 */
-/* File: armv5te/OP_UNUSED_73FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_VOLATILE_finish:
+    @bl      common_squeak0
+    mov     r1, rINST, lsr #8           @ r1<- A+
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    and     r1, r1, #15                 @ r1<- A
+    cmp     r9, #0                      @ check object for null
+    GET_VREG(r0, r1)                    @ r0<- fp[A]
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SMP_DMB_ST                        @ releasing store
+    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+    SMP_DMB
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_SGET_VOLATILE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_74FF: /* 0x174 */
-/* File: armv5te/OP_UNUSED_74FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SGET_VOLATILE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_VOLATILE_finish
 
+/* continuation for OP_SPUT_VOLATILE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_75FF: /* 0x175 */
-/* File: armv5te/OP_UNUSED_75FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SPUT_VOLATILE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_VOLATILE_finish          @ resume
 
+/* continuation for OP_IGET_OBJECT_VOLATILE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_76FF: /* 0x176 */
-/* File: armv5te/OP_UNUSED_76FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IGET_OBJECT_VOLATILE_finish:
+    @bl      common_squeak0
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+    SMP_DMB                            @ acquiring load
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IGET_WIDE_VOLATILE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_77FF: /* 0x177 */
-/* File: armv5te/OP_UNUSED_77FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IGET_WIDE_VOLATILE_finish:
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    .if     1
+    add     r0, r9, r3                  @ r0<- address of field
+    bl      dvmQuasiAtomicRead64        @ r0/r1<- contents of field
+    .else
+    ldrd    r0, [r9, r3]                @ r0/r1<- obj.field (64-bit align ok)
+    .endif
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    add     r3, rFP, r2, lsl #2         @ r3<- &fp[A]
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_IPUT_WIDE_VOLATILE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_78FF: /* 0x178 */
-/* File: armv5te/OP_UNUSED_78FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_WIDE_VOLATILE_finish:
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    cmp     r9, #0                      @ check object for null
+    and     r2, r2, #15                 @ r2<- A
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    add     r2, rFP, r2, lsl #2         @ r3<- &fp[A]
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[A]
+    GET_INST_OPCODE(r10)                @ extract opcode from rINST
+    .if     1
+    add     r2, r9, r3                  @ r2<- target address
+    bl      dvmQuasiAtomicSwap64Sync    @ stores r0/r1 into addr r2
+    .else
+    strd    r0, [r9, r3]                @ obj.field (64 bits, aligned)<- r0/r1
+    .endif
+    GOTO_OPCODE(r10)                    @ jump to next instruction
 
+/* continuation for OP_SGET_WIDE_VOLATILE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_79FF: /* 0x179 */
-/* File: armv5te/OP_UNUSED_79FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     *
+     * Returns StaticField pointer in r0.
+     */
+.LOP_SGET_WIDE_VOLATILE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r1<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_WIDE_VOLATILE_finish          @ resume
 
+/* continuation for OP_SPUT_WIDE_VOLATILE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_7AFF: /* 0x17a */
-/* File: armv5te/OP_UNUSED_7AFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r9:  &fp[AA]
+     *  r10: dvmDex->pResFields
+     *
+     * Returns StaticField pointer in r2.
+     */
+.LOP_SPUT_WIDE_VOLATILE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    mov     r2, r0                      @ copy to r2
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_WIDE_VOLATILE_finish          @ resume
 
+/* continuation for OP_EXECUTE_INLINE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_7BFF: /* 0x17b */
-/* File: armv5te/OP_UNUSED_7BFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_7CFF: /* 0x17c */
-/* File: armv5te/OP_UNUSED_7CFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_7DFF: /* 0x17d */
-/* File: armv5te/OP_UNUSED_7DFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_7EFF: /* 0x17e */
-/* File: armv5te/OP_UNUSED_7EFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_7FFF: /* 0x17f */
-/* File: armv5te/OP_UNUSED_7FFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_80FF: /* 0x180 */
-/* File: armv5te/OP_UNUSED_80FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_81FF: /* 0x181 */
-/* File: armv5te/OP_UNUSED_81FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_82FF: /* 0x182 */
-/* File: armv5te/OP_UNUSED_82FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_83FF: /* 0x183 */
-/* File: armv5te/OP_UNUSED_83FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_84FF: /* 0x184 */
-/* File: armv5te/OP_UNUSED_84FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_85FF: /* 0x185 */
-/* File: armv5te/OP_UNUSED_85FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_86FF: /* 0x186 */
-/* File: armv5te/OP_UNUSED_86FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_87FF: /* 0x187 */
-/* File: armv5te/OP_UNUSED_87FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_88FF: /* 0x188 */
-/* File: armv5te/OP_UNUSED_88FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_89FF: /* 0x189 */
-/* File: armv5te/OP_UNUSED_89FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+    /*
+     * Extract args, call function.
+     *  r0 = #of args (0-4)
+     *  r10 = call index
+     *  lr = return addr, above  [DO NOT bl out of here w/o preserving LR]
+     *
+     * Other ideas:
+     * - Use a jump table from the main piece to jump directly into the
+     *   AND/LDR pairs.  Costs a data load, saves a branch.
+     * - Have five separate pieces that do the loading, so we can work the
+     *   interleave a little better.  Increases code size.
+     */
+.LOP_EXECUTE_INLINE_continue:
+    rsb     r0, r0, #4                  @ r0<- 4-r0
+    FETCH(rINST, 2)                     @ rINST<- FEDC
+    add     pc, pc, r0, lsl #3          @ computed goto, 2 instrs each
+    bl      common_abort                @ (skipped due to ARM prefetch)
+4:  and     ip, rINST, #0xf000          @ isolate F
+    ldr     r3, [rFP, ip, lsr #10]      @ r3<- vF (shift right 12, left 2)
+3:  and     ip, rINST, #0x0f00          @ isolate E
+    ldr     r2, [rFP, ip, lsr #6]       @ r2<- vE
+2:  and     ip, rINST, #0x00f0          @ isolate D
+    ldr     r1, [rFP, ip, lsr #2]       @ r1<- vD
+1:  and     ip, rINST, #0x000f          @ isolate C
+    ldr     r0, [rFP, ip, lsl #2]       @ r0<- vC
+0:
+    ldr     rINST, .LOP_EXECUTE_INLINE_table    @ table of InlineOperation
+    ldr     pc, [rINST, r10, lsl #4]    @ sizeof=16, "func" is first entry
+    @ (not reached)
 
+    /*
+     * We're debugging or profiling.
+     * r10: opIndex
+     */
+.LOP_EXECUTE_INLINE_debugmode:
+    mov     r0, r10
+    bl      dvmResolveInlineNative
+    cmp     r0, #0                      @ did it resolve?
+    beq     .LOP_EXECUTE_INLINE_resume          @ no, just move on
+    mov     r9, r0                      @ remember method
+    mov     r1, rSELF
+    bl      dvmFastMethodTraceEnter     @ (method, self)
+    add     r1, rSELF, #offThread_retval@ r1<- &self->retval
+    sub     sp, sp, #8                  @ make room for arg, +64 bit align
+    mov     r0, rINST, lsr #12          @ r0<- B
+    str     r1, [sp]                    @ push &self->retval
+    bl      .LOP_EXECUTE_INLINE_continue        @ make call; will return after
+    mov     rINST, r0                   @ save result of inline
+    add     sp, sp, #8                  @ pop stack
+    mov     r0, r9                      @ r0<- method
+    mov     r1, rSELF
+    bl      dvmFastNativeMethodTraceExit @ (method, self)
+    cmp     rINST, #0                   @ test boolean result of inline
+    beq     common_exceptionThrown      @ returned false, handle exception
+    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_8AFF: /* 0x18a */
-/* File: armv5te/OP_UNUSED_8AFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
 
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_8BFF: /* 0x18b */
-/* File: armv5te/OP_UNUSED_8BFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
 
+.LOP_EXECUTE_INLINE_table:
+    .word   gDvmInlineOpsTable
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_8CFF: /* 0x18c */
-/* File: armv5te/OP_UNUSED_8CFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_EXECUTE_INLINE_RANGE */
 
+    /*
+     * Extract args, call function.
+     *  r0 = #of args (0-4)
+     *  r10 = call index
+     *  lr = return addr, above  [DO NOT bl out of here w/o preserving LR]
+     */
+.LOP_EXECUTE_INLINE_RANGE_continue:
+    rsb     r0, r0, #4                  @ r0<- 4-r0
+    FETCH(r9, 2)                        @ r9<- CCCC
+    add     pc, pc, r0, lsl #3          @ computed goto, 2 instrs each
+    bl      common_abort                @ (skipped due to ARM prefetch)
+4:  add     ip, r9, #3                  @ base+3
+    GET_VREG(r3, ip)                    @ r3<- vBase[3]
+3:  add     ip, r9, #2                  @ base+2
+    GET_VREG(r2, ip)                    @ r2<- vBase[2]
+2:  add     ip, r9, #1                  @ base+1
+    GET_VREG(r1, ip)                    @ r1<- vBase[1]
+1:  add     ip, r9, #0                  @ (nop)
+    GET_VREG(r0, ip)                    @ r0<- vBase[0]
+0:
+    ldr     r9, .LOP_EXECUTE_INLINE_RANGE_table       @ table of InlineOperation
+    ldr     pc, [r9, r10, lsl #4]       @ sizeof=16, "func" is first entry
+    @ (not reached)
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_8DFF: /* 0x18d */
-/* File: armv5te/OP_UNUSED_8DFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
 
+    /*
+     * We're debugging or profiling.
+     * r10: opIndex
+     */
+.LOP_EXECUTE_INLINE_RANGE_debugmode:
+    mov     r0, r10
+    bl      dvmResolveInlineNative
+    cmp     r0, #0                      @ did it resolve?
+    beq     .LOP_EXECUTE_INLINE_RANGE_resume          @ no, just move on
+    mov     r9, r0                      @ remember method
+    mov     r1, rSELF
+    bl      dvmFastMethodTraceEnter     @ (method, self)
+    add     r1, rSELF, #offThread_retval@ r1<- &self->retval
+    sub     sp, sp, #8                  @ make room for arg, +64 bit align
+    mov     r0, rINST, lsr #8           @ r0<- B
+    mov     rINST, r9                   @ rINST<- method
+    str     r1, [sp]                    @ push &self->retval
+    bl      .LOP_EXECUTE_INLINE_RANGE_continue        @ make call; will return after
+    mov     r9, r0                      @ save result of inline
+    add     sp, sp, #8                  @ pop stack
+    mov     r0, rINST                   @ r0<- method
+    mov     r1, rSELF
+    bl      dvmFastNativeMethodTraceExit  @ (method, self)
+    cmp     r9, #0                      @ test boolean result of inline
+    beq     common_exceptionThrown      @ returned false, handle exception
+    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_8EFF: /* 0x18e */
-/* File: armv5te/OP_UNUSED_8EFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
 
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_8FFF: /* 0x18f */
-/* File: armv5te/OP_UNUSED_8FFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
 
+.LOP_EXECUTE_INLINE_RANGE_table:
+    .word   gDvmInlineOpsTable
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_90FF: /* 0x190 */
-/* File: armv5te/OP_UNUSED_90FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
 
+/* continuation for OP_INVOKE_OBJECT_INIT_RANGE */
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_91FF: /* 0x191 */
-/* File: armv5te/OP_UNUSED_91FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+.LOP_INVOKE_OBJECT_INIT_RANGE_setFinal:
+    EXPORT_PC()                         @ can throw
+    bl      dvmSetFinalizable           @ call dvmSetFinalizable(obj)
+    ldr     r0, [rSELF, #offThread_exception] @ r0<- self->exception
+    cmp     r0, #0                      @ exception pending?
+    bne     common_exceptionThrown      @ yes, handle it
+    b       .LOP_INVOKE_OBJECT_INIT_RANGE_finish
 
+    /*
+     * A debugger is attached, so we need to go ahead and do
+     * this.  For simplicity, we'll just jump directly to the
+     * corresponding handler.  Note that we can't use
+     * rIBASE here because it may be in single-step mode.
+     * Load the primary table base directly.
+     */
+.LOP_INVOKE_OBJECT_INIT_RANGE_debugger:
+    ldr     r1, [rSELF, #offThread_mainHandlerTable]
+    mov     ip, #OP_INVOKE_DIRECT_RANGE
+    GOTO_OPCODE_BASE(r1,ip)             @ execute it
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_92FF: /* 0x192 */
-/* File: armv5te/OP_UNUSED_92FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
+/* continuation for OP_IPUT_OBJECT_VOLATILE */
 
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.LOP_IPUT_OBJECT_VOLATILE_finish:
+    @bl      common_squeak0
+    mov     r1, rINST, lsr #8           @ r1<- A+
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    and     r1, r1, #15                 @ r1<- A
+    cmp     r9, #0                      @ check object for null
+    GET_VREG(r0, r1)                    @ r0<- fp[A]
+    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SMP_DMB_ST                        @ releasing store
+    str     r0, [r9, r3]                @ obj.field (32 bits)<- r0
+    SMP_DMB
+    cmp     r0, #0                      @ stored a null reference?
+    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card if not
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_93FF: /* 0x193 */
-/* File: armv5te/OP_UNUSED_93FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_94FF: /* 0x194 */
-/* File: armv5te/OP_UNUSED_94FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_95FF: /* 0x195 */
-/* File: armv5te/OP_UNUSED_95FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_96FF: /* 0x196 */
-/* File: armv5te/OP_UNUSED_96FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_97FF: /* 0x197 */
-/* File: armv5te/OP_UNUSED_97FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_98FF: /* 0x198 */
-/* File: armv5te/OP_UNUSED_98FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_99FF: /* 0x199 */
-/* File: armv5te/OP_UNUSED_99FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_9AFF: /* 0x19a */
-/* File: armv5te/OP_UNUSED_9AFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_9BFF: /* 0x19b */
-/* File: armv5te/OP_UNUSED_9BFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_9CFF: /* 0x19c */
-/* File: armv5te/OP_UNUSED_9CFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_9DFF: /* 0x19d */
-/* File: armv5te/OP_UNUSED_9DFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_9EFF: /* 0x19e */
-/* File: armv5te/OP_UNUSED_9EFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_9FFF: /* 0x19f */
-/* File: armv5te/OP_UNUSED_9FFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A0FF: /* 0x1a0 */
-/* File: armv5te/OP_UNUSED_A0FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A1FF: /* 0x1a1 */
-/* File: armv5te/OP_UNUSED_A1FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A2FF: /* 0x1a2 */
-/* File: armv5te/OP_UNUSED_A2FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A3FF: /* 0x1a3 */
-/* File: armv5te/OP_UNUSED_A3FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A4FF: /* 0x1a4 */
-/* File: armv5te/OP_UNUSED_A4FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A5FF: /* 0x1a5 */
-/* File: armv5te/OP_UNUSED_A5FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A6FF: /* 0x1a6 */
-/* File: armv5te/OP_UNUSED_A6FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A7FF: /* 0x1a7 */
-/* File: armv5te/OP_UNUSED_A7FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A8FF: /* 0x1a8 */
-/* File: armv5te/OP_UNUSED_A8FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_A9FF: /* 0x1a9 */
-/* File: armv5te/OP_UNUSED_A9FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_AAFF: /* 0x1aa */
-/* File: armv5te/OP_UNUSED_AAFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_ABFF: /* 0x1ab */
-/* File: armv5te/OP_UNUSED_ABFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_ACFF: /* 0x1ac */
-/* File: armv5te/OP_UNUSED_ACFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_ADFF: /* 0x1ad */
-/* File: armv5te/OP_UNUSED_ADFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_AEFF: /* 0x1ae */
-/* File: armv5te/OP_UNUSED_AEFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_AFFF: /* 0x1af */
-/* File: armv5te/OP_UNUSED_AFFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B0FF: /* 0x1b0 */
-/* File: armv5te/OP_UNUSED_B0FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B1FF: /* 0x1b1 */
-/* File: armv5te/OP_UNUSED_B1FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B2FF: /* 0x1b2 */
-/* File: armv5te/OP_UNUSED_B2FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B3FF: /* 0x1b3 */
-/* File: armv5te/OP_UNUSED_B3FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B4FF: /* 0x1b4 */
-/* File: armv5te/OP_UNUSED_B4FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B5FF: /* 0x1b5 */
-/* File: armv5te/OP_UNUSED_B5FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B6FF: /* 0x1b6 */
-/* File: armv5te/OP_UNUSED_B6FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B7FF: /* 0x1b7 */
-/* File: armv5te/OP_UNUSED_B7FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B8FF: /* 0x1b8 */
-/* File: armv5te/OP_UNUSED_B8FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_B9FF: /* 0x1b9 */
-/* File: armv5te/OP_UNUSED_B9FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_BAFF: /* 0x1ba */
-/* File: armv5te/OP_UNUSED_BAFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_BBFF: /* 0x1bb */
-/* File: armv5te/OP_UNUSED_BBFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_BCFF: /* 0x1bc */
-/* File: armv5te/OP_UNUSED_BCFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_BDFF: /* 0x1bd */
-/* File: armv5te/OP_UNUSED_BDFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_BEFF: /* 0x1be */
-/* File: armv5te/OP_UNUSED_BEFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_BFFF: /* 0x1bf */
-/* File: armv5te/OP_UNUSED_BFFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C0FF: /* 0x1c0 */
-/* File: armv5te/OP_UNUSED_C0FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C1FF: /* 0x1c1 */
-/* File: armv5te/OP_UNUSED_C1FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C2FF: /* 0x1c2 */
-/* File: armv5te/OP_UNUSED_C2FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C3FF: /* 0x1c3 */
-/* File: armv5te/OP_UNUSED_C3FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C4FF: /* 0x1c4 */
-/* File: armv5te/OP_UNUSED_C4FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C5FF: /* 0x1c5 */
-/* File: armv5te/OP_UNUSED_C5FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C6FF: /* 0x1c6 */
-/* File: armv5te/OP_UNUSED_C6FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C7FF: /* 0x1c7 */
-/* File: armv5te/OP_UNUSED_C7FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C8FF: /* 0x1c8 */
-/* File: armv5te/OP_UNUSED_C8FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_C9FF: /* 0x1c9 */
-/* File: armv5te/OP_UNUSED_C9FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_CAFF: /* 0x1ca */
-/* File: armv5te/OP_UNUSED_CAFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_CBFF: /* 0x1cb */
-/* File: armv5te/OP_UNUSED_CBFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_CCFF: /* 0x1cc */
-/* File: armv5te/OP_UNUSED_CCFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_CDFF: /* 0x1cd */
-/* File: armv5te/OP_UNUSED_CDFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_CEFF: /* 0x1ce */
-/* File: armv5te/OP_UNUSED_CEFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_CFFF: /* 0x1cf */
-/* File: armv5te/OP_UNUSED_CFFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D0FF: /* 0x1d0 */
-/* File: armv5te/OP_UNUSED_D0FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D1FF: /* 0x1d1 */
-/* File: armv5te/OP_UNUSED_D1FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D2FF: /* 0x1d2 */
-/* File: armv5te/OP_UNUSED_D2FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D3FF: /* 0x1d3 */
-/* File: armv5te/OP_UNUSED_D3FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D4FF: /* 0x1d4 */
-/* File: armv5te/OP_UNUSED_D4FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D5FF: /* 0x1d5 */
-/* File: armv5te/OP_UNUSED_D5FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D6FF: /* 0x1d6 */
-/* File: armv5te/OP_UNUSED_D6FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D7FF: /* 0x1d7 */
-/* File: armv5te/OP_UNUSED_D7FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D8FF: /* 0x1d8 */
-/* File: armv5te/OP_UNUSED_D8FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_D9FF: /* 0x1d9 */
-/* File: armv5te/OP_UNUSED_D9FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_DAFF: /* 0x1da */
-/* File: armv5te/OP_UNUSED_DAFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_DBFF: /* 0x1db */
-/* File: armv5te/OP_UNUSED_DBFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_DCFF: /* 0x1dc */
-/* File: armv5te/OP_UNUSED_DCFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_DDFF: /* 0x1dd */
-/* File: armv5te/OP_UNUSED_DDFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_DEFF: /* 0x1de */
-/* File: armv5te/OP_UNUSED_DEFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_DFFF: /* 0x1df */
-/* File: armv5te/OP_UNUSED_DFFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E0FF: /* 0x1e0 */
-/* File: armv5te/OP_UNUSED_E0FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E1FF: /* 0x1e1 */
-/* File: armv5te/OP_UNUSED_E1FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E2FF: /* 0x1e2 */
-/* File: armv5te/OP_UNUSED_E2FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E3FF: /* 0x1e3 */
-/* File: armv5te/OP_UNUSED_E3FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E4FF: /* 0x1e4 */
-/* File: armv5te/OP_UNUSED_E4FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E5FF: /* 0x1e5 */
-/* File: armv5te/OP_UNUSED_E5FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E6FF: /* 0x1e6 */
-/* File: armv5te/OP_UNUSED_E6FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E7FF: /* 0x1e7 */
-/* File: armv5te/OP_UNUSED_E7FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E8FF: /* 0x1e8 */
-/* File: armv5te/OP_UNUSED_E8FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_E9FF: /* 0x1e9 */
-/* File: armv5te/OP_UNUSED_E9FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_EAFF: /* 0x1ea */
-/* File: armv5te/OP_UNUSED_EAFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_EBFF: /* 0x1eb */
-/* File: armv5te/OP_UNUSED_EBFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_ECFF: /* 0x1ec */
-/* File: armv5te/OP_UNUSED_ECFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_EDFF: /* 0x1ed */
-/* File: armv5te/OP_UNUSED_EDFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_EEFF: /* 0x1ee */
-/* File: armv5te/OP_UNUSED_EEFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_EFFF: /* 0x1ef */
-/* File: armv5te/OP_UNUSED_EFFF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_F0FF: /* 0x1f0 */
-/* File: armv5te/OP_UNUSED_F0FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_UNUSED_F1FF: /* 0x1f1 */
-/* File: armv5te/OP_UNUSED_F1FF.S */
-/* File: armv5te/unused.S */
-    bl      common_abort
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_INVOKE_OBJECT_INIT_JUMBO: /* 0x1f2 */
-/* File: armv5te/OP_INVOKE_OBJECT_INIT_JUMBO.S */
-/* File: armv5te/OP_INVOKE_OBJECT_INIT_RANGE.S */
-    /*
-     * Invoke Object.<init> on an object.  In practice we know that
-     * Object's nullary constructor doesn't do anything, so we just
-     * skip it unless a debugger is active.
-     */
-    FETCH(r1, 4)                  @ r1<- CCCC
-    GET_VREG(r0, r1)                    @ r0<- "this" ptr
-    cmp     r0, #0                      @ check for NULL
-    beq     common_errNullObject        @ export PC and throw NPE
-    ldr     r1, [r0, #offObject_clazz]  @ r1<- obj->clazz
-    ldr     r2, [r1, #offClassObject_accessFlags] @ r2<- clazz->accessFlags
-    tst     r2, #CLASS_ISFINALIZABLE    @ is this class finalizable?
-    bne     .LOP_INVOKE_OBJECT_INIT_JUMBO_setFinal        @ yes, go
-.LOP_INVOKE_OBJECT_INIT_JUMBO_finish:
-    ldrh    r1, [rSELF, #offThread_subMode]
-    ands    r1, #kSubModeDebuggerActive @ debugger active?
-    bne     .LOP_INVOKE_OBJECT_INIT_JUMBO_debugger        @ Yes - skip optimization
-    FETCH_ADVANCE_INST(4+1)       @ advance to next instr, load rINST
-    GET_INST_OPCODE(ip)                 @ ip<- opcode from rINST
-    GOTO_OPCODE(ip)                     @ execute it
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_VOLATILE_JUMBO: /* 0x1f3 */
-/* File: armv5te/OP_IGET_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_IGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit instance field get.
-     *
-     * for: iget/jumbo, iget-object/jumbo, iget-boolean/jumbo, iget-byte/jumbo,
-     *      iget-char/jumbo, iget-short/jumbo
-     */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_VOLATILE_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_VOLATILE_JUMBO_resolved        @ resolved, continue
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_WIDE_VOLATILE_JUMBO: /* 0x1f4 */
-/* File: armv5te/OP_IGET_WIDE_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_IGET_WIDE_JUMBO.S */
-    /*
-     * Jumbo 64-bit instance field get.
-     */
-    /* iget-wide/jumbo vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_WIDE_VOLATILE_JUMBO_finish          @ no, already resolved
-    ldr     r2, [rSELF, #offThread_method] @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_WIDE_VOLATILE_JUMBO_resolved        @ resolved, continue
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IGET_OBJECT_VOLATILE_JUMBO: /* 0x1f5 */
-/* File: armv5te/OP_IGET_OBJECT_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_IGET_OBJECT_JUMBO.S */
-/* File: armv5te/OP_IGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit instance field get.
-     *
-     * for: iget/jumbo, iget-object/jumbo, iget-boolean/jumbo, iget-byte/jumbo,
-     *      iget-char/jumbo, iget-short/jumbo
-     */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IGET_OBJECT_VOLATILE_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IGET_OBJECT_VOLATILE_JUMBO_resolved        @ resolved, continue
-
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_VOLATILE_JUMBO: /* 0x1f6 */
-/* File: armv5te/OP_IPUT_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_IPUT_JUMBO.S */
-    /*
-     * Jumbo 32-bit instance field put.
-     *
-     * for: iput/jumbo, iput-boolean/jumbo, iput-byte/jumbo, iput-char/jumbo,
-     *      iput-short/jumbo
-     */
-    /* exop vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_VOLATILE_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_VOLATILE_JUMBO_resolved        @ resolved, continue
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_WIDE_VOLATILE_JUMBO: /* 0x1f7 */
-/* File: armv5te/OP_IPUT_WIDE_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_IPUT_WIDE_JUMBO.S */
-    /* iput-wide/jumbo vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_WIDE_VOLATILE_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method] @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_WIDE_VOLATILE_JUMBO_resolved        @ resolved, continue
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_IPUT_OBJECT_VOLATILE_JUMBO: /* 0x1f8 */
-/* File: armv5te/OP_IPUT_OBJECT_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_IPUT_OBJECT_JUMBO.S */
-    /*
-     * Jumbo 32-bit instance field put.
-     */
-    /* iput-object/jumbo vBBBB, vCCCC, field@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    FETCH(r0, 4)                        @ r0<- CCCC
-    ldr     r3, [rSELF, #offThread_methodClassDex]    @ r3<- DvmDex
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[CCCC], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_IPUT_OBJECT_VOLATILE_JUMBO_finish          @ no, already resolved
-8:  ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
-    b       .LOP_IPUT_OBJECT_VOLATILE_JUMBO_resolved        @ resolved, continue
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_VOLATILE_JUMBO: /* 0x1f9 */
-/* File: armv5te/OP_SGET_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_SGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit SGET handler.
-     *
-     * for: sget/jumbo, sget-object/jumbo, sget-boolean/jumbo, sget-byte/jumbo,
-     *      sget-char/jumbo, sget-short/jumbo
-     */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_VOLATILE_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_VOLATILE_JUMBO_finish: @ field ptr in r0
-    ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    SMP_DMB                            @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    SET_VREG(r1, r2)                    @ fp[BBBB]<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_WIDE_VOLATILE_JUMBO: /* 0x1fa */
-/* File: armv5te/OP_SGET_WIDE_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_SGET_WIDE_JUMBO.S */
-    /*
-     * Jumbo 64-bit SGET handler.
-     */
-    /* sget-wide/jumbo vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r2, [r2, #offDvmDex_pResFields] @ r2<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_WIDE_VOLATILE_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_WIDE_VOLATILE_JUMBO_finish:
-    FETCH(r9, 3)                        @ r9<- BBBB
-    .if 1
-    add     r0, r0, #offStaticField_value @ r0<- pointer to data
-    bl      dvmQuasiAtomicRead64        @ r0/r1<- contents of field
-    .else
-    ldrd    r0, [r0, #offStaticField_value] @ r0/r1<- field value (aligned)
-    .endif
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[BBBB]
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    stmia   r9, {r0-r1}                 @ vBBBB/vBBBB+1<- r0/r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_SGET_OBJECT_VOLATILE_JUMBO: /* 0x1fb */
-/* File: armv5te/OP_SGET_OBJECT_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_SGET_OBJECT_JUMBO.S */
-/* File: armv5te/OP_SGET_JUMBO.S */
-    /*
-     * Jumbo 32-bit SGET handler.
-     *
-     * for: sget/jumbo, sget-object/jumbo, sget-boolean/jumbo, sget-byte/jumbo,
-     *      sget-char/jumbo, sget-short/jumbo
-     */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SGET_OBJECT_VOLATILE_JUMBO_resolve         @ yes, do resolve
-.LOP_SGET_OBJECT_VOLATILE_JUMBO_finish: @ field ptr in r0
-    ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    SMP_DMB                            @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    SET_VREG(r1, r2)                    @ fp[BBBB]<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_VOLATILE_JUMBO: /* 0x1fc */
-/* File: armv5te/OP_SPUT_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_SPUT_JUMBO.S */
-    /*
-     * Jumbo 32-bit SPUT handler.
-     *
-     * for: sput/jumbo, sput-boolean/jumbo, sput-byte/jumbo, sput-char/jumbo,
-     *      sput-short/jumbo
-     */
-    /* exop vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]        @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_VOLATILE_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_VOLATILE_JUMBO_finish:   @ field ptr in r0
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_VREG(r1, r2)                    @ r1<- fp[BBBB]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SMP_DMB_ST                        @ releasing store
-    str     r1, [r0, #offStaticField_value] @ field<- vBBBB
-    SMP_DMB
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_WIDE_VOLATILE_JUMBO: /* 0x1fd */
-/* File: armv5te/OP_SPUT_WIDE_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_SPUT_WIDE_JUMBO.S */
-    /*
-     * Jumbo 64-bit SPUT handler.
-     */
-    /* sput-wide/jumbo vBBBB, field@AAAAAAAA */
-    ldr     r0, [rSELF, #offThread_methodClassDex]  @ r0<- DvmDex
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    ldr     r10, [r0, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r1, r2, lsl #16         @ r1<- AAAAaaaa
-    FETCH(r9, 3)                        @ r9<- BBBB
-    ldr     r2, [r10, r1, lsl #2]       @ r2<- resolved StaticField ptr
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[BBBB]
-    cmp     r2, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_WIDE_VOLATILE_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_WIDE_VOLATILE_JUMBO_finish: @ field ptr in r2, BBBB in r9
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vBBBB/vBBBB+1
-    GET_INST_OPCODE(r10)                @ extract opcode from rINST
-    .if 1
-    add     r2, r2, #offStaticField_value @ r2<- pointer to data
-    bl      dvmQuasiAtomicSwap64Sync    @ stores r0/r1 into addr r2
-    .else
-    strd    r0, [r2, #offStaticField_value] @ field<- vBBBB/vBBBB+1
-    .endif
-    GOTO_OPCODE(r10)                    @ jump to next instruction
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_SPUT_OBJECT_VOLATILE_JUMBO: /* 0x1fe */
-/* File: armv5te/OP_SPUT_OBJECT_VOLATILE_JUMBO.S */
-/* File: armv5te/OP_SPUT_OBJECT_JUMBO.S */
-    /*
-     * Jumbo 32-bit SPUT handler for objects
-     */
-    /* sput-object/jumbo vBBBB, field@AAAAAAAA */
-    ldr     r2, [rSELF, #offThread_methodClassDex]    @ r2<- DvmDex
-    FETCH(r0, 1)                        @ r0<- aaaa (lo)
-    FETCH(r1, 2)                        @ r1<- AAAA (hi)
-    ldr     r10, [r2, #offDvmDex_pResFields] @ r10<- dvmDex->pResFields
-    orr     r1, r0, r1, lsl #16         @ r1<- AAAAaaaa
-    ldr     r0, [r10, r1, lsl #2]       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ is resolved entry null?
-    beq     .LOP_SPUT_OBJECT_VOLATILE_JUMBO_resolve         @ yes, do resolve
-.LOP_SPUT_OBJECT_VOLATILE_JUMBO_finish:   @ field ptr in r0
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_VREG(r1, r2)                    @ r1<- fp[BBBB]
-    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
-    ldr     r9, [r0, #offField_clazz]   @ r9<- field->clazz
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SMP_DMB_ST                        @ releasing store
-    b       .LOP_SPUT_OBJECT_VOLATILE_JUMBO_end
-
-
-/* ------------------------------ */
-    .balign 64
-.L_OP_THROW_VERIFICATION_ERROR_JUMBO: /* 0x1ff */
-/* File: armv5te/OP_THROW_VERIFICATION_ERROR_JUMBO.S */
-    /*
-     * Handle a jumbo throw-verification-error instruction.  This throws an
-     * exception for an error discovered during verification.  The
-     * exception is indicated by BBBB, with some detail provided by AAAAAAAA.
-     */
-    /* exop BBBB, Class@AAAAAAAA */
-    FETCH(r1, 1)                        @ r1<- aaaa (lo)
-    FETCH(r2, 2)                        @ r2<- AAAA (hi)
-    ldr     r0, [rSELF, #offThread_method]    @ r0<- self->method
-    orr     r2, r1, r2, lsl #16         @ r2<- AAAAaaaa
-    EXPORT_PC()                         @ export the PC
-    FETCH(r1, 3)                        @ r1<- BBBB
-    bl      dvmThrowVerificationError   @ always throws
-    b       common_exceptionThrown      @ handle exception
-
-    .balign 64
-    .size   dvmAsmInstructionStart, .-dvmAsmInstructionStart
-    .global dvmAsmInstructionEnd
-dvmAsmInstructionEnd:
-
-/*
- * ===========================================================================
- *  Sister implementations
- * ===========================================================================
- */
-    .global dvmAsmSisterStart
-    .type   dvmAsmSisterStart, %function
-    .text
-    .balign 4
-dvmAsmSisterStart:
-
-/* continuation for OP_CONST_STRING */
-
-    /*
-     * Continuation if the String has not yet been resolved.
-     *  r1: BBBB (String ref)
-     *  r9: target register
-     */
-.LOP_CONST_STRING_resolve:
-    EXPORT_PC()
-    ldr     r0, [rSELF, #offThread_method] @ r0<- self->method
-    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveString            @ r0<- String reference
-    cmp     r0, #0                      @ failed?
-    beq     common_exceptionThrown      @ yup, handle the exception
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r9)                    @ vAA<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_CONST_STRING_JUMBO */
-
-    /*
-     * Continuation if the String has not yet been resolved.
-     *  r1: BBBBBBBB (String ref)
-     *  r9: target register
-     */
-.LOP_CONST_STRING_JUMBO_resolve:
-    EXPORT_PC()
-    ldr     r0, [rSELF, #offThread_method] @ r0<- self->method
-    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveString            @ r0<- String reference
-    cmp     r0, #0                      @ failed?
-    beq     common_exceptionThrown      @ yup, handle the exception
-    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r9)                    @ vAA<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_CONST_CLASS */
-
-    /*
-     * Continuation if the Class has not yet been resolved.
-     *  r1: BBBB (Class ref)
-     *  r9: target register
-     */
-.LOP_CONST_CLASS_resolve:
-    EXPORT_PC()
-    ldr     r0, [rSELF, #offThread_method] @ r0<- self->method
-    mov     r2, #1                      @ r2<- true
-    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- Class reference
-    cmp     r0, #0                      @ failed?
-    beq     common_exceptionThrown      @ yup, handle the exception
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r9)                    @ vAA<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_CHECK_CAST */
-
-    /*
-     * Trivial test failed, need to perform full check.  This is common.
-     *  r0 holds obj->clazz
-     *  r1 holds desired class resolved from BBBB
-     *  r9 holds object
-     */
-.LOP_CHECK_CAST_fullcheck:
-    mov     r10, r1                     @ avoid ClassObject getting clobbered
-    bl      dvmInstanceofNonTrivial     @ r0<- boolean result
-    cmp     r0, #0                      @ failed?
-    bne     .LOP_CHECK_CAST_okay            @ no, success
-
-    @ A cast has failed.  We need to throw a ClassCastException.
-    EXPORT_PC()                         @ about to throw
-    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz (actual class)
-    mov     r1, r10                     @ r1<- desired class
-    bl      dvmThrowClassCastException
-    b       common_exceptionThrown
-
-    /*
-     * Resolution required.  This is the least-likely path.
-     *
-     *  r2 holds BBBB
-     *  r9 holds object
-     */
-.LOP_CHECK_CAST_resolve:
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    mov     r1, r2                      @ r1<- BBBB
-    mov     r2, #0                      @ r2<- false
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
-    cmp     r0, #0                      @ got null?
-    beq     common_exceptionThrown      @ yes, handle exception
-    mov     r1, r0                      @ r1<- class resolved from BBB
-    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz
-    b       .LOP_CHECK_CAST_resolved        @ pick up where we left off
-
-/* continuation for OP_INSTANCE_OF */
-
-    /*
-     * Trivial test failed, need to perform full check.  This is common.
-     *  r0 holds obj->clazz
-     *  r1 holds class resolved from BBBB
-     *  r9 holds A
-     */
-.LOP_INSTANCE_OF_fullcheck:
-    bl      dvmInstanceofNonTrivial     @ r0<- boolean result
-    @ fall through to OP_INSTANCE_OF_store
-
-    /*
-     * r0 holds boolean result
-     * r9 holds A
-     */
-.LOP_INSTANCE_OF_store:
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    SET_VREG(r0, r9)                    @ vA<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /*
-     * Trivial test succeeded, save and bail.
-     *  r9 holds A
-     */
-.LOP_INSTANCE_OF_trivial:
-    mov     r0, #1                      @ indicate success
-    @ could b OP_INSTANCE_OF_store, but copying is faster and cheaper
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    SET_VREG(r0, r9)                    @ vA<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /*
-     * Resolution required.  This is the least-likely path.
-     *
-     *  r3 holds BBBB
-     *  r9 holds A
-     */
-.LOP_INSTANCE_OF_resolve:
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [rSELF, #offThread_method]    @ r0<- self->method
-    mov     r1, r3                      @ r1<- BBBB
-    mov     r2, #1                      @ r2<- true
-    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
-    cmp     r0, #0                      @ got null?
-    beq     common_exceptionThrown      @ yes, handle exception
-    mov     r1, r0                      @ r1<- class resolved from BBB
-    mov     r3, rINST, lsr #12          @ r3<- B
-    GET_VREG(r0, r3)                    @ r0<- vB (object)
-    ldr     r0, [r0, #offObject_clazz]  @ r0<- obj->clazz
-    b       .LOP_INSTANCE_OF_resolved        @ pick up where we left off
-
-/* continuation for OP_NEW_INSTANCE */
-
-    .balign 32                          @ minimize cache lines
-.LOP_NEW_INSTANCE_finish: @ r0=new object
-    mov     r3, rINST, lsr #8           @ r3<- AA
-    cmp     r0, #0                      @ failed?
-#if defined(WITH_JIT)
-    /*
-     * The JIT needs the class to be fully resolved before it can
-     * include this instruction in a trace.
-     */
-    ldrh    r1, [rSELF, #offThread_subMode]
-    beq     common_exceptionThrown      @ yes, handle the exception
-    ands    r1, #kSubModeJitTraceBuild  @ under construction?
-    bne     .LOP_NEW_INSTANCE_jitCheck
-#else
-    beq     common_exceptionThrown      @ yes, handle the exception
-#endif
-.LOP_NEW_INSTANCE_end:
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r3)                    @ vAA<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-#if defined(WITH_JIT)
-    /*
-     * Check to see if we need to stop the trace building early.
-     * r0: new object
-     * r3: vAA
-     */
-.LOP_NEW_INSTANCE_jitCheck:
-    ldr     r1, [r10]                   @ reload resolved class
-    cmp     r1, #0                      @ okay?
-    bne     .LOP_NEW_INSTANCE_end             @ yes, finish
-    mov     r9, r0                      @ preserve new object
-    mov     r10, r3                     @ preserve vAA
-    mov     r0, rSELF
-    mov     r1, rPC
-    bl      dvmJitEndTraceSelect        @ (self, pc)
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r9, r10)                   @ vAA<- new object
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-#endif
-
-    /*
-     * Class initialization required.
-     *
-     *  r0 holds class object
-     */
-.LOP_NEW_INSTANCE_needinit:
-    mov     r9, r0                      @ save r0
-    bl      dvmInitClass                @ initialize class
-    cmp     r0, #0                      @ check boolean result
-    mov     r0, r9                      @ restore r0
-    bne     .LOP_NEW_INSTANCE_initialized     @ success, continue
-    b       common_exceptionThrown      @ failed, deal with init exception
-
-    /*
-     * Resolution required.  This is the least-likely path.
-     *
-     *  r1 holds BBBB
-     */
-.LOP_NEW_INSTANCE_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    mov     r2, #0                      @ r2<- false
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_NEW_INSTANCE_resolved        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-/* continuation for OP_NEW_ARRAY */
-
-
-    /*
-     * Resolve class.  (This is an uncommon case.)
-     *
-     *  r1 holds array length
-     *  r2 holds class ref CCCC
-     */
-.LOP_NEW_ARRAY_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    mov     r9, r1                      @ r9<- length (save)
-    mov     r1, r2                      @ r1<- CCCC
-    mov     r2, #0                      @ r2<- false
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- call(clazz, ref)
-    cmp     r0, #0                      @ got null?
-    mov     r1, r9                      @ r1<- length (restore)
-    beq     common_exceptionThrown      @ yes, handle exception
-    @ fall through to OP_NEW_ARRAY_finish
-
-    /*
-     * Finish allocation.
-     *
-     *  r0 holds class
-     *  r1 holds array length
-     */
-.LOP_NEW_ARRAY_finish:
-    mov     r2, #ALLOC_DONT_TRACK       @ don't track in local refs table
-    bl      dvmAllocArrayByClass        @ r0<- call(clazz, length, flags)
-    cmp     r0, #0                      @ failed?
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    beq     common_exceptionThrown      @ yes, handle the exception
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ vA<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_FILLED_NEW_ARRAY */
-
-    /*
-     * On entry:
-     *  r0 holds array class
-     *  r10 holds AA or BA
-     */
-.LOP_FILLED_NEW_ARRAY_continue:
-    ldr     r3, [r0, #offClassObject_descriptor] @ r3<- arrayClass->descriptor
-    mov     r2, #ALLOC_DONT_TRACK       @ r2<- alloc flags
-    ldrb    rINST, [r3, #1]             @ rINST<- descriptor[1]
-    .if     0
-    mov     r1, r10                     @ r1<- AA (length)
-    .else
-    mov     r1, r10, lsr #4             @ r1<- B (length)
-    .endif
-    cmp     rINST, #'I'                 @ array of ints?
-    cmpne   rINST, #'L'                 @ array of objects?
-    cmpne   rINST, #'['                 @ array of arrays?
-    mov     r9, r1                      @ save length in r9
-    bne     .LOP_FILLED_NEW_ARRAY_notimpl         @ no, not handled yet
-    bl      dvmAllocArrayByClass        @ r0<- call(arClass, length, flags)
-    cmp     r0, #0                      @ null return?
-    beq     common_exceptionThrown      @ alloc failed, handle exception
-
-    FETCH(r1, 2)                        @ r1<- FEDC or CCCC
-    str     r0, [rSELF, #offThread_retval]      @ retval.l <- new array
-    str     rINST, [rSELF, #offThread_retval+4] @ retval.h <- type
-    add     r0, r0, #offArrayObject_contents @ r0<- newArray->contents
-    subs    r9, r9, #1                  @ length--, check for neg
-    FETCH_ADVANCE_INST(3)               @ advance to next instr, load rINST
-    bmi     2f                          @ was zero, bail
-
-    @ copy values from registers into the array
-    @ r0=array, r1=CCCC/FEDC, r9=length (from AA or B), r10=AA/BA
-    .if     0
-    add     r2, rFP, r1, lsl #2         @ r2<- &fp[CCCC]
-1:  ldr     r3, [r2], #4                @ r3<- *r2++
-    subs    r9, r9, #1                  @ count--
-    str     r3, [r0], #4                @ *contents++ = vX
-    bpl     1b
-    @ continue at 2
-    .else
-    cmp     r9, #4                      @ length was initially 5?
-    and     r2, r10, #15                @ r2<- A
-    bne     1f                          @ <= 4 args, branch
-    GET_VREG(r3, r2)                    @ r3<- vA
-    sub     r9, r9, #1                  @ count--
-    str     r3, [r0, #16]               @ contents[4] = vA
-1:  and     r2, r1, #15                 @ r2<- F/E/D/C
-    GET_VREG(r3, r2)                    @ r3<- vF/vE/vD/vC
-    mov     r1, r1, lsr #4              @ r1<- next reg in low 4
-    subs    r9, r9, #1                  @ count--
-    str     r3, [r0], #4                @ *contents++ = vX
-    bpl     1b
-    @ continue at 2
-    .endif
-
-2:
-    ldr     r0, [rSELF, #offThread_retval]     @ r0<- object
-    ldr     r1, [rSELF, #offThread_retval+4]   @ r1<- type
-    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
-    GET_INST_OPCODE(ip)                      @ ip<- opcode from rINST
-    cmp     r1, #'I'                         @ Is int array?
-    strneb  r2, [r2, r0, lsr #GC_CARD_SHIFT] @ Mark card based on object head
-    GOTO_OPCODE(ip)                          @ execute it
-
-    /*
-     * Throw an exception indicating that we have not implemented this
-     * mode of filled-new-array.
-     */
-.LOP_FILLED_NEW_ARRAY_notimpl:
-    ldr     r0, .L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY
-    bl      dvmThrowInternalError
-    b       common_exceptionThrown
-
-    /*
-     * Ideally we'd only define this once, but depending on layout we can
-     * exceed the range of the load above.
-     */
-
-.L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY:
-    .word   .LstrFilledNewArrayNotImpl
-
-/* continuation for OP_FILLED_NEW_ARRAY_RANGE */
-
-    /*
-     * On entry:
-     *  r0 holds array class
-     *  r10 holds AA or BA
-     */
-.LOP_FILLED_NEW_ARRAY_RANGE_continue:
-    ldr     r3, [r0, #offClassObject_descriptor] @ r3<- arrayClass->descriptor
-    mov     r2, #ALLOC_DONT_TRACK       @ r2<- alloc flags
-    ldrb    rINST, [r3, #1]             @ rINST<- descriptor[1]
-    .if     1
-    mov     r1, r10                     @ r1<- AA (length)
-    .else
-    mov     r1, r10, lsr #4             @ r1<- B (length)
-    .endif
-    cmp     rINST, #'I'                 @ array of ints?
-    cmpne   rINST, #'L'                 @ array of objects?
-    cmpne   rINST, #'['                 @ array of arrays?
-    mov     r9, r1                      @ save length in r9
-    bne     .LOP_FILLED_NEW_ARRAY_RANGE_notimpl         @ no, not handled yet
-    bl      dvmAllocArrayByClass        @ r0<- call(arClass, length, flags)
-    cmp     r0, #0                      @ null return?
-    beq     common_exceptionThrown      @ alloc failed, handle exception
-
-    FETCH(r1, 2)                        @ r1<- FEDC or CCCC
-    str     r0, [rSELF, #offThread_retval]      @ retval.l <- new array
-    str     rINST, [rSELF, #offThread_retval+4] @ retval.h <- type
-    add     r0, r0, #offArrayObject_contents @ r0<- newArray->contents
-    subs    r9, r9, #1                  @ length--, check for neg
-    FETCH_ADVANCE_INST(3)               @ advance to next instr, load rINST
-    bmi     2f                          @ was zero, bail
-
-    @ copy values from registers into the array
-    @ r0=array, r1=CCCC/FEDC, r9=length (from AA or B), r10=AA/BA
-    .if     1
-    add     r2, rFP, r1, lsl #2         @ r2<- &fp[CCCC]
-1:  ldr     r3, [r2], #4                @ r3<- *r2++
-    subs    r9, r9, #1                  @ count--
-    str     r3, [r0], #4                @ *contents++ = vX
-    bpl     1b
-    @ continue at 2
-    .else
-    cmp     r9, #4                      @ length was initially 5?
-    and     r2, r10, #15                @ r2<- A
-    bne     1f                          @ <= 4 args, branch
-    GET_VREG(r3, r2)                    @ r3<- vA
-    sub     r9, r9, #1                  @ count--
-    str     r3, [r0, #16]               @ contents[4] = vA
-1:  and     r2, r1, #15                 @ r2<- F/E/D/C
-    GET_VREG(r3, r2)                    @ r3<- vF/vE/vD/vC
-    mov     r1, r1, lsr #4              @ r1<- next reg in low 4
-    subs    r9, r9, #1                  @ count--
-    str     r3, [r0], #4                @ *contents++ = vX
-    bpl     1b
-    @ continue at 2
-    .endif
-
-2:
-    ldr     r0, [rSELF, #offThread_retval]     @ r0<- object
-    ldr     r1, [rSELF, #offThread_retval+4]   @ r1<- type
-    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
-    GET_INST_OPCODE(ip)                      @ ip<- opcode from rINST
-    cmp     r1, #'I'                         @ Is int array?
-    strneb  r2, [r2, r0, lsr #GC_CARD_SHIFT] @ Mark card based on object head
-    GOTO_OPCODE(ip)                          @ execute it
-
-    /*
-     * Throw an exception indicating that we have not implemented this
-     * mode of filled-new-array.
-     */
-.LOP_FILLED_NEW_ARRAY_RANGE_notimpl:
-    ldr     r0, .L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY_RANGE
-    bl      dvmThrowInternalError
-    b       common_exceptionThrown
-
-    /*
-     * Ideally we'd only define this once, but depending on layout we can
-     * exceed the range of the load above.
-     */
-
-.L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY_RANGE:
-    .word   .LstrFilledNewArrayNotImpl
-
-/* continuation for OP_CMPL_FLOAT */
-
-    @ Test for NaN with a second comparison.  EABI forbids testing bit
-    @ patterns, and we can't represent 0x7fc00000 in immediate form, so
-    @ make the library call.
-.LOP_CMPL_FLOAT_gt_or_nan:
-    mov     r1, r9                      @ reverse order
-    mov     r0, r10
-    bl      __aeabi_cfcmple             @ r0<- Z set if eq, C clear if <
-    @bleq    common_abort
-    movcc   r1, #1                      @ (greater than) r1<- 1
-    bcc     .LOP_CMPL_FLOAT_finish
-    mvn     r1, #0                            @ r1<- 1 or -1 for NaN
-    b       .LOP_CMPL_FLOAT_finish
-
-
-#if 0       /* "clasic" form */
-    FETCH(r0, 1)                        @ r0<- CCBB
-    and     r2, r0, #255                @ r2<- BB
-    mov     r3, r0, lsr #8              @ r3<- CC
-    GET_VREG(r9, r2)                    @ r9<- vBB
-    GET_VREG(r10, r3)                   @ r10<- vCC
-    mov     r0, r9                      @ r0<- vBB
-    mov     r1, r10                     @ r1<- vCC
-    bl      __aeabi_fcmpeq              @ r0<- (vBB == vCC)
-    cmp     r0, #0                      @ equal?
-    movne   r1, #0                      @ yes, result is 0
-    bne     OP_CMPL_FLOAT_finish
-    mov     r0, r9                      @ r0<- vBB
-    mov     r1, r10                     @ r1<- vCC
-    bl      __aeabi_fcmplt              @ r0<- (vBB < vCC)
-    cmp     r0, #0                      @ less than?
-    b       OP_CMPL_FLOAT_continue
-@%break
-
-OP_CMPL_FLOAT_continue:
-    mvnne   r1, #0                      @ yes, result is -1
-    bne     OP_CMPL_FLOAT_finish
-    mov     r0, r9                      @ r0<- vBB
-    mov     r1, r10                     @ r1<- vCC
-    bl      __aeabi_fcmpgt              @ r0<- (vBB > vCC)
-    cmp     r0, #0                      @ greater than?
-    beq     OP_CMPL_FLOAT_nan               @ no, must be NaN
-    mov     r1, #1                      @ yes, result is 1
-    @ fall through to _finish
-
-OP_CMPL_FLOAT_finish:
-    mov     r3, rINST, lsr #8           @ r3<- AA
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    SET_VREG(r1, r3)                    @ vAA<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /*
-     * This is expected to be uncommon, so we double-branch (once to here,
-     * again back to _finish).
-     */
-OP_CMPL_FLOAT_nan:
-    mvn     r1, #0                            @ r1<- 1 or -1 for NaN
-    b       OP_CMPL_FLOAT_finish
-
-#endif
-
-/* continuation for OP_CMPG_FLOAT */
-
-    @ Test for NaN with a second comparison.  EABI forbids testing bit
-    @ patterns, and we can't represent 0x7fc00000 in immediate form, so
-    @ make the library call.
-.LOP_CMPG_FLOAT_gt_or_nan:
-    mov     r1, r9                      @ reverse order
-    mov     r0, r10
-    bl      __aeabi_cfcmple             @ r0<- Z set if eq, C clear if <
-    @bleq    common_abort
-    movcc   r1, #1                      @ (greater than) r1<- 1
-    bcc     .LOP_CMPG_FLOAT_finish
-    mov     r1, #1                            @ r1<- 1 or -1 for NaN
-    b       .LOP_CMPG_FLOAT_finish
-
-
-#if 0       /* "clasic" form */
-    FETCH(r0, 1)                        @ r0<- CCBB
-    and     r2, r0, #255                @ r2<- BB
-    mov     r3, r0, lsr #8              @ r3<- CC
-    GET_VREG(r9, r2)                    @ r9<- vBB
-    GET_VREG(r10, r3)                   @ r10<- vCC
-    mov     r0, r9                      @ r0<- vBB
-    mov     r1, r10                     @ r1<- vCC
-    bl      __aeabi_fcmpeq              @ r0<- (vBB == vCC)
-    cmp     r0, #0                      @ equal?
-    movne   r1, #0                      @ yes, result is 0
-    bne     OP_CMPG_FLOAT_finish
-    mov     r0, r9                      @ r0<- vBB
-    mov     r1, r10                     @ r1<- vCC
-    bl      __aeabi_fcmplt              @ r0<- (vBB < vCC)
-    cmp     r0, #0                      @ less than?
-    b       OP_CMPG_FLOAT_continue
-@%break
-
-OP_CMPG_FLOAT_continue:
-    mvnne   r1, #0                      @ yes, result is -1
-    bne     OP_CMPG_FLOAT_finish
-    mov     r0, r9                      @ r0<- vBB
-    mov     r1, r10                     @ r1<- vCC
-    bl      __aeabi_fcmpgt              @ r0<- (vBB > vCC)
-    cmp     r0, #0                      @ greater than?
-    beq     OP_CMPG_FLOAT_nan               @ no, must be NaN
-    mov     r1, #1                      @ yes, result is 1
-    @ fall through to _finish
-
-OP_CMPG_FLOAT_finish:
-    mov     r3, rINST, lsr #8           @ r3<- AA
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    SET_VREG(r1, r3)                    @ vAA<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /*
-     * This is expected to be uncommon, so we double-branch (once to here,
-     * again back to _finish).
-     */
-OP_CMPG_FLOAT_nan:
-    mov     r1, #1                            @ r1<- 1 or -1 for NaN
-    b       OP_CMPG_FLOAT_finish
-
-#endif
-
-/* continuation for OP_CMPL_DOUBLE */
-
-    @ Test for NaN with a second comparison.  EABI forbids testing bit
-    @ patterns, and we can't represent 0x7fc00000 in immediate form, so
-    @ make the library call.
-.LOP_CMPL_DOUBLE_gt_or_nan:
-    ldmia   r10, {r0-r1}                @ reverse order
-    ldmia   r9, {r2-r3}
-    bl      __aeabi_cdcmple             @ r0<- Z set if eq, C clear if <
-    @bleq    common_abort
-    movcc   r1, #1                      @ (greater than) r1<- 1
-    bcc     .LOP_CMPL_DOUBLE_finish
-    mvn     r1, #0                            @ r1<- 1 or -1 for NaN
-    b       .LOP_CMPL_DOUBLE_finish
-
-/* continuation for OP_CMPG_DOUBLE */
-
-    @ Test for NaN with a second comparison.  EABI forbids testing bit
-    @ patterns, and we can't represent 0x7fc00000 in immediate form, so
-    @ make the library call.
-.LOP_CMPG_DOUBLE_gt_or_nan:
-    ldmia   r10, {r0-r1}                @ reverse order
-    ldmia   r9, {r2-r3}
-    bl      __aeabi_cdcmple             @ r0<- Z set if eq, C clear if <
-    @bleq    common_abort
-    movcc   r1, #1                      @ (greater than) r1<- 1
-    bcc     .LOP_CMPG_DOUBLE_finish
-    mov     r1, #1                            @ r1<- 1 or -1 for NaN
-    b       .LOP_CMPG_DOUBLE_finish
-
-/* continuation for OP_CMP_LONG */
-
-.LOP_CMP_LONG_less:
-    mvn     r1, #0                      @ r1<- -1
-    @ Want to cond code the next mov so we can avoid branch, but don't see it;
-    @ instead, we just replicate the tail end.
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    SET_VREG(r1, r9)                    @ vAA<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-.LOP_CMP_LONG_greater:
-    mov     r1, #1                      @ r1<- 1
-    @ fall through to _finish
-
-.LOP_CMP_LONG_finish:
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    SET_VREG(r1, r9)                    @ vAA<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_AGET_WIDE */
-
-.LOP_AGET_WIDE_finish:
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldrd    r2, [r0, #offArrayObject_contents]  @ r2/r3<- vBB[vCC]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r2-r3}                 @ vAA/vAA+1<- r2/r3
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_APUT_WIDE */
-
-.LOP_APUT_WIDE_finish:
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldmia   r9, {r2-r3}                 @ r2/r3<- vAA/vAA+1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    strd    r2, [r0, #offArrayObject_contents]  @ r2/r3<- vBB[vCC]
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_APUT_OBJECT */
-    /*
-     * On entry:
-     *  rINST = vBB (arrayObj)
-     *  r9 = vAA (obj)
-     *  r10 = offset into array (vBB + vCC * width)
-     */
-.LOP_APUT_OBJECT_finish:
-    cmp     r9, #0                      @ storing null reference?
-    beq     .LOP_APUT_OBJECT_skip_check      @ yes, skip type checks
-    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz
-    ldr     r1, [rINST, #offObject_clazz]  @ r1<- arrayObj->clazz
-    bl      dvmCanPutArrayElement       @ test object type vs. array type
-    cmp     r0, #0                      @ okay?
-    beq     .LOP_APUT_OBJECT_throw           @ no
-    mov     r1, rINST                   @ r1<- arrayObj
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldr     r2, [rSELF, #offThread_cardTable]     @ get biased CT base
-    add     r10, #offArrayObject_contents   @ r0<- pointer to slot
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    str     r9, [r10]                   @ vBB[vCC]<- vAA
-    strb    r2, [r2, r1, lsr #GC_CARD_SHIFT] @ mark card using object head
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-.LOP_APUT_OBJECT_skip_check:
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    str     r9, [r10, #offArrayObject_contents] @ vBB[vCC]<- vAA
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-.LOP_APUT_OBJECT_throw:
-    @ The types don't match.  We need to throw an ArrayStoreException.
-    ldr     r0, [r9, #offObject_clazz]
-    ldr     r1, [rINST, #offObject_clazz]
-    EXPORT_PC()
-    bl      dvmThrowArrayStoreExceptionIncompatibleElement
-    b       common_exceptionThrown
-
-/* continuation for OP_IGET */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_finish:
-    @bl      common_squeak0
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ fp[A]<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_WIDE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_WIDE_finish:
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    .if     0
-    add     r0, r9, r3                  @ r0<- address of field
-    bl      dvmQuasiAtomicRead64        @ r0/r1<- contents of field
-    .else
-    ldrd    r0, [r9, r3]                @ r0/r1<- obj.field (64-bit align ok)
-    .endif
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    add     r3, rFP, r2, lsl #2         @ r3<- &fp[A]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_OBJECT */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_OBJECT_finish:
-    @bl      common_squeak0
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ fp[A]<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_BOOLEAN */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_BOOLEAN_finish:
-    @bl      common_squeak1
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ fp[A]<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_BYTE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_BYTE_finish:
-    @bl      common_squeak2
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ fp[A]<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_CHAR */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_CHAR_finish:
-    @bl      common_squeak3
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ fp[A]<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_SHORT */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_SHORT_finish:
-    @bl      common_squeak4
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ fp[A]<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_finish:
-    @bl      common_squeak0
-    mov     r1, rINST, lsr #8           @ r1<- A+
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    and     r1, r1, #15                 @ r1<- A
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[A]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                         @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_WIDE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_WIDE_finish:
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    cmp     r9, #0                      @ check object for null
-    and     r2, r2, #15                 @ r2<- A
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    add     r2, rFP, r2, lsl #2         @ r3<- &fp[A]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[A]
-    GET_INST_OPCODE(r10)                @ extract opcode from rINST
-    .if     0
-    add     r2, r9, r3                  @ r2<- target address
-    bl      dvmQuasiAtomicSwap64Sync    @ stores r0/r1 into addr r2
-    .else
-    strd    r0, [r9, r3]                @ obj.field (64 bits, aligned)<- r0/r1
-    .endif
-    GOTO_OPCODE(r10)                    @ jump to next instruction
-
-/* continuation for OP_IPUT_OBJECT */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_OBJECT_finish:
-    @bl      common_squeak0
-    mov     r1, rINST, lsr #8           @ r1<- A+
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    and     r1, r1, #15                 @ r1<- A
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[A]
-    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                         @ releasing store
-    str     r0, [r9, r3]                @ obj.field (32 bits)<- r0
-    @ no-op 
-    cmp     r0, #0                      @ stored a null reference?
-    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card if not
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_BOOLEAN */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_BOOLEAN_finish:
-    @bl      common_squeak1
-    mov     r1, rINST, lsr #8           @ r1<- A+
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    and     r1, r1, #15                 @ r1<- A
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[A]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                         @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_BYTE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_BYTE_finish:
-    @bl      common_squeak2
-    mov     r1, rINST, lsr #8           @ r1<- A+
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    and     r1, r1, #15                 @ r1<- A
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[A]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                         @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_CHAR */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_CHAR_finish:
-    @bl      common_squeak3
-    mov     r1, rINST, lsr #8           @ r1<- A+
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    and     r1, r1, #15                 @ r1<- A
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[A]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                         @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_SHORT */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_SHORT_finish:
-    @bl      common_squeak4
-    mov     r1, rINST, lsr #8           @ r1<- A+
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    and     r1, r1, #15                 @ r1<- A
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[A]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                         @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_SGET */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_finish
-
-/* continuation for OP_SGET_WIDE */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     *
-     * Returns StaticField pointer in r0.
-     */
-.LOP_SGET_WIDE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r1<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_WIDE_finish          @ resume
-
-/* continuation for OP_SGET_OBJECT */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_OBJECT_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_OBJECT_finish
-
-/* continuation for OP_SGET_BOOLEAN */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_BOOLEAN_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_BOOLEAN_finish
-
-/* continuation for OP_SGET_BYTE */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_BYTE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_BYTE_finish
-
-/* continuation for OP_SGET_CHAR */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_CHAR_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_CHAR_finish
-
-/* continuation for OP_SGET_SHORT */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_SHORT_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_SHORT_finish
-
-/* continuation for OP_SPUT */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_finish          @ resume
-
-/* continuation for OP_SPUT_WIDE */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r9:  &fp[AA]
-     *  r10: dvmDex->pResFields
-     *
-     * Returns StaticField pointer in r2.
-     */
-.LOP_SPUT_WIDE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    mov     r2, r0                      @ copy to r2
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_WIDE_finish          @ resume
-
-/* continuation for OP_SPUT_OBJECT */
-
-
-.LOP_SPUT_OBJECT_end:
-    str     r1, [r0, #offStaticField_value]  @ field<- vAA
-    @ no-op 
-    cmp     r1, #0                      @ stored a null object?
-    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card based on obj head
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /* Continuation if the field has not yet been resolved.
-     * r1:  BBBB field ref
-     * r10: dvmDex->pResFields
-     */
-.LOP_SPUT_OBJECT_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_OBJECT_finish          @ resume
-
-
-/* continuation for OP_SPUT_BOOLEAN */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_BOOLEAN_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_BOOLEAN_finish          @ resume
-
-/* continuation for OP_SPUT_BYTE */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_BYTE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_BYTE_finish          @ resume
-
-/* continuation for OP_SPUT_CHAR */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_CHAR_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_CHAR_finish          @ resume
-
-/* continuation for OP_SPUT_SHORT */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_SHORT_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_SHORT_finish          @ resume
-
-/* continuation for OP_INVOKE_VIRTUAL */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r10 = C or CCCC (index of first arg, which is the "this" ptr)
-     */
-.LOP_INVOKE_VIRTUAL_continue:
-    GET_VREG(r9, r10)                   @ r9<- "this" ptr
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    cmp     r9, #0                      @ is "this" null?
-    beq     common_errNullObject        @ null "this", throw exception
-    ldr     r3, [r9, #offObject_clazz]  @ r3<- thisPtr->clazz
-    ldr     r3, [r3, #offClassObject_vtable]    @ r3<- thisPtr->clazz->vtable
-    ldr     r0, [r3, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodNoRange @ (r0=method, r9="this")
-
-/* continuation for OP_INVOKE_SUPER */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r10 = method->clazz
-     */
-.LOP_INVOKE_SUPER_continue:
-    ldr     r1, [r10, #offClassObject_super]    @ r1<- method->clazz->super
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    ldr     r3, [r1, #offClassObject_vtableCount]   @ r3<- super->vtableCount
-    EXPORT_PC()                         @ must export for invoke
-    cmp     r2, r3                      @ compare (methodIndex, vtableCount)
-    bcs     .LOP_INVOKE_SUPER_nsm             @ method not present in superclass
-    ldr     r1, [r1, #offClassObject_vtable]    @ r1<- ...clazz->super->vtable
-    ldr     r0, [r1, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodNoRange @ continue on
-
-.LOP_INVOKE_SUPER_resolve:
-    mov     r0, r10                     @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_SUPER_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-    /*
-     * Throw a NoSuchMethodError with the method name as the message.
-     *  r0 = resolved base method
-     */
-.LOP_INVOKE_SUPER_nsm:
-    ldr     r1, [r0, #offMethod_name]   @ r1<- method name
-    b       common_errNoSuchMethod
-
-/* continuation for OP_INVOKE_DIRECT */
-
-    /*
-     * On entry:
-     *  r1 = reference (BBBB or CCCC)
-     *  r10 = "this" register
-     */
-.LOP_INVOKE_DIRECT_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_DIRECT          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_DIRECT_finish          @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-/* continuation for OP_INVOKE_STATIC */
-
-
-.LOP_INVOKE_STATIC_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_STATIC          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-#if defined(WITH_JIT)
-    /*
-     * Check to see if we're actively building a trace.  If so,
-     * we need to keep this instruction out of it.
-     * r10: &resolved_methodToCall
-     */
-    ldrh    r2, [rSELF, #offThread_subMode]
-    beq     common_exceptionThrown            @ null, handle exception
-    ands    r2, #kSubModeJitTraceBuild        @ trace under construction?
-    beq     common_invokeMethodNoRange     @ no (r0=method, r9="this")
-    ldr     r1, [r10]                         @ reload resolved method
-    cmp     r1, #0                            @ finished resolving?
-    bne     common_invokeMethodNoRange     @ yes (r0=method, r9="this")
-    mov     r10, r0                           @ preserve method
-    mov     r0, rSELF
-    mov     r1, rPC
-    bl      dvmJitEndTraceSelect              @ (self, pc)
-    mov     r0, r10
-    b       common_invokeMethodNoRange     @ whew, finally!
-#else
-    bne     common_invokeMethodNoRange     @ (r0=method, r9="this")
-    b       common_exceptionThrown            @ yes, handle exception
-#endif
-
-/* continuation for OP_INVOKE_VIRTUAL_RANGE */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r10 = C or CCCC (index of first arg, which is the "this" ptr)
-     */
-.LOP_INVOKE_VIRTUAL_RANGE_continue:
-    GET_VREG(r9, r10)                   @ r9<- "this" ptr
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    cmp     r9, #0                      @ is "this" null?
-    beq     common_errNullObject        @ null "this", throw exception
-    ldr     r3, [r9, #offObject_clazz]  @ r3<- thisPtr->clazz
-    ldr     r3, [r3, #offClassObject_vtable]    @ r3<- thisPtr->clazz->vtable
-    ldr     r0, [r3, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodRange @ (r0=method, r9="this")
-
-/* continuation for OP_INVOKE_SUPER_RANGE */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r10 = method->clazz
-     */
-.LOP_INVOKE_SUPER_RANGE_continue:
-    ldr     r1, [r10, #offClassObject_super]    @ r1<- method->clazz->super
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    ldr     r3, [r1, #offClassObject_vtableCount]   @ r3<- super->vtableCount
-    EXPORT_PC()                         @ must export for invoke
-    cmp     r2, r3                      @ compare (methodIndex, vtableCount)
-    bcs     .LOP_INVOKE_SUPER_RANGE_nsm             @ method not present in superclass
-    ldr     r1, [r1, #offClassObject_vtable]    @ r1<- ...clazz->super->vtable
-    ldr     r0, [r1, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodRange @ continue on
-
-.LOP_INVOKE_SUPER_RANGE_resolve:
-    mov     r0, r10                     @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_SUPER_RANGE_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-    /*
-     * Throw a NoSuchMethodError with the method name as the message.
-     *  r0 = resolved base method
-     */
-.LOP_INVOKE_SUPER_RANGE_nsm:
-    ldr     r1, [r0, #offMethod_name]   @ r1<- method name
-    b       common_errNoSuchMethod
-
-/* continuation for OP_INVOKE_DIRECT_RANGE */
-
-    /*
-     * On entry:
-     *  r1 = reference (BBBB or CCCC)
-     *  r10 = "this" register
-     */
-.LOP_INVOKE_DIRECT_RANGE_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_DIRECT          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_DIRECT_RANGE_finish          @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-/* continuation for OP_INVOKE_STATIC_RANGE */
-
-
-.LOP_INVOKE_STATIC_RANGE_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_STATIC          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-#if defined(WITH_JIT)
-    /*
-     * Check to see if we're actively building a trace.  If so,
-     * we need to keep this instruction out of it.
-     * r10: &resolved_methodToCall
-     */
-    ldrh    r2, [rSELF, #offThread_subMode]
-    beq     common_exceptionThrown            @ null, handle exception
-    ands    r2, #kSubModeJitTraceBuild        @ trace under construction?
-    beq     common_invokeMethodRange     @ no (r0=method, r9="this")
-    ldr     r1, [r10]                         @ reload resolved method
-    cmp     r1, #0                            @ finished resolving?
-    bne     common_invokeMethodRange     @ yes (r0=method, r9="this")
-    mov     r10, r0                           @ preserve method
-    mov     r0, rSELF
-    mov     r1, rPC
-    bl      dvmJitEndTraceSelect              @ (self, pc)
-    mov     r0, r10
-    b       common_invokeMethodRange     @ whew, finally!
-#else
-    bne     common_invokeMethodRange     @ (r0=method, r9="this")
-    b       common_exceptionThrown            @ yes, handle exception
-#endif
-
-/* continuation for OP_FLOAT_TO_LONG */
-/*
- * Convert the float in r0 to a long in r0/r1.
- *
- * We have to clip values to long min/max per the specification.  The
- * expected common case is a "reasonable" value that converts directly
- * to modest integer.  The EABI convert function isn't doing this for us.
- */
-f2l_doconv:
-    stmfd   sp!, {r4, lr}
-    mov     r1, #0x5f000000             @ (float)maxlong
-    mov     r4, r0
-    bl      __aeabi_fcmpge              @ is arg >= maxlong?
-    cmp     r0, #0                      @ nonzero == yes
-    mvnne   r0, #0                      @ return maxlong (7fffffff)
-    mvnne   r1, #0x80000000
-    ldmnefd sp!, {r4, pc}
-
-    mov     r0, r4                      @ recover arg
-    mov     r1, #0xdf000000             @ (float)minlong
-    bl      __aeabi_fcmple              @ is arg <= minlong?
-    cmp     r0, #0                      @ nonzero == yes
-    movne   r0, #0                      @ return minlong (80000000)
-    movne   r1, #0x80000000
-    ldmnefd sp!, {r4, pc}
-
-    mov     r0, r4                      @ recover arg
-    mov     r1, r4
-    bl      __aeabi_fcmpeq              @ is arg == self?
-    cmp     r0, #0                      @ zero == no
-    moveq   r1, #0                      @ return zero for NaN
-    ldmeqfd sp!, {r4, pc}
-
-    mov     r0, r4                      @ recover arg
-    bl      __aeabi_f2lz                @ convert float to long
-    ldmfd   sp!, {r4, pc}
-
-/* continuation for OP_DOUBLE_TO_LONG */
-/*
- * Convert the double in r0/r1 to a long in r0/r1.
- *
- * We have to clip values to long min/max per the specification.  The
- * expected common case is a "reasonable" value that converts directly
- * to modest integer.  The EABI convert function isn't doing this for us.
- */
-d2l_doconv:
-    stmfd   sp!, {r4, r5, lr}           @ save regs
-    mov     r3, #0x43000000             @ maxlong, as a double (high word)
-    add     r3, #0x00e00000             @  0x43e00000
-    mov     r2, #0                      @ maxlong, as a double (low word)
-    sub     sp, sp, #4                  @ align for EABI
-    mov     r4, r0                      @ save a copy of r0
-    mov     r5, r1                      @  and r1
-    bl      __aeabi_dcmpge              @ is arg >= maxlong?
-    cmp     r0, #0                      @ nonzero == yes
-    mvnne   r0, #0                      @ return maxlong (7fffffffffffffff)
-    mvnne   r1, #0x80000000
-    bne     1f
-
-    mov     r0, r4                      @ recover arg
-    mov     r1, r5
-    mov     r3, #0xc3000000             @ minlong, as a double (high word)
-    add     r3, #0x00e00000             @  0xc3e00000
-    mov     r2, #0                      @ minlong, as a double (low word)
-    bl      __aeabi_dcmple              @ is arg <= minlong?
-    cmp     r0, #0                      @ nonzero == yes
-    movne   r0, #0                      @ return minlong (8000000000000000)
-    movne   r1, #0x80000000
-    bne     1f
-
-    mov     r0, r4                      @ recover arg
-    mov     r1, r5
-    mov     r2, r4                      @ compare against self
-    mov     r3, r5
-    bl      __aeabi_dcmpeq              @ is arg == self?
-    cmp     r0, #0                      @ zero == no
-    moveq   r1, #0                      @ return zero for NaN
-    beq     1f
-
-    mov     r0, r4                      @ recover arg
-    mov     r1, r5
-    bl      __aeabi_d2lz                @ convert double to long
-
-1:
-    add     sp, sp, #4
-    ldmfd   sp!, {r4, r5, pc}
-
-/* continuation for OP_MUL_LONG */
-
-.LOP_MUL_LONG_finish:
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r0, {r9-r10}                @ vAA/vAA+1<- r9/r10
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_SHL_LONG */
-
-.LOP_SHL_LONG_finish:
-    mov     r0, r0, asl r2              @  r0<- r0 << r2
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_SHR_LONG */
-
-.LOP_SHR_LONG_finish:
-    mov     r1, r1, asr r2              @  r1<- r1 >> r2
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_USHR_LONG */
-
-.LOP_USHR_LONG_finish:
-    mov     r1, r1, lsr r2              @  r1<- r1 >>> r2
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_SHL_LONG_2ADDR */
-
-.LOP_SHL_LONG_2ADDR_finish:
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_SHR_LONG_2ADDR */
-
-.LOP_SHR_LONG_2ADDR_finish:
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_USHR_LONG_2ADDR */
-
-.LOP_USHR_LONG_2ADDR_finish:
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_VOLATILE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_VOLATILE_finish:
-    @bl      common_squeak0
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    SMP_DMB                            @ acquiring load
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ fp[A]<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_VOLATILE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_VOLATILE_finish:
-    @bl      common_squeak0
-    mov     r1, rINST, lsr #8           @ r1<- A+
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    and     r1, r1, #15                 @ r1<- A
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[A]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SMP_DMB_ST                        @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    SMP_DMB
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_SGET_VOLATILE */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_VOLATILE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_VOLATILE_finish
-
-/* continuation for OP_SPUT_VOLATILE */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_VOLATILE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_VOLATILE_finish          @ resume
-
-/* continuation for OP_IGET_OBJECT_VOLATILE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_OBJECT_VOLATILE_finish:
-    @bl      common_squeak0
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    SMP_DMB                            @ acquiring load
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ fp[A]<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_WIDE_VOLATILE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_WIDE_VOLATILE_finish:
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    .if     1
-    add     r0, r9, r3                  @ r0<- address of field
-    bl      dvmQuasiAtomicRead64        @ r0/r1<- contents of field
-    .else
-    ldrd    r0, [r9, r3]                @ r0/r1<- obj.field (64-bit align ok)
-    .endif
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    and     r2, r2, #15                 @ r2<- A
-    add     r3, rFP, r2, lsl #2         @ r3<- &fp[A]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_WIDE_VOLATILE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_WIDE_VOLATILE_finish:
-    mov     r2, rINST, lsr #8           @ r2<- A+
-    cmp     r9, #0                      @ check object for null
-    and     r2, r2, #15                 @ r2<- A
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    add     r2, rFP, r2, lsl #2         @ r3<- &fp[A]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[A]
-    GET_INST_OPCODE(r10)                @ extract opcode from rINST
-    .if     1
-    add     r2, r9, r3                  @ r2<- target address
-    bl      dvmQuasiAtomicSwap64Sync    @ stores r0/r1 into addr r2
-    .else
-    strd    r0, [r9, r3]                @ obj.field (64 bits, aligned)<- r0/r1
-    .endif
-    GOTO_OPCODE(r10)                    @ jump to next instruction
-
-/* continuation for OP_SGET_WIDE_VOLATILE */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     *
-     * Returns StaticField pointer in r0.
-     */
-.LOP_SGET_WIDE_VOLATILE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r1<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_WIDE_VOLATILE_finish          @ resume
-
-/* continuation for OP_SPUT_WIDE_VOLATILE */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r9:  &fp[AA]
-     *  r10: dvmDex->pResFields
-     *
-     * Returns StaticField pointer in r2.
-     */
-.LOP_SPUT_WIDE_VOLATILE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    mov     r2, r0                      @ copy to r2
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_WIDE_VOLATILE_finish          @ resume
-
-/* continuation for OP_EXECUTE_INLINE */
-
-    /*
-     * Extract args, call function.
-     *  r0 = #of args (0-4)
-     *  r10 = call index
-     *  lr = return addr, above  [DO NOT bl out of here w/o preserving LR]
-     *
-     * Other ideas:
-     * - Use a jump table from the main piece to jump directly into the
-     *   AND/LDR pairs.  Costs a data load, saves a branch.
-     * - Have five separate pieces that do the loading, so we can work the
-     *   interleave a little better.  Increases code size.
-     */
-.LOP_EXECUTE_INLINE_continue:
-    rsb     r0, r0, #4                  @ r0<- 4-r0
-    FETCH(rINST, 2)                     @ rINST<- FEDC
-    add     pc, pc, r0, lsl #3          @ computed goto, 2 instrs each
-    bl      common_abort                @ (skipped due to ARM prefetch)
-4:  and     ip, rINST, #0xf000          @ isolate F
-    ldr     r3, [rFP, ip, lsr #10]      @ r3<- vF (shift right 12, left 2)
-3:  and     ip, rINST, #0x0f00          @ isolate E
-    ldr     r2, [rFP, ip, lsr #6]       @ r2<- vE
-2:  and     ip, rINST, #0x00f0          @ isolate D
-    ldr     r1, [rFP, ip, lsr #2]       @ r1<- vD
-1:  and     ip, rINST, #0x000f          @ isolate C
-    ldr     r0, [rFP, ip, lsl #2]       @ r0<- vC
-0:
-    ldr     rINST, .LOP_EXECUTE_INLINE_table    @ table of InlineOperation
-    ldr     pc, [rINST, r10, lsl #4]    @ sizeof=16, "func" is first entry
-    @ (not reached)
-
-    /*
-     * We're debugging or profiling.
-     * r10: opIndex
-     */
-.LOP_EXECUTE_INLINE_debugmode:
-    mov     r0, r10
-    bl      dvmResolveInlineNative
-    cmp     r0, #0                      @ did it resolve?
-    beq     .LOP_EXECUTE_INLINE_resume          @ no, just move on
-    mov     r9, r0                      @ remember method
-    mov     r1, rSELF
-    bl      dvmFastMethodTraceEnter     @ (method, self)
-    add     r1, rSELF, #offThread_retval@ r1<- &self->retval
-    sub     sp, sp, #8                  @ make room for arg, +64 bit align
-    mov     r0, rINST, lsr #12          @ r0<- B
-    str     r1, [sp]                    @ push &self->retval
-    bl      .LOP_EXECUTE_INLINE_continue        @ make call; will return after
-    mov     rINST, r0                   @ save result of inline
-    add     sp, sp, #8                  @ pop stack
-    mov     r0, r9                      @ r0<- method
-    mov     r1, rSELF
-    bl      dvmFastNativeMethodTraceExit @ (method, self)
-    cmp     rINST, #0                   @ test boolean result of inline
-    beq     common_exceptionThrown      @ returned false, handle exception
-    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-
-
-
-.LOP_EXECUTE_INLINE_table:
-    .word   gDvmInlineOpsTable
-
-/* continuation for OP_EXECUTE_INLINE_RANGE */
-
-    /*
-     * Extract args, call function.
-     *  r0 = #of args (0-4)
-     *  r10 = call index
-     *  lr = return addr, above  [DO NOT bl out of here w/o preserving LR]
-     */
-.LOP_EXECUTE_INLINE_RANGE_continue:
-    rsb     r0, r0, #4                  @ r0<- 4-r0
-    FETCH(r9, 2)                        @ r9<- CCCC
-    add     pc, pc, r0, lsl #3          @ computed goto, 2 instrs each
-    bl      common_abort                @ (skipped due to ARM prefetch)
-4:  add     ip, r9, #3                  @ base+3
-    GET_VREG(r3, ip)                    @ r3<- vBase[3]
-3:  add     ip, r9, #2                  @ base+2
-    GET_VREG(r2, ip)                    @ r2<- vBase[2]
-2:  add     ip, r9, #1                  @ base+1
-    GET_VREG(r1, ip)                    @ r1<- vBase[1]
-1:  add     ip, r9, #0                  @ (nop)
-    GET_VREG(r0, ip)                    @ r0<- vBase[0]
-0:
-    ldr     r9, .LOP_EXECUTE_INLINE_RANGE_table       @ table of InlineOperation
-    ldr     pc, [r9, r10, lsl #4]       @ sizeof=16, "func" is first entry
-    @ (not reached)
-
-
-    /*
-     * We're debugging or profiling.
-     * r10: opIndex
-     */
-.LOP_EXECUTE_INLINE_RANGE_debugmode:
-    mov     r0, r10
-    bl      dvmResolveInlineNative
-    cmp     r0, #0                      @ did it resolve?
-    beq     .LOP_EXECUTE_INLINE_RANGE_resume          @ no, just move on
-    mov     r9, r0                      @ remember method
-    mov     r1, rSELF
-    bl      dvmFastMethodTraceEnter     @ (method, self)
-    add     r1, rSELF, #offThread_retval@ r1<- &self->retval
-    sub     sp, sp, #8                  @ make room for arg, +64 bit align
-    mov     r0, rINST, lsr #8           @ r0<- B
-    mov     rINST, r9                   @ rINST<- method
-    str     r1, [sp]                    @ push &self->retval
-    bl      .LOP_EXECUTE_INLINE_RANGE_continue        @ make call; will return after
-    mov     r9, r0                      @ save result of inline
-    add     sp, sp, #8                  @ pop stack
-    mov     r0, rINST                   @ r0<- method
-    mov     r1, rSELF
-    bl      dvmFastNativeMethodTraceExit  @ (method, self)
-    cmp     r9, #0                      @ test boolean result of inline
-    beq     common_exceptionThrown      @ returned false, handle exception
-    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-
-
-
-.LOP_EXECUTE_INLINE_RANGE_table:
-    .word   gDvmInlineOpsTable
-
-
-/* continuation for OP_INVOKE_OBJECT_INIT_RANGE */
-
-.LOP_INVOKE_OBJECT_INIT_RANGE_setFinal:
-    EXPORT_PC()                         @ can throw
-    bl      dvmSetFinalizable           @ call dvmSetFinalizable(obj)
-    ldr     r0, [rSELF, #offThread_exception] @ r0<- self->exception
-    cmp     r0, #0                      @ exception pending?
-    bne     common_exceptionThrown      @ yes, handle it
-    b       .LOP_INVOKE_OBJECT_INIT_RANGE_finish
-
-    /*
-     * A debugger is attached, so we need to go ahead and do
-     * this.  For simplicity, we'll just jump directly to the
-     * corresponding handler.  Note that we can't use
-     * rIBASE here because it may be in single-step mode.
-     * Load the primary table base directly.
-     */
-.LOP_INVOKE_OBJECT_INIT_RANGE_debugger:
-    ldr     r1, [rSELF, #offThread_mainHandlerTable]
-    .if 0
-    mov     ip, #OP_INVOKE_DIRECT_JUMBO
-    .else
-    mov     ip, #OP_INVOKE_DIRECT_RANGE
-    .endif
-    GOTO_OPCODE_BASE(r1,ip)             @ execute it
-
-/* continuation for OP_IPUT_OBJECT_VOLATILE */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_OBJECT_VOLATILE_finish:
-    @bl      common_squeak0
-    mov     r1, rINST, lsr #8           @ r1<- A+
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    and     r1, r1, #15                 @ r1<- A
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[A]
-    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SMP_DMB_ST                        @ releasing store
-    str     r0, [r9, r3]                @ obj.field (32 bits)<- r0
-    SMP_DMB
-    cmp     r0, #0                      @ stored a null reference?
-    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card if not
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_SGET_OBJECT_VOLATILE */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  BBBB field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_OBJECT_VOLATILE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_OBJECT_VOLATILE_finish
-
-/* continuation for OP_SPUT_OBJECT_VOLATILE */
-
-
-.LOP_SPUT_OBJECT_VOLATILE_end:
-    str     r1, [r0, #offStaticField_value]  @ field<- vAA
-    SMP_DMB
-    cmp     r1, #0                      @ stored a null object?
-    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card based on obj head
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /* Continuation if the field has not yet been resolved.
-     * r1:  BBBB field ref
-     * r10: dvmDex->pResFields
-     */
-.LOP_SPUT_OBJECT_VOLATILE_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_OBJECT_VOLATILE_finish          @ resume
-
-
-/* continuation for OP_CONST_CLASS_JUMBO */
-
-    /*
-     * Continuation if the Class has not yet been resolved.
-     *  r1: AAAAAAAA (Class ref)
-     *  r9: target register
-     */
-.LOP_CONST_CLASS_JUMBO_resolve:
-    EXPORT_PC()
-    ldr     r0, [rSELF, #offThread_method] @ r0<- self->method
-    mov     r2, #1                      @ r2<- true
-    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- Class reference
-    cmp     r0, #0                      @ failed?
-    beq     common_exceptionThrown      @ yup, handle the exception
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r9)                    @ vBBBB<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_CHECK_CAST_JUMBO */
-
-    /*
-     * Trivial test failed, need to perform full check.  This is common.
-     *  r0 holds obj->clazz
-     *  r1 holds desired class resolved from AAAAAAAA
-     *  r9 holds object
-     */
-.LOP_CHECK_CAST_JUMBO_fullcheck:
-    mov     r10, r1                     @ avoid ClassObject getting clobbered
-    bl      dvmInstanceofNonTrivial     @ r0<- boolean result
-    cmp     r0, #0                      @ failed?
-    bne     .LOP_CHECK_CAST_JUMBO_okay            @ no, success
-
-    @ A cast has failed.  We need to throw a ClassCastException.
-    EXPORT_PC()                         @ about to throw
-    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz (actual class)
-    mov     r1, r10                     @ r1<- desired class
-    bl      dvmThrowClassCastException
-    b       common_exceptionThrown
-
-    /*
-     * Advance PC and get the next opcode.
-     */
-.LOP_CHECK_CAST_JUMBO_okay:
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /*
-     * Resolution required.  This is the least-likely path.
-     *
-     *  r2 holds AAAAAAAA
-     *  r9 holds object
-     */
-.LOP_CHECK_CAST_JUMBO_resolve:
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    mov     r1, r2                      @ r1<- AAAAAAAA
-    mov     r2, #0                      @ r2<- false
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
-    cmp     r0, #0                      @ got null?
-    beq     common_exceptionThrown      @ yes, handle exception
-    mov     r1, r0                      @ r1<- class resolved from AAAAAAAA
-    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz
-    b       .LOP_CHECK_CAST_JUMBO_resolved        @ pick up where we left off
-
-/* continuation for OP_INSTANCE_OF_JUMBO */
-
-    /*
-     * Class resolved, determine type of check necessary.  This is common.
-     *  r0 holds obj->clazz
-     *  r1 holds class resolved from AAAAAAAA
-     *  r9 holds BBBB
-     */
-.LOP_INSTANCE_OF_JUMBO_resolved:
-    cmp     r0, r1                      @ same class (trivial success)?
-    beq     .LOP_INSTANCE_OF_JUMBO_trivial         @ yes, trivial finish
-    @ fall through to OP_INSTANCE_OF_JUMBO_fullcheck
-
-    /*
-     * Trivial test failed, need to perform full check.  This is common.
-     *  r0 holds obj->clazz
-     *  r1 holds class resolved from AAAAAAAA
-     *  r9 holds BBBB
-     */
-.LOP_INSTANCE_OF_JUMBO_fullcheck:
-    bl      dvmInstanceofNonTrivial     @ r0<- boolean result
-    @ fall through to OP_INSTANCE_OF_JUMBO_store
-
-    /*
-     * r0 holds boolean result
-     * r9 holds BBBB
-     */
-.LOP_INSTANCE_OF_JUMBO_store:
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r9)                    @ vBBBB<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /*
-     * Trivial test succeeded, save and bail.
-     *  r9 holds BBBB
-     */
-.LOP_INSTANCE_OF_JUMBO_trivial:
-    mov     r0, #1                      @ indicate success
-    @ could b OP_INSTANCE_OF_JUMBO_store, but copying is faster and cheaper
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r9)                    @ vBBBB<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /*
-     * Resolution required.  This is the least-likely path.
-     *
-     *  r3 holds AAAAAAAA
-     *  r9 holds BBBB
-     */
-
-.LOP_INSTANCE_OF_JUMBO_resolve:
-    EXPORT_PC()                         @ resolve() could throw
-    ldr     r0, [rSELF, #offThread_method]    @ r0<- self->method
-    mov     r1, r3                      @ r1<- AAAAAAAA
-    mov     r2, #1                      @ r2<- true
-    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
-    cmp     r0, #0                      @ got null?
-    beq     common_exceptionThrown      @ yes, handle exception
-    FETCH(r3, 4)                        @ r3<- vCCCC
-    mov     r1, r0                      @ r1<- class resolved from AAAAAAAA
-    GET_VREG(r0, r3)                    @ r0<- vCCCC (object)
-    ldr     r0, [r0, #offObject_clazz]  @ r0<- obj->clazz
-    b       .LOP_INSTANCE_OF_JUMBO_resolved        @ pick up where we left off
-
-/* continuation for OP_NEW_INSTANCE_JUMBO */
-
-    .balign 32                          @ minimize cache lines
-.LOP_NEW_INSTANCE_JUMBO_finish: @ r0=new object
-    FETCH(r3, 3)                        @ r3<- BBBB
-    cmp     r0, #0                      @ failed?
-#if defined(WITH_JIT)
-    /*
-     * The JIT needs the class to be fully resolved before it can
-     * include this instruction in a trace.
-     */
-    ldrh    r1, [rSELF, #offThread_subMode]
-    beq     common_exceptionThrown      @ yes, handle the exception
-    ands    r1, #kSubModeJitTraceBuild  @ under construction?
-    bne     .LOP_NEW_INSTANCE_JUMBO_jitCheck
-#else
-    beq     common_exceptionThrown      @ yes, handle the exception
-#endif
-.LOP_NEW_INSTANCE_JUMBO_end:
-    FETCH_ADVANCE_INST(4)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r3)                    @ vBBBB<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-#if defined(WITH_JIT)
-    /*
-     * Check to see if we need to stop the trace building early.
-     * r0: new object
-     * r3: vAA
-     */
-.LOP_NEW_INSTANCE_JUMBO_jitCheck:
-    ldr     r1, [r10]                   @ reload resolved class
-    cmp     r1, #0                      @ okay?
-    bne     .LOP_NEW_INSTANCE_JUMBO_end             @ yes, finish
-    mov     r9, r0                      @ preserve new object
-    mov     r10, r3                     @ preserve vAA
-    mov     r0, rSELF
-    mov     r1, rPC
-    bl      dvmJitEndTraceSelect        @ (self, pc)
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r9, r10)                   @ vAA<- new object
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-#endif
-
-    /*
-     * Class initialization required.
-     *
-     *  r0 holds class object
-     */
-.LOP_NEW_INSTANCE_JUMBO_needinit:
-    mov     r9, r0                      @ save r0
-    bl      dvmInitClass                @ initialize class
-    cmp     r0, #0                      @ check boolean result
-    mov     r0, r9                      @ restore r0
-    bne     .LOP_NEW_INSTANCE_JUMBO_initialized     @ success, continue
-    b       common_exceptionThrown      @ failed, deal with init exception
-
-    /*
-     * Resolution required.  This is the least-likely path.
-     *
-     *  r1 holds AAAAAAAA
-     */
-.LOP_NEW_INSTANCE_JUMBO_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    mov     r2, #0                      @ r2<- false
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_NEW_INSTANCE_JUMBO_resolved        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-/* continuation for OP_NEW_ARRAY_JUMBO */
-
-
-    /*
-     * Resolve class.  (This is an uncommon case.)
-     *
-     *  r1 holds array length
-     *  r2 holds class ref AAAAAAAA
-     */
-.LOP_NEW_ARRAY_JUMBO_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    mov     r9, r1                      @ r9<- length (save)
-    mov     r1, r2                      @ r1<- AAAAAAAA
-    mov     r2, #0                      @ r2<- false
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveClass             @ r0<- call(clazz, ref)
-    cmp     r0, #0                      @ got null?
-    mov     r1, r9                      @ r1<- length (restore)
-    beq     common_exceptionThrown      @ yes, handle exception
-    @ fall through to OP_NEW_ARRAY_JUMBO_finish
-
-    /*
-     * Finish allocation.
-     *
-     *  r0 holds class
-     *  r1 holds array length
-     */
-.LOP_NEW_ARRAY_JUMBO_finish:
-    mov     r2, #ALLOC_DONT_TRACK       @ don't track in local refs table
-    bl      dvmAllocArrayByClass        @ r0<- call(clazz, length, flags)
-    cmp     r0, #0                      @ failed?
-    FETCH(r2, 3)                        @ r2<- vBBBB
-    beq     common_exceptionThrown      @ yes, handle the exception
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SET_VREG(r0, r2)                    @ vBBBB<- r0
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_FILLED_NEW_ARRAY_JUMBO */
-
-    /*
-     * On entry:
-     *  r0 holds array class
-     */
-.LOP_FILLED_NEW_ARRAY_JUMBO_continue:
-    ldr     r3, [r0, #offClassObject_descriptor] @ r3<- arrayClass->descriptor
-    mov     r2, #ALLOC_DONT_TRACK       @ r2<- alloc flags
-    ldrb    rINST, [r3, #1]             @ rINST<- descriptor[1]
-    FETCH(r1, 3)                        @ r1<- BBBB (length)
-    cmp     rINST, #'I'                 @ array of ints?
-    cmpne   rINST, #'L'                 @ array of objects?
-    cmpne   rINST, #'['                 @ array of arrays?
-    mov     r9, r1                      @ save length in r9
-    bne     .LOP_FILLED_NEW_ARRAY_JUMBO_notimpl         @ no, not handled yet
-    bl      dvmAllocArrayByClass        @ r0<- call(arClass, length, flags)
-    cmp     r0, #0                      @ null return?
-    beq     common_exceptionThrown      @ alloc failed, handle exception
-
-    FETCH(r1, 4)                        @ r1<- CCCC
-    str     r0, [rSELF, #offThread_retval]      @ retval.l <- new array
-    str     rINST, [rSELF, #offThread_retval+4] @ retval.h <- type
-    add     r0, r0, #offArrayObject_contents @ r0<- newArray->contents
-    subs    r9, r9, #1                  @ length--, check for neg
-    FETCH_ADVANCE_INST(5)               @ advance to next instr, load rINST
-    bmi     2f                          @ was zero, bail
-
-    @ copy values from registers into the array
-    @ r0=array, r1=CCCC, r9=BBBB (length)
-    add     r2, rFP, r1, lsl #2         @ r2<- &fp[CCCC]
-1:  ldr     r3, [r2], #4                @ r3<- *r2++
-    subs    r9, r9, #1                  @ count--
-    str     r3, [r0], #4                @ *contents++ = vX
-    bpl     1b
-
-2:  ldr     r0, [rSELF, #offThread_retval]     @ r0<- object
-    ldr     r1, [rSELF, #offThread_retval+4]   @ r1<- type
-    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
-    GET_INST_OPCODE(ip)                      @ ip<- opcode from rINST
-    cmp     r1, #'I'                         @ Is int array?
-    strneb  r2, [r2, r0, lsr #GC_CARD_SHIFT] @ Mark card based on object head
-    GOTO_OPCODE(ip)                          @ execute it
-
-    /*
-     * Throw an exception indicating that we have not implemented this
-     * mode of filled-new-array.
-     */
-.LOP_FILLED_NEW_ARRAY_JUMBO_notimpl:
-    ldr     r0, .L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY_JUMBO
-    bl      dvmThrowInternalError
-    b       common_exceptionThrown
-
-    /*
-     * Ideally we'd only define this once, but depending on layout we can
-     * exceed the range of the load above.
-     */
-
-.L_strFilledNewArrayNotImpl_OP_FILLED_NEW_ARRAY_JUMBO:
-    .word   .LstrFilledNewArrayNotImpl
-
-/* continuation for OP_IGET_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_JUMBO_finish:
-    @bl      common_squeak0
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r2)                    @ fp[BBBB]<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_WIDE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_WIDE_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_WIDE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_WIDE_JUMBO_finish:
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    .if     0
-    add     r0, r9, r3                  @ r0<- address of field
-    bl      dvmQuasiAtomicRead64        @ r0/r1<- contents of field
-    .else
-    ldrd    r0, [r9, r3]                @ r0/r1<- obj.field (64-bit align ok)
-    .endif
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    add     r3, rFP, r2, lsl #2         @ r3<- &fp[BBBB]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ fp[BBBB]<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_OBJECT_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_OBJECT_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_OBJECT_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_OBJECT_JUMBO_finish:
-    @bl      common_squeak0
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r2)                    @ fp[BBBB]<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_BOOLEAN_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_BOOLEAN_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_BOOLEAN_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_BOOLEAN_JUMBO_finish:
-    @bl      common_squeak1
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r2)                    @ fp[BBBB]<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_BYTE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_BYTE_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_BYTE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_BYTE_JUMBO_finish:
-    @bl      common_squeak2
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r2)                    @ fp[BBBB]<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_CHAR_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_CHAR_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_CHAR_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_CHAR_JUMBO_finish:
-    @bl      common_squeak3
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r2)                    @ fp[BBBB]<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_SHORT_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_SHORT_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_SHORT_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_SHORT_JUMBO_finish:
-    @bl      common_squeak4
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r2)                    @ fp[BBBB]<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_JUMBO_finish:
-    @bl      common_squeak0
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    FETCH(r1, 3)                        @ r1<- BBBB
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[BBBB]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                          @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_WIDE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_WIDE_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_WIDE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_WIDE_JUMBO_finish:
-    cmp     r9, #0                      @ check object for null
-    FETCH(r2, 3)                        @ r1<- BBBB
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    add     r2, rFP, r2, lsl #2         @ r3<- &fp[BBBB]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[BBBB]
-    GET_INST_OPCODE(r10)                @ extract opcode from rINST
-    .if     0
-    add     r2, r9, r3                  @ r2<- target address
-    bl      dvmQuasiAtomicSwap64Sync    @ stores r0/r1 into addr r2
-    .else
-    strd    r0, [r9, r3]                @ obj.field (64 bits, aligned)<- r0/r1
-    .endif
-    GOTO_OPCODE(r10)                    @ jump to next instruction
-
-/* continuation for OP_IPUT_OBJECT_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_OBJECT_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_OBJECT_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_OBJECT_JUMBO_finish:
-    @bl      common_squeak0
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    FETCH(r1, 3)                        @ r1<- BBBB
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[BBBB]
-    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                         @ releasing store
-    str     r0, [r9, r3]                @ obj.field (32 bits)<- r0
-    @ no-op 
-    cmp     r0, #0                      @ stored a null reference?
-    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card if not
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_BOOLEAN_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_BOOLEAN_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_BOOLEAN_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_BOOLEAN_JUMBO_finish:
-    @bl      common_squeak1
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    FETCH(r1, 3)                        @ r1<- BBBB
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[BBBB]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                          @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_BYTE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_BYTE_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_BYTE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_BYTE_JUMBO_finish:
-    @bl      common_squeak2
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    FETCH(r1, 3)                        @ r1<- BBBB
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[BBBB]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                          @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_CHAR_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_CHAR_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_CHAR_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_CHAR_JUMBO_finish:
-    @bl      common_squeak3
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    FETCH(r1, 3)                        @ r1<- BBBB
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[BBBB]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                          @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_SHORT_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_SHORT_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_SHORT_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_SHORT_JUMBO_finish:
-    @bl      common_squeak4
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    FETCH(r1, 3)                        @ r1<- BBBB
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[BBBB]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                          @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    @ no-op 
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_SGET_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_JUMBO_finish          @ resume
-
-/* continuation for OP_SGET_WIDE_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1: AAAAAAAA field ref
-     *
-     * Returns StaticField pointer in r0.
-     */
-.LOP_SGET_WIDE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    bne     .LOP_SGET_WIDE_JUMBO_finish          @ yes, finish
-    b       common_exceptionThrown      @ no, handle exception
-
-/* continuation for OP_SGET_OBJECT_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_OBJECT_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_OBJECT_JUMBO_finish          @ resume
-
-/* continuation for OP_SGET_BOOLEAN_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_BOOLEAN_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_BOOLEAN_JUMBO_finish          @ resume
-
-/* continuation for OP_SGET_BYTE_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_BYTE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_BYTE_JUMBO_finish          @ resume
-
-/* continuation for OP_SGET_CHAR_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_CHAR_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_CHAR_JUMBO_finish          @ resume
-
-/* continuation for OP_SGET_SHORT_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_SHORT_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_SHORT_JUMBO_finish          @ resume
-
-/* continuation for OP_SPUT_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_JUMBO_finish          @ resume
-
-/* continuation for OP_SPUT_WIDE_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r9:  &fp[BBBB]
-     *  r10: dvmDex->pResFields
-     *
-     * Returns StaticField pointer in r2.
-     */
-.LOP_SPUT_WIDE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    mov     r2, r0                      @ copy to r2
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_WIDE_JUMBO_finish          @ resume
-
-/* continuation for OP_SPUT_OBJECT_JUMBO */
-
-
-.LOP_SPUT_OBJECT_JUMBO_end:
-    str     r1, [r0, #offStaticField_value]  @ field<- vBBBB
-    @ no-op 
-    cmp     r1, #0                      @ stored a null object?
-    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card based on obj head
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /* Continuation if the field has not yet been resolved.
-     * r1:  AAAAaaaa field ref
-     * r10: dvmDex->pResFields
-     */
-.LOP_SPUT_OBJECT_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r9<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_OBJECT_JUMBO_finish          @ resume
-
-
-/* continuation for OP_SPUT_BOOLEAN_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_BOOLEAN_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_BOOLEAN_JUMBO_finish          @ resume
-
-/* continuation for OP_SPUT_BYTE_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_BYTE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_BYTE_JUMBO_finish          @ resume
-
-/* continuation for OP_SPUT_CHAR_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_CHAR_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_CHAR_JUMBO_finish          @ resume
-
-/* continuation for OP_SPUT_SHORT_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_SHORT_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_SHORT_JUMBO_finish          @ resume
-
-/* continuation for OP_INVOKE_VIRTUAL_JUMBO */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     */
-.LOP_INVOKE_VIRTUAL_JUMBO_continue:
-    FETCH(r10, 4)                       @ r10<- CCCC
-    GET_VREG(r9, r10)                   @ r9<- "this" ptr
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    cmp     r9, #0                      @ is "this" null?
-    beq     common_errNullObject        @ null "this", throw exception
-    ldr     r3, [r9, #offObject_clazz]  @ r3<- thisPtr->clazz
-    ldr     r3, [r3, #offClassObject_vtable]    @ r3<- thisPtr->clazz->vtable
-    ldr     r0, [r3, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodJumbo    @ (r0=method, r9="this")
-
-/* continuation for OP_INVOKE_SUPER_JUMBO */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r10 = method->clazz
-     */
-.LOP_INVOKE_SUPER_JUMBO_continue:
-    ldr     r1, [r10, #offClassObject_super]    @ r1<- method->clazz->super
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    ldr     r3, [r1, #offClassObject_vtableCount]   @ r3<- super->vtableCount
-    EXPORT_PC()                         @ must export for invoke
-    cmp     r2, r3                      @ compare (methodIndex, vtableCount)
-    bcs     .LOP_INVOKE_SUPER_JUMBO_nsm             @ method not present in superclass
-    ldr     r1, [r1, #offClassObject_vtable]    @ r1<- ...clazz->super->vtable
-    ldr     r0, [r1, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodJumbo    @ (r0=method, r9="this")
-
-.LOP_INVOKE_SUPER_JUMBO_resolve:
-    mov     r0, r10                     @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_SUPER_JUMBO_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-    /*
-     * Throw a NoSuchMethodError with the method name as the message.
-     *  r0 = resolved base method
-     */
-.LOP_INVOKE_SUPER_JUMBO_nsm:
-    ldr     r1, [r0, #offMethod_name]   @ r1<- method name
-    b       common_errNoSuchMethod
-
-/* continuation for OP_INVOKE_DIRECT_JUMBO */
-
-    /*
-     * On entry:
-     *  r1 = reference (CCCC)
-     *  r10 = "this" register
-     */
-.LOP_INVOKE_DIRECT_JUMBO_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_DIRECT          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_DIRECT_JUMBO_finish          @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-/* continuation for OP_INVOKE_STATIC_JUMBO */
-
-
-.LOP_INVOKE_STATIC_JUMBO_resolve:
-    ldr     r3, [rSELF, #offThread_method] @ r3<- self->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_STATIC          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-#if defined(WITH_JIT)
-    /*
-     * Check to see if we're actively building a trace.  If so,
-     * we need to keep this instruction out of it.
-     * r10: &resolved_methodToCall
-     */
-    ldrh    r2, [rSELF, #offThread_subMode]
-    beq     common_exceptionThrown            @ null, handle exception
-    ands    r2, #kSubModeJitTraceBuild        @ trace under construction?
-    beq     common_invokeMethodJumboNoThis    @ no (r0=method, r9="this")
-    ldr     r1, [r10]                         @ reload resolved method
-    cmp     r1, #0                            @ finished resolving?
-    bne     common_invokeMethodJumboNoThis    @ yes (r0=method, r9="this")
-    mov     r10, r0                           @ preserve method
-    mov     r0, rSELF
-    mov     r1, rPC
-    bl      dvmJitEndTraceSelect              @ (self, pc)
-    mov     r0, r10
-    b       common_invokeMethodJumboNoThis    @ whew, finally!
-#else
-    bne     common_invokeMethodJumboNoThis    @ (r0=method, r9="this")
-    b       common_exceptionThrown            @ yes, handle exception
-#endif
-
-/* continuation for OP_INVOKE_OBJECT_INIT_JUMBO */
-
-.LOP_INVOKE_OBJECT_INIT_JUMBO_setFinal:
-    EXPORT_PC()                         @ can throw
-    bl      dvmSetFinalizable           @ call dvmSetFinalizable(obj)
-    ldr     r0, [rSELF, #offThread_exception] @ r0<- self->exception
-    cmp     r0, #0                      @ exception pending?
-    bne     common_exceptionThrown      @ yes, handle it
-    b       .LOP_INVOKE_OBJECT_INIT_JUMBO_finish
-
-    /*
-     * A debugger is attached, so we need to go ahead and do
-     * this.  For simplicity, we'll just jump directly to the
-     * corresponding handler.  Note that we can't use
-     * rIBASE here because it may be in single-step mode.
-     * Load the primary table base directly.
-     */
-.LOP_INVOKE_OBJECT_INIT_JUMBO_debugger:
-    ldr     r1, [rSELF, #offThread_mainHandlerTable]
-    .if 1
-    mov     ip, #OP_INVOKE_DIRECT_JUMBO
-    .else
-    mov     ip, #OP_INVOKE_DIRECT_RANGE
-    .endif
-    GOTO_OPCODE_BASE(r1,ip)             @ execute it
-
-/* continuation for OP_IGET_VOLATILE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_VOLATILE_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_VOLATILE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_VOLATILE_JUMBO_finish:
-    @bl      common_squeak0
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    SMP_DMB                            @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r2)                    @ fp[BBBB]<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_WIDE_VOLATILE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_WIDE_VOLATILE_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_WIDE_VOLATILE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_WIDE_VOLATILE_JUMBO_finish:
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    .if     1
-    add     r0, r9, r3                  @ r0<- address of field
-    bl      dvmQuasiAtomicRead64        @ r0/r1<- contents of field
-    .else
-    ldrd    r0, [r9, r3]                @ r0/r1<- obj.field (64-bit align ok)
-    .endif
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    add     r3, rFP, r2, lsl #2         @ r3<- &fp[BBBB]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ fp[BBBB]<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IGET_OBJECT_VOLATILE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_OBJECT_VOLATILE_JUMBO_resolved:
-    cmp     r0, #0                      @ resolution unsuccessful?
-    beq     common_exceptionThrown      @ yes, throw exception
-    @ fall through to OP_IGET_OBJECT_VOLATILE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IGET_OBJECT_VOLATILE_JUMBO_finish:
-    @bl      common_squeak0
-    cmp     r9, #0                      @ check object for null
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    beq     common_errNullObject        @ object was null
-    ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    SMP_DMB                            @ acquiring load
-    FETCH(r2, 3)                        @ r2<- BBBB
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    SET_VREG(r0, r2)                    @ fp[BBBB]<- r0
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_VOLATILE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_VOLATILE_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_VOLATILE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_VOLATILE_JUMBO_finish:
-    @bl      common_squeak0
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    FETCH(r1, 3)                        @ r1<- BBBB
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[BBBB]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SMP_DMB_ST                         @ releasing store
-    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
-    SMP_DMB
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_IPUT_WIDE_VOLATILE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_WIDE_VOLATILE_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_WIDE_VOLATILE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_WIDE_VOLATILE_JUMBO_finish:
-    cmp     r9, #0                      @ check object for null
-    FETCH(r2, 3)                        @ r1<- BBBB
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    add     r2, rFP, r2, lsl #2         @ r3<- &fp[BBBB]
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[BBBB]
-    GET_INST_OPCODE(r10)                @ extract opcode from rINST
-    .if     1
-    add     r2, r9, r3                  @ r2<- target address
-    bl      dvmQuasiAtomicSwap64Sync    @ stores r0/r1 into addr r2
-    .else
-    strd    r0, [r9, r3]                @ obj.field (64 bits, aligned)<- r0/r1
-    .endif
-    GOTO_OPCODE(r10)                    @ jump to next instruction
-
-/* continuation for OP_IPUT_OBJECT_VOLATILE_JUMBO */
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_OBJECT_VOLATILE_JUMBO_resolved:
-     cmp     r0, #0                     @ resolution unsuccessful?
-     beq     common_exceptionThrown     @ yes, throw exception
-     @ fall through to OP_IPUT_OBJECT_VOLATILE_JUMBO_finish
-
-    /*
-     * Currently:
-     *  r0 holds resolved field
-     *  r9 holds object
-     */
-.LOP_IPUT_OBJECT_VOLATILE_JUMBO_finish:
-    @bl      common_squeak0
-    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    FETCH(r1, 3)                        @ r1<- BBBB
-    cmp     r9, #0                      @ check object for null
-    GET_VREG(r0, r1)                    @ r0<- fp[BBBB]
-    ldr     r2, [rSELF, #offThread_cardTable]  @ r2<- card table base
-    beq     common_errNullObject        @ object was null
-    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    SMP_DMB_ST                        @ releasing store
-    str     r0, [r9, r3]                @ obj.field (32 bits)<- r0
-    SMP_DMB
-    cmp     r0, #0                      @ stored a null reference?
-    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card if not
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/* continuation for OP_SGET_VOLATILE_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_VOLATILE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_VOLATILE_JUMBO_finish          @ resume
-
-/* continuation for OP_SGET_WIDE_VOLATILE_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1: AAAAAAAA field ref
-     *
-     * Returns StaticField pointer in r0.
-     */
-.LOP_SGET_WIDE_VOLATILE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    bne     .LOP_SGET_WIDE_VOLATILE_JUMBO_finish          @ yes, finish
-    b       common_exceptionThrown      @ no, handle exception
-
-/* continuation for OP_SGET_OBJECT_VOLATILE_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SGET_OBJECT_VOLATILE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SGET_OBJECT_VOLATILE_JUMBO_finish          @ resume
-
-/* continuation for OP_SPUT_VOLATILE_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r10: dvmDex->pResFields
-     */
-.LOP_SPUT_VOLATILE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_VOLATILE_JUMBO_finish          @ resume
-
-/* continuation for OP_SPUT_WIDE_VOLATILE_JUMBO */
-
-    /*
-     * Continuation if the field has not yet been resolved.
-     *  r1:  AAAAAAAA field ref
-     *  r9:  &fp[BBBB]
-     *  r10: dvmDex->pResFields
-     *
-     * Returns StaticField pointer in r2.
-     */
-.LOP_SPUT_WIDE_VOLATILE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    mov     r2, r0                      @ copy to r2
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_WIDE_VOLATILE_JUMBO_finish          @ resume
-
-/* continuation for OP_SPUT_OBJECT_VOLATILE_JUMBO */
-
-
-.LOP_SPUT_OBJECT_VOLATILE_JUMBO_end:
-    str     r1, [r0, #offStaticField_value]  @ field<- vBBBB
-    SMP_DMB
-    cmp     r1, #0                      @ stored a null object?
-    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card based on obj head
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-    /* Continuation if the field has not yet been resolved.
-     * r1:  AAAAaaaa field ref
-     * r10: dvmDex->pResFields
-     */
-.LOP_SPUT_OBJECT_VOLATILE_JUMBO_resolve:
-    ldr     r2, [rSELF, #offThread_method]    @ r9<- current method
-#if defined(WITH_JIT)
-    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
-#endif
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    beq     common_exceptionThrown      @ no, handle exception
-#if defined(WITH_JIT)
-    /*
-     * If the JIT is actively building a trace we need to make sure
-     * that the field is fully resolved before including this instruction.
-     */
-    bl      common_verifyField
-#endif
-    b       .LOP_SPUT_OBJECT_VOLATILE_JUMBO_finish          @ resume
-
-
-    .size   dvmAsmSisterStart, .-dvmAsmSisterStart
-    .global dvmAsmSisterEnd
-dvmAsmSisterEnd:
-
-
-    .global dvmAsmAltInstructionStart
-    .type   dvmAsmAltInstructionStart, %function
-    .text
-
-dvmAsmAltInstructionStart = .L_ALT_OP_NOP
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_NOP: /* 0x00 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (0 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE: /* 0x01 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (1 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_FROM16: /* 0x02 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (2 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_16: /* 0x03 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (3 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_WIDE: /* 0x04 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (4 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_WIDE_FROM16: /* 0x05 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (5 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_WIDE_16: /* 0x06 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (6 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_OBJECT: /* 0x07 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (7 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_OBJECT_FROM16: /* 0x08 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (8 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_OBJECT_16: /* 0x09 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (9 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_RESULT: /* 0x0a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (10 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_RESULT_WIDE: /* 0x0b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (11 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_RESULT_OBJECT: /* 0x0c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (12 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MOVE_EXCEPTION: /* 0x0d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (13 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_RETURN_VOID: /* 0x0e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (14 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_RETURN: /* 0x0f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (15 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_RETURN_WIDE: /* 0x10 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (16 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_RETURN_OBJECT: /* 0x11 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (17 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_4: /* 0x12 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (18 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_16: /* 0x13 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (19 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST: /* 0x14 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (20 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_HIGH16: /* 0x15 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (21 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_WIDE_16: /* 0x16 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (22 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_WIDE_32: /* 0x17 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (23 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_WIDE: /* 0x18 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (24 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_WIDE_HIGH16: /* 0x19 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (25 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_STRING: /* 0x1a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (26 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_STRING_JUMBO: /* 0x1b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (27 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CONST_CLASS: /* 0x1c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (28 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MONITOR_ENTER: /* 0x1d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (29 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MONITOR_EXIT: /* 0x1e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (30 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CHECK_CAST: /* 0x1f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (31 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INSTANCE_OF: /* 0x20 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (32 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ARRAY_LENGTH: /* 0x21 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (33 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_NEW_INSTANCE: /* 0x22 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (34 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_NEW_ARRAY: /* 0x23 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (35 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_FILLED_NEW_ARRAY: /* 0x24 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (36 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_FILLED_NEW_ARRAY_RANGE: /* 0x25 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (37 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_FILL_ARRAY_DATA: /* 0x26 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (38 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_THROW: /* 0x27 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (39 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_GOTO: /* 0x28 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (40 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_GOTO_16: /* 0x29 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (41 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_GOTO_32: /* 0x2a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (42 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_PACKED_SWITCH: /* 0x2b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (43 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPARSE_SWITCH: /* 0x2c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (44 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CMPL_FLOAT: /* 0x2d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (45 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CMPG_FLOAT: /* 0x2e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (46 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CMPL_DOUBLE: /* 0x2f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (47 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CMPG_DOUBLE: /* 0x30 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (48 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_CMP_LONG: /* 0x31 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (49 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_EQ: /* 0x32 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (50 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_NE: /* 0x33 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (51 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_LT: /* 0x34 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (52 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_GE: /* 0x35 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (53 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_GT: /* 0x36 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (54 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_LE: /* 0x37 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (55 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_EQZ: /* 0x38 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (56 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_NEZ: /* 0x39 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (57 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_LTZ: /* 0x3a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (58 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_GEZ: /* 0x3b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (59 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_GTZ: /* 0x3c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (60 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IF_LEZ: /* 0x3d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (61 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_UNUSED_3E: /* 0x3e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (62 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_UNUSED_3F: /* 0x3f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (63 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_UNUSED_40: /* 0x40 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (64 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_UNUSED_41: /* 0x41 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (65 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_UNUSED_42: /* 0x42 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (66 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_UNUSED_43: /* 0x43 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (67 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AGET: /* 0x44 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (68 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AGET_WIDE: /* 0x45 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (69 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AGET_OBJECT: /* 0x46 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (70 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AGET_BOOLEAN: /* 0x47 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (71 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AGET_BYTE: /* 0x48 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (72 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AGET_CHAR: /* 0x49 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (73 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AGET_SHORT: /* 0x4a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (74 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_APUT: /* 0x4b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (75 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_APUT_WIDE: /* 0x4c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (76 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_APUT_OBJECT: /* 0x4d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (77 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_APUT_BOOLEAN: /* 0x4e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (78 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_APUT_BYTE: /* 0x4f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (79 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_APUT_CHAR: /* 0x50 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (80 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_APUT_SHORT: /* 0x51 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (81 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET: /* 0x52 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (82 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_WIDE: /* 0x53 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (83 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_OBJECT: /* 0x54 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (84 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_BOOLEAN: /* 0x55 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (85 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_BYTE: /* 0x56 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (86 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_CHAR: /* 0x57 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (87 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_SHORT: /* 0x58 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (88 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT: /* 0x59 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (89 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_WIDE: /* 0x5a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (90 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_OBJECT: /* 0x5b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (91 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_BOOLEAN: /* 0x5c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (92 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_BYTE: /* 0x5d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (93 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_CHAR: /* 0x5e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (94 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_SHORT: /* 0x5f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (95 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET: /* 0x60 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (96 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET_WIDE: /* 0x61 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (97 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET_OBJECT: /* 0x62 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (98 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET_BOOLEAN: /* 0x63 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (99 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET_BYTE: /* 0x64 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (100 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET_CHAR: /* 0x65 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (101 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET_SHORT: /* 0x66 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (102 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT: /* 0x67 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (103 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT_WIDE: /* 0x68 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (104 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT_OBJECT: /* 0x69 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (105 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT_BOOLEAN: /* 0x6a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (106 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT_BYTE: /* 0x6b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (107 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT_CHAR: /* 0x6c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (108 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT_SHORT: /* 0x6d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (109 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_VIRTUAL: /* 0x6e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (110 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_SUPER: /* 0x6f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (111 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_DIRECT: /* 0x70 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (112 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_STATIC: /* 0x71 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (113 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_INTERFACE: /* 0x72 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (114 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_UNUSED_73: /* 0x73 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (115 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_VIRTUAL_RANGE: /* 0x74 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (116 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_SUPER_RANGE: /* 0x75 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (117 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_DIRECT_RANGE: /* 0x76 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (118 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_STATIC_RANGE: /* 0x77 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (119 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_INTERFACE_RANGE: /* 0x78 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (120 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_UNUSED_79: /* 0x79 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (121 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_UNUSED_7A: /* 0x7a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (122 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_NEG_INT: /* 0x7b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (123 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_NOT_INT: /* 0x7c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (124 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_NEG_LONG: /* 0x7d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (125 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_NOT_LONG: /* 0x7e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (126 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_NEG_FLOAT: /* 0x7f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (127 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_NEG_DOUBLE: /* 0x80 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (128 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INT_TO_LONG: /* 0x81 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (129 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INT_TO_FLOAT: /* 0x82 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (130 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INT_TO_DOUBLE: /* 0x83 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (131 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_LONG_TO_INT: /* 0x84 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (132 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_LONG_TO_FLOAT: /* 0x85 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (133 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_LONG_TO_DOUBLE: /* 0x86 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (134 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_FLOAT_TO_INT: /* 0x87 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (135 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_FLOAT_TO_LONG: /* 0x88 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (136 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_FLOAT_TO_DOUBLE: /* 0x89 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (137 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DOUBLE_TO_INT: /* 0x8a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (138 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DOUBLE_TO_LONG: /* 0x8b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (139 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DOUBLE_TO_FLOAT: /* 0x8c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (140 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INT_TO_BYTE: /* 0x8d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (141 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INT_TO_CHAR: /* 0x8e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (142 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INT_TO_SHORT: /* 0x8f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (143 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_INT: /* 0x90 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (144 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SUB_INT: /* 0x91 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (145 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_INT: /* 0x92 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (146 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_INT: /* 0x93 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (147 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_INT: /* 0x94 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (148 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AND_INT: /* 0x95 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (149 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_OR_INT: /* 0x96 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (150 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_XOR_INT: /* 0x97 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (151 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHL_INT: /* 0x98 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (152 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHR_INT: /* 0x99 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (153 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_USHR_INT: /* 0x9a */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (154 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_LONG: /* 0x9b */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (155 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SUB_LONG: /* 0x9c */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (156 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_LONG: /* 0x9d */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (157 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_LONG: /* 0x9e */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (158 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_LONG: /* 0x9f */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (159 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AND_LONG: /* 0xa0 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (160 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_OR_LONG: /* 0xa1 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (161 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_XOR_LONG: /* 0xa2 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (162 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHL_LONG: /* 0xa3 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (163 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHR_LONG: /* 0xa4 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (164 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_USHR_LONG: /* 0xa5 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (165 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_FLOAT: /* 0xa6 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (166 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SUB_FLOAT: /* 0xa7 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (167 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_FLOAT: /* 0xa8 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (168 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_FLOAT: /* 0xa9 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (169 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_FLOAT: /* 0xaa */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (170 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_DOUBLE: /* 0xab */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (171 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SUB_DOUBLE: /* 0xac */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (172 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_DOUBLE: /* 0xad */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (173 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_DOUBLE: /* 0xae */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (174 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_DOUBLE: /* 0xaf */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (175 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_INT_2ADDR: /* 0xb0 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (176 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SUB_INT_2ADDR: /* 0xb1 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (177 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_INT_2ADDR: /* 0xb2 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (178 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_INT_2ADDR: /* 0xb3 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (179 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_INT_2ADDR: /* 0xb4 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (180 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AND_INT_2ADDR: /* 0xb5 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (181 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_OR_INT_2ADDR: /* 0xb6 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (182 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_XOR_INT_2ADDR: /* 0xb7 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (183 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHL_INT_2ADDR: /* 0xb8 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (184 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHR_INT_2ADDR: /* 0xb9 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (185 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_USHR_INT_2ADDR: /* 0xba */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (186 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_LONG_2ADDR: /* 0xbb */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (187 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SUB_LONG_2ADDR: /* 0xbc */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (188 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_LONG_2ADDR: /* 0xbd */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (189 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_LONG_2ADDR: /* 0xbe */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (190 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_LONG_2ADDR: /* 0xbf */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (191 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AND_LONG_2ADDR: /* 0xc0 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (192 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_OR_LONG_2ADDR: /* 0xc1 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (193 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_XOR_LONG_2ADDR: /* 0xc2 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (194 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHL_LONG_2ADDR: /* 0xc3 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (195 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHR_LONG_2ADDR: /* 0xc4 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (196 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_USHR_LONG_2ADDR: /* 0xc5 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (197 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_FLOAT_2ADDR: /* 0xc6 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (198 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SUB_FLOAT_2ADDR: /* 0xc7 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (199 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_FLOAT_2ADDR: /* 0xc8 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (200 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_FLOAT_2ADDR: /* 0xc9 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (201 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_FLOAT_2ADDR: /* 0xca */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (202 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_DOUBLE_2ADDR: /* 0xcb */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (203 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SUB_DOUBLE_2ADDR: /* 0xcc */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (204 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_DOUBLE_2ADDR: /* 0xcd */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (205 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_DOUBLE_2ADDR: /* 0xce */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (206 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_DOUBLE_2ADDR: /* 0xcf */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (207 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_INT_LIT16: /* 0xd0 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (208 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_RSUB_INT: /* 0xd1 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (209 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_INT_LIT16: /* 0xd2 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (210 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_INT_LIT16: /* 0xd3 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (211 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_INT_LIT16: /* 0xd4 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (212 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AND_INT_LIT16: /* 0xd5 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (213 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_OR_INT_LIT16: /* 0xd6 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (214 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_XOR_INT_LIT16: /* 0xd7 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (215 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_ADD_INT_LIT8: /* 0xd8 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (216 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_RSUB_INT_LIT8: /* 0xd9 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (217 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_MUL_INT_LIT8: /* 0xda */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (218 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DIV_INT_LIT8: /* 0xdb */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (219 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_REM_INT_LIT8: /* 0xdc */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (220 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_AND_INT_LIT8: /* 0xdd */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (221 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_OR_INT_LIT8: /* 0xde */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (222 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_XOR_INT_LIT8: /* 0xdf */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (223 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHL_INT_LIT8: /* 0xe0 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (224 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SHR_INT_LIT8: /* 0xe1 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (225 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_USHR_INT_LIT8: /* 0xe2 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (226 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_VOLATILE: /* 0xe3 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (227 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_VOLATILE: /* 0xe4 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (228 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET_VOLATILE: /* 0xe5 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (229 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT_VOLATILE: /* 0xe6 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (230 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_OBJECT_VOLATILE: /* 0xe7 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (231 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_WIDE_VOLATILE: /* 0xe8 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (232 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_WIDE_VOLATILE: /* 0xe9 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (233 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET_WIDE_VOLATILE: /* 0xea */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (234 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT_WIDE_VOLATILE: /* 0xeb */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (235 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_BREAKPOINT: /* 0xec */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (236 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_THROW_VERIFICATION_ERROR: /* 0xed */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (237 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_EXECUTE_INLINE: /* 0xee */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (238 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_EXECUTE_INLINE_RANGE: /* 0xef */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (239 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_OBJECT_INIT_RANGE: /* 0xf0 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (240 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_RETURN_VOID_BARRIER: /* 0xf1 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (241 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_QUICK: /* 0xf2 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (242 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_WIDE_QUICK: /* 0xf3 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (243 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IGET_OBJECT_QUICK: /* 0xf4 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (244 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_QUICK: /* 0xf5 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (245 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_WIDE_QUICK: /* 0xf6 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (246 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
-
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_OBJECT_QUICK: /* 0xf7 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (247 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
+/* continuation for OP_SGET_OBJECT_VOLATILE */
 
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_VIRTUAL_QUICK: /* 0xf8 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (248 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1:  BBBB field ref
+     *  r10: dvmDex->pResFields
+     */
+.LOP_SGET_OBJECT_VOLATILE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SGET_OBJECT_VOLATILE_finish
 
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_VIRTUAL_QUICK_RANGE: /* 0xf9 */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (249 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
+/* continuation for OP_SPUT_OBJECT_VOLATILE */
 
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_SUPER_QUICK: /* 0xfa */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (250 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
 
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_INVOKE_SUPER_QUICK_RANGE: /* 0xfb */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (251 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
+.LOP_SPUT_OBJECT_VOLATILE_end:
+    str     r1, [r0, #offStaticField_value]  @ field<- vAA
+    SMP_DMB
+    cmp     r1, #0                      @ stored a null object?
+    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card based on obj head
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_IPUT_OBJECT_VOLATILE: /* 0xfc */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (252 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
+    /* Continuation if the field has not yet been resolved.
+     * r1:  BBBB field ref
+     * r10: dvmDex->pResFields
+     */
+.LOP_SPUT_OBJECT_VOLATILE_resolve:
+    ldr     r2, [rSELF, #offThread_method]    @ r2<- current method
+#if defined(WITH_JIT)
+    add     r10, r10, r1, lsl #2        @ r10<- &dvmDex->pResFields[field]
+#endif
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    beq     common_exceptionThrown      @ no, handle exception
+#if defined(WITH_JIT)
+    /*
+     * If the JIT is actively building a trace we need to make sure
+     * that the field is fully resolved before including this instruction.
+     */
+    bl      common_verifyField
+#endif
+    b       .LOP_SPUT_OBJECT_VOLATILE_finish          @ resume
 
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SGET_OBJECT_VOLATILE: /* 0xfd */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (253 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
 
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_SPUT_OBJECT_VOLATILE: /* 0xfe */
-/* File: armv5te/alt_stub.S */
-/*
- * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
- * any interesting requests and then jump to the real instruction
- * handler.    Note that the call to dvmCheckBefore is done as a tail call.
- * rIBASE updates won't be seen until a refresh, and we can tell we have a
- * stale rIBASE if breakFlags==0.  Always refresh rIBASE here, and then
- * bail to the real handler if breakFlags==0.
- */
-    ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (254 * 64)
-    ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
-    cmp    r3, #0
-    bxeq   lr                   @ nothing to do - jump to real handler
-    EXPORT_PC()
-    mov    r0, rPC              @ arg0
-    mov    r1, rFP              @ arg1
-    mov    r2, rSELF            @ arg2
-    b      dvmCheckBefore       @ (dPC,dFP,self) tail call
+    .size   dvmAsmSisterStart, .-dvmAsmSisterStart
+    .global dvmAsmSisterEnd
+dvmAsmSisterEnd:
 
-/* ------------------------------ */
-    .balign 64
-.L_ALT_OP_DISPATCH_FF: /* 0xff */
-/* File: armv5te/ALT_OP_DISPATCH_FF.S */
-/*
- * Unlike other alt stubs, we don't want to call dvmCheckBefore() here.
- * Instead, just treat this as a trampoline to reach the real alt
- * handler (which will do the dvmCheckBefore() call.
- */
-    mov     ip, rINST, lsr #8           @ ip<- extended opcode
-    add     ip, ip, #256                @ add offset for extended opcodes
-    GOTO_OPCODE(ip)                     @ go to proper extended handler
 
+    .global dvmAsmAltInstructionStart
+    .type   dvmAsmAltInstructionStart, %function
+    .text
 
+dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_CONST_CLASS_JUMBO: /* 0x100 */
+.L_ALT_OP_NOP: /* 0x00 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20804,7 +10219,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (256 * 64)
+    adrl   lr, dvmAsmInstructionStart + (0 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20816,7 +10231,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_CHECK_CAST_JUMBO: /* 0x101 */
+.L_ALT_OP_MOVE: /* 0x01 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20827,7 +10242,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (257 * 64)
+    adrl   lr, dvmAsmInstructionStart + (1 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20839,7 +10254,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_INSTANCE_OF_JUMBO: /* 0x102 */
+.L_ALT_OP_MOVE_FROM16: /* 0x02 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20850,7 +10265,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (258 * 64)
+    adrl   lr, dvmAsmInstructionStart + (2 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20862,7 +10277,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_NEW_INSTANCE_JUMBO: /* 0x103 */
+.L_ALT_OP_MOVE_16: /* 0x03 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20873,7 +10288,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (259 * 64)
+    adrl   lr, dvmAsmInstructionStart + (3 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20885,7 +10300,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_NEW_ARRAY_JUMBO: /* 0x104 */
+.L_ALT_OP_MOVE_WIDE: /* 0x04 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20896,7 +10311,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (260 * 64)
+    adrl   lr, dvmAsmInstructionStart + (4 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20908,7 +10323,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_FILLED_NEW_ARRAY_JUMBO: /* 0x105 */
+.L_ALT_OP_MOVE_WIDE_FROM16: /* 0x05 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20919,7 +10334,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (261 * 64)
+    adrl   lr, dvmAsmInstructionStart + (5 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20931,7 +10346,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_JUMBO: /* 0x106 */
+.L_ALT_OP_MOVE_WIDE_16: /* 0x06 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20942,7 +10357,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (262 * 64)
+    adrl   lr, dvmAsmInstructionStart + (6 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20954,7 +10369,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_WIDE_JUMBO: /* 0x107 */
+.L_ALT_OP_MOVE_OBJECT: /* 0x07 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20965,7 +10380,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (263 * 64)
+    adrl   lr, dvmAsmInstructionStart + (7 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -20977,7 +10392,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_OBJECT_JUMBO: /* 0x108 */
+.L_ALT_OP_MOVE_OBJECT_FROM16: /* 0x08 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -20988,7 +10403,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (264 * 64)
+    adrl   lr, dvmAsmInstructionStart + (8 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21000,7 +10415,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_BOOLEAN_JUMBO: /* 0x109 */
+.L_ALT_OP_MOVE_OBJECT_16: /* 0x09 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21011,7 +10426,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (265 * 64)
+    adrl   lr, dvmAsmInstructionStart + (9 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21023,7 +10438,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_BYTE_JUMBO: /* 0x10a */
+.L_ALT_OP_MOVE_RESULT: /* 0x0a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21034,7 +10449,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (266 * 64)
+    adrl   lr, dvmAsmInstructionStart + (10 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21046,7 +10461,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_CHAR_JUMBO: /* 0x10b */
+.L_ALT_OP_MOVE_RESULT_WIDE: /* 0x0b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21057,7 +10472,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (267 * 64)
+    adrl   lr, dvmAsmInstructionStart + (11 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21069,7 +10484,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_SHORT_JUMBO: /* 0x10c */
+.L_ALT_OP_MOVE_RESULT_OBJECT: /* 0x0c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21080,7 +10495,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (268 * 64)
+    adrl   lr, dvmAsmInstructionStart + (12 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21092,7 +10507,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_JUMBO: /* 0x10d */
+.L_ALT_OP_MOVE_EXCEPTION: /* 0x0d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21103,7 +10518,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (269 * 64)
+    adrl   lr, dvmAsmInstructionStart + (13 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21115,7 +10530,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_WIDE_JUMBO: /* 0x10e */
+.L_ALT_OP_RETURN_VOID: /* 0x0e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21126,7 +10541,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (270 * 64)
+    adrl   lr, dvmAsmInstructionStart + (14 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21138,7 +10553,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_OBJECT_JUMBO: /* 0x10f */
+.L_ALT_OP_RETURN: /* 0x0f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21149,7 +10564,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (271 * 64)
+    adrl   lr, dvmAsmInstructionStart + (15 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21161,7 +10576,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_BOOLEAN_JUMBO: /* 0x110 */
+.L_ALT_OP_RETURN_WIDE: /* 0x10 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21172,7 +10587,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (272 * 64)
+    adrl   lr, dvmAsmInstructionStart + (16 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21184,7 +10599,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_BYTE_JUMBO: /* 0x111 */
+.L_ALT_OP_RETURN_OBJECT: /* 0x11 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21195,7 +10610,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (273 * 64)
+    adrl   lr, dvmAsmInstructionStart + (17 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21207,7 +10622,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_CHAR_JUMBO: /* 0x112 */
+.L_ALT_OP_CONST_4: /* 0x12 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21218,7 +10633,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (274 * 64)
+    adrl   lr, dvmAsmInstructionStart + (18 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21230,7 +10645,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_SHORT_JUMBO: /* 0x113 */
+.L_ALT_OP_CONST_16: /* 0x13 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21241,7 +10656,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (275 * 64)
+    adrl   lr, dvmAsmInstructionStart + (19 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21253,7 +10668,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_JUMBO: /* 0x114 */
+.L_ALT_OP_CONST: /* 0x14 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21264,7 +10679,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (276 * 64)
+    adrl   lr, dvmAsmInstructionStart + (20 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21276,7 +10691,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_WIDE_JUMBO: /* 0x115 */
+.L_ALT_OP_CONST_HIGH16: /* 0x15 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21287,7 +10702,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (277 * 64)
+    adrl   lr, dvmAsmInstructionStart + (21 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21299,7 +10714,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_OBJECT_JUMBO: /* 0x116 */
+.L_ALT_OP_CONST_WIDE_16: /* 0x16 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21310,7 +10725,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (278 * 64)
+    adrl   lr, dvmAsmInstructionStart + (22 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21322,7 +10737,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_BOOLEAN_JUMBO: /* 0x117 */
+.L_ALT_OP_CONST_WIDE_32: /* 0x17 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21333,7 +10748,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (279 * 64)
+    adrl   lr, dvmAsmInstructionStart + (23 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21345,7 +10760,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_BYTE_JUMBO: /* 0x118 */
+.L_ALT_OP_CONST_WIDE: /* 0x18 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21356,7 +10771,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (280 * 64)
+    adrl   lr, dvmAsmInstructionStart + (24 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21368,7 +10783,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_CHAR_JUMBO: /* 0x119 */
+.L_ALT_OP_CONST_WIDE_HIGH16: /* 0x19 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21379,7 +10794,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (281 * 64)
+    adrl   lr, dvmAsmInstructionStart + (25 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21391,7 +10806,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_SHORT_JUMBO: /* 0x11a */
+.L_ALT_OP_CONST_STRING: /* 0x1a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21402,7 +10817,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (282 * 64)
+    adrl   lr, dvmAsmInstructionStart + (26 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21414,7 +10829,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_JUMBO: /* 0x11b */
+.L_ALT_OP_CONST_STRING_JUMBO: /* 0x1b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21425,7 +10840,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (283 * 64)
+    adrl   lr, dvmAsmInstructionStart + (27 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21437,7 +10852,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_WIDE_JUMBO: /* 0x11c */
+.L_ALT_OP_CONST_CLASS: /* 0x1c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21448,7 +10863,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (284 * 64)
+    adrl   lr, dvmAsmInstructionStart + (28 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21460,7 +10875,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_OBJECT_JUMBO: /* 0x11d */
+.L_ALT_OP_MONITOR_ENTER: /* 0x1d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21471,7 +10886,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (285 * 64)
+    adrl   lr, dvmAsmInstructionStart + (29 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21483,7 +10898,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_BOOLEAN_JUMBO: /* 0x11e */
+.L_ALT_OP_MONITOR_EXIT: /* 0x1e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21494,7 +10909,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (286 * 64)
+    adrl   lr, dvmAsmInstructionStart + (30 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21506,7 +10921,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_BYTE_JUMBO: /* 0x11f */
+.L_ALT_OP_CHECK_CAST: /* 0x1f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21517,7 +10932,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (287 * 64)
+    adrl   lr, dvmAsmInstructionStart + (31 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21529,7 +10944,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_CHAR_JUMBO: /* 0x120 */
+.L_ALT_OP_INSTANCE_OF: /* 0x20 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21540,7 +10955,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (288 * 64)
+    adrl   lr, dvmAsmInstructionStart + (32 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21552,7 +10967,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_SHORT_JUMBO: /* 0x121 */
+.L_ALT_OP_ARRAY_LENGTH: /* 0x21 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21563,7 +10978,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (289 * 64)
+    adrl   lr, dvmAsmInstructionStart + (33 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21575,7 +10990,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_INVOKE_VIRTUAL_JUMBO: /* 0x122 */
+.L_ALT_OP_NEW_INSTANCE: /* 0x22 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21586,7 +11001,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (290 * 64)
+    adrl   lr, dvmAsmInstructionStart + (34 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21598,7 +11013,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_INVOKE_SUPER_JUMBO: /* 0x123 */
+.L_ALT_OP_NEW_ARRAY: /* 0x23 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21609,7 +11024,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (291 * 64)
+    adrl   lr, dvmAsmInstructionStart + (35 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21621,7 +11036,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_INVOKE_DIRECT_JUMBO: /* 0x124 */
+.L_ALT_OP_FILLED_NEW_ARRAY: /* 0x24 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21632,7 +11047,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (292 * 64)
+    adrl   lr, dvmAsmInstructionStart + (36 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21644,7 +11059,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_INVOKE_STATIC_JUMBO: /* 0x125 */
+.L_ALT_OP_FILLED_NEW_ARRAY_RANGE: /* 0x25 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21655,7 +11070,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (293 * 64)
+    adrl   lr, dvmAsmInstructionStart + (37 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21667,7 +11082,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_INVOKE_INTERFACE_JUMBO: /* 0x126 */
+.L_ALT_OP_FILL_ARRAY_DATA: /* 0x26 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21678,7 +11093,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (294 * 64)
+    adrl   lr, dvmAsmInstructionStart + (38 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21690,7 +11105,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_27FF: /* 0x127 */
+.L_ALT_OP_THROW: /* 0x27 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21701,7 +11116,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (295 * 64)
+    adrl   lr, dvmAsmInstructionStart + (39 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21713,7 +11128,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_28FF: /* 0x128 */
+.L_ALT_OP_GOTO: /* 0x28 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21724,7 +11139,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (296 * 64)
+    adrl   lr, dvmAsmInstructionStart + (40 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21736,7 +11151,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_29FF: /* 0x129 */
+.L_ALT_OP_GOTO_16: /* 0x29 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21747,7 +11162,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (297 * 64)
+    adrl   lr, dvmAsmInstructionStart + (41 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21759,7 +11174,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_2AFF: /* 0x12a */
+.L_ALT_OP_GOTO_32: /* 0x2a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21770,7 +11185,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (298 * 64)
+    adrl   lr, dvmAsmInstructionStart + (42 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21782,7 +11197,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_2BFF: /* 0x12b */
+.L_ALT_OP_PACKED_SWITCH: /* 0x2b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21793,7 +11208,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (299 * 64)
+    adrl   lr, dvmAsmInstructionStart + (43 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21805,7 +11220,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_2CFF: /* 0x12c */
+.L_ALT_OP_SPARSE_SWITCH: /* 0x2c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21816,7 +11231,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (300 * 64)
+    adrl   lr, dvmAsmInstructionStart + (44 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21828,7 +11243,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_2DFF: /* 0x12d */
+.L_ALT_OP_CMPL_FLOAT: /* 0x2d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21839,7 +11254,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (301 * 64)
+    adrl   lr, dvmAsmInstructionStart + (45 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21851,7 +11266,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_2EFF: /* 0x12e */
+.L_ALT_OP_CMPG_FLOAT: /* 0x2e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21862,7 +11277,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (302 * 64)
+    adrl   lr, dvmAsmInstructionStart + (46 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21874,7 +11289,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_2FFF: /* 0x12f */
+.L_ALT_OP_CMPL_DOUBLE: /* 0x2f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21885,7 +11300,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (303 * 64)
+    adrl   lr, dvmAsmInstructionStart + (47 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21897,7 +11312,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_30FF: /* 0x130 */
+.L_ALT_OP_CMPG_DOUBLE: /* 0x30 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21908,7 +11323,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (304 * 64)
+    adrl   lr, dvmAsmInstructionStart + (48 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21920,7 +11335,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_31FF: /* 0x131 */
+.L_ALT_OP_CMP_LONG: /* 0x31 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21931,7 +11346,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (305 * 64)
+    adrl   lr, dvmAsmInstructionStart + (49 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21943,7 +11358,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_32FF: /* 0x132 */
+.L_ALT_OP_IF_EQ: /* 0x32 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21954,7 +11369,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (306 * 64)
+    adrl   lr, dvmAsmInstructionStart + (50 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21966,7 +11381,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_33FF: /* 0x133 */
+.L_ALT_OP_IF_NE: /* 0x33 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -21977,7 +11392,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (307 * 64)
+    adrl   lr, dvmAsmInstructionStart + (51 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -21989,7 +11404,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_34FF: /* 0x134 */
+.L_ALT_OP_IF_LT: /* 0x34 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22000,7 +11415,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (308 * 64)
+    adrl   lr, dvmAsmInstructionStart + (52 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22012,7 +11427,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_35FF: /* 0x135 */
+.L_ALT_OP_IF_GE: /* 0x35 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22023,7 +11438,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (309 * 64)
+    adrl   lr, dvmAsmInstructionStart + (53 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22035,7 +11450,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_36FF: /* 0x136 */
+.L_ALT_OP_IF_GT: /* 0x36 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22046,7 +11461,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (310 * 64)
+    adrl   lr, dvmAsmInstructionStart + (54 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22058,7 +11473,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_37FF: /* 0x137 */
+.L_ALT_OP_IF_LE: /* 0x37 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22069,7 +11484,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (311 * 64)
+    adrl   lr, dvmAsmInstructionStart + (55 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22081,7 +11496,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_38FF: /* 0x138 */
+.L_ALT_OP_IF_EQZ: /* 0x38 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22092,7 +11507,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (312 * 64)
+    adrl   lr, dvmAsmInstructionStart + (56 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22104,7 +11519,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_39FF: /* 0x139 */
+.L_ALT_OP_IF_NEZ: /* 0x39 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22115,7 +11530,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (313 * 64)
+    adrl   lr, dvmAsmInstructionStart + (57 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22127,7 +11542,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_3AFF: /* 0x13a */
+.L_ALT_OP_IF_LTZ: /* 0x3a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22138,7 +11553,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (314 * 64)
+    adrl   lr, dvmAsmInstructionStart + (58 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22150,7 +11565,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_3BFF: /* 0x13b */
+.L_ALT_OP_IF_GEZ: /* 0x3b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22161,7 +11576,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (315 * 64)
+    adrl   lr, dvmAsmInstructionStart + (59 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22173,7 +11588,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_3CFF: /* 0x13c */
+.L_ALT_OP_IF_GTZ: /* 0x3c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22184,7 +11599,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (316 * 64)
+    adrl   lr, dvmAsmInstructionStart + (60 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22196,7 +11611,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_3DFF: /* 0x13d */
+.L_ALT_OP_IF_LEZ: /* 0x3d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22207,7 +11622,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (317 * 64)
+    adrl   lr, dvmAsmInstructionStart + (61 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22219,7 +11634,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_3EFF: /* 0x13e */
+.L_ALT_OP_UNUSED_3E: /* 0x3e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22230,7 +11645,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (318 * 64)
+    adrl   lr, dvmAsmInstructionStart + (62 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22242,7 +11657,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_3FFF: /* 0x13f */
+.L_ALT_OP_UNUSED_3F: /* 0x3f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22253,7 +11668,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (319 * 64)
+    adrl   lr, dvmAsmInstructionStart + (63 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22265,7 +11680,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_40FF: /* 0x140 */
+.L_ALT_OP_UNUSED_40: /* 0x40 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22276,7 +11691,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (320 * 64)
+    adrl   lr, dvmAsmInstructionStart + (64 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22288,7 +11703,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_41FF: /* 0x141 */
+.L_ALT_OP_UNUSED_41: /* 0x41 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22299,7 +11714,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (321 * 64)
+    adrl   lr, dvmAsmInstructionStart + (65 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22311,7 +11726,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_42FF: /* 0x142 */
+.L_ALT_OP_UNUSED_42: /* 0x42 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22322,7 +11737,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (322 * 64)
+    adrl   lr, dvmAsmInstructionStart + (66 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22334,7 +11749,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_43FF: /* 0x143 */
+.L_ALT_OP_UNUSED_43: /* 0x43 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22345,7 +11760,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (323 * 64)
+    adrl   lr, dvmAsmInstructionStart + (67 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22357,7 +11772,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_44FF: /* 0x144 */
+.L_ALT_OP_AGET: /* 0x44 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22368,7 +11783,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (324 * 64)
+    adrl   lr, dvmAsmInstructionStart + (68 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22380,7 +11795,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_45FF: /* 0x145 */
+.L_ALT_OP_AGET_WIDE: /* 0x45 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22391,7 +11806,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (325 * 64)
+    adrl   lr, dvmAsmInstructionStart + (69 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22403,7 +11818,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_46FF: /* 0x146 */
+.L_ALT_OP_AGET_OBJECT: /* 0x46 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22414,7 +11829,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (326 * 64)
+    adrl   lr, dvmAsmInstructionStart + (70 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22426,7 +11841,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_47FF: /* 0x147 */
+.L_ALT_OP_AGET_BOOLEAN: /* 0x47 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22437,7 +11852,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (327 * 64)
+    adrl   lr, dvmAsmInstructionStart + (71 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22449,7 +11864,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_48FF: /* 0x148 */
+.L_ALT_OP_AGET_BYTE: /* 0x48 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22460,7 +11875,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (328 * 64)
+    adrl   lr, dvmAsmInstructionStart + (72 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22472,7 +11887,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_49FF: /* 0x149 */
+.L_ALT_OP_AGET_CHAR: /* 0x49 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22483,7 +11898,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (329 * 64)
+    adrl   lr, dvmAsmInstructionStart + (73 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22495,7 +11910,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_4AFF: /* 0x14a */
+.L_ALT_OP_AGET_SHORT: /* 0x4a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22506,7 +11921,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (330 * 64)
+    adrl   lr, dvmAsmInstructionStart + (74 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22518,7 +11933,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_4BFF: /* 0x14b */
+.L_ALT_OP_APUT: /* 0x4b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22529,7 +11944,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (331 * 64)
+    adrl   lr, dvmAsmInstructionStart + (75 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22541,7 +11956,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_4CFF: /* 0x14c */
+.L_ALT_OP_APUT_WIDE: /* 0x4c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22552,7 +11967,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (332 * 64)
+    adrl   lr, dvmAsmInstructionStart + (76 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22564,7 +11979,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_4DFF: /* 0x14d */
+.L_ALT_OP_APUT_OBJECT: /* 0x4d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22575,7 +11990,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (333 * 64)
+    adrl   lr, dvmAsmInstructionStart + (77 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22587,7 +12002,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_4EFF: /* 0x14e */
+.L_ALT_OP_APUT_BOOLEAN: /* 0x4e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22598,7 +12013,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (334 * 64)
+    adrl   lr, dvmAsmInstructionStart + (78 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22610,7 +12025,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_4FFF: /* 0x14f */
+.L_ALT_OP_APUT_BYTE: /* 0x4f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22621,7 +12036,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (335 * 64)
+    adrl   lr, dvmAsmInstructionStart + (79 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22633,7 +12048,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_50FF: /* 0x150 */
+.L_ALT_OP_APUT_CHAR: /* 0x50 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22644,7 +12059,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (336 * 64)
+    adrl   lr, dvmAsmInstructionStart + (80 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22656,7 +12071,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_51FF: /* 0x151 */
+.L_ALT_OP_APUT_SHORT: /* 0x51 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22667,7 +12082,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (337 * 64)
+    adrl   lr, dvmAsmInstructionStart + (81 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22679,7 +12094,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_52FF: /* 0x152 */
+.L_ALT_OP_IGET: /* 0x52 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22690,7 +12105,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (338 * 64)
+    adrl   lr, dvmAsmInstructionStart + (82 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22702,7 +12117,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_53FF: /* 0x153 */
+.L_ALT_OP_IGET_WIDE: /* 0x53 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22713,7 +12128,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (339 * 64)
+    adrl   lr, dvmAsmInstructionStart + (83 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22725,7 +12140,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_54FF: /* 0x154 */
+.L_ALT_OP_IGET_OBJECT: /* 0x54 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22736,7 +12151,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (340 * 64)
+    adrl   lr, dvmAsmInstructionStart + (84 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22748,7 +12163,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_55FF: /* 0x155 */
+.L_ALT_OP_IGET_BOOLEAN: /* 0x55 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22759,7 +12174,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (341 * 64)
+    adrl   lr, dvmAsmInstructionStart + (85 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22771,7 +12186,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_56FF: /* 0x156 */
+.L_ALT_OP_IGET_BYTE: /* 0x56 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22782,7 +12197,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (342 * 64)
+    adrl   lr, dvmAsmInstructionStart + (86 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22794,7 +12209,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_57FF: /* 0x157 */
+.L_ALT_OP_IGET_CHAR: /* 0x57 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22805,7 +12220,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (343 * 64)
+    adrl   lr, dvmAsmInstructionStart + (87 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22817,7 +12232,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_58FF: /* 0x158 */
+.L_ALT_OP_IGET_SHORT: /* 0x58 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22828,7 +12243,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (344 * 64)
+    adrl   lr, dvmAsmInstructionStart + (88 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22840,7 +12255,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_59FF: /* 0x159 */
+.L_ALT_OP_IPUT: /* 0x59 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22851,7 +12266,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (345 * 64)
+    adrl   lr, dvmAsmInstructionStart + (89 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22863,7 +12278,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_5AFF: /* 0x15a */
+.L_ALT_OP_IPUT_WIDE: /* 0x5a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22874,7 +12289,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (346 * 64)
+    adrl   lr, dvmAsmInstructionStart + (90 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22886,7 +12301,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_5BFF: /* 0x15b */
+.L_ALT_OP_IPUT_OBJECT: /* 0x5b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22897,7 +12312,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (347 * 64)
+    adrl   lr, dvmAsmInstructionStart + (91 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22909,7 +12324,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_5CFF: /* 0x15c */
+.L_ALT_OP_IPUT_BOOLEAN: /* 0x5c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22920,7 +12335,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (348 * 64)
+    adrl   lr, dvmAsmInstructionStart + (92 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22932,7 +12347,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_5DFF: /* 0x15d */
+.L_ALT_OP_IPUT_BYTE: /* 0x5d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22943,7 +12358,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (349 * 64)
+    adrl   lr, dvmAsmInstructionStart + (93 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22955,7 +12370,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_5EFF: /* 0x15e */
+.L_ALT_OP_IPUT_CHAR: /* 0x5e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22966,7 +12381,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (350 * 64)
+    adrl   lr, dvmAsmInstructionStart + (94 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -22978,7 +12393,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_5FFF: /* 0x15f */
+.L_ALT_OP_IPUT_SHORT: /* 0x5f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -22989,7 +12404,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (351 * 64)
+    adrl   lr, dvmAsmInstructionStart + (95 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23001,7 +12416,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_60FF: /* 0x160 */
+.L_ALT_OP_SGET: /* 0x60 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23012,7 +12427,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (352 * 64)
+    adrl   lr, dvmAsmInstructionStart + (96 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23024,7 +12439,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_61FF: /* 0x161 */
+.L_ALT_OP_SGET_WIDE: /* 0x61 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23035,7 +12450,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (353 * 64)
+    adrl   lr, dvmAsmInstructionStart + (97 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23047,7 +12462,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_62FF: /* 0x162 */
+.L_ALT_OP_SGET_OBJECT: /* 0x62 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23058,7 +12473,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (354 * 64)
+    adrl   lr, dvmAsmInstructionStart + (98 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23070,7 +12485,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_63FF: /* 0x163 */
+.L_ALT_OP_SGET_BOOLEAN: /* 0x63 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23081,7 +12496,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (355 * 64)
+    adrl   lr, dvmAsmInstructionStart + (99 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23093,7 +12508,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_64FF: /* 0x164 */
+.L_ALT_OP_SGET_BYTE: /* 0x64 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23104,7 +12519,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (356 * 64)
+    adrl   lr, dvmAsmInstructionStart + (100 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23116,7 +12531,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_65FF: /* 0x165 */
+.L_ALT_OP_SGET_CHAR: /* 0x65 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23127,7 +12542,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (357 * 64)
+    adrl   lr, dvmAsmInstructionStart + (101 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23139,7 +12554,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_66FF: /* 0x166 */
+.L_ALT_OP_SGET_SHORT: /* 0x66 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23150,7 +12565,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (358 * 64)
+    adrl   lr, dvmAsmInstructionStart + (102 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23162,7 +12577,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_67FF: /* 0x167 */
+.L_ALT_OP_SPUT: /* 0x67 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23173,7 +12588,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (359 * 64)
+    adrl   lr, dvmAsmInstructionStart + (103 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23185,7 +12600,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_68FF: /* 0x168 */
+.L_ALT_OP_SPUT_WIDE: /* 0x68 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23196,7 +12611,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (360 * 64)
+    adrl   lr, dvmAsmInstructionStart + (104 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23208,7 +12623,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_69FF: /* 0x169 */
+.L_ALT_OP_SPUT_OBJECT: /* 0x69 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23219,7 +12634,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (361 * 64)
+    adrl   lr, dvmAsmInstructionStart + (105 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23231,7 +12646,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_6AFF: /* 0x16a */
+.L_ALT_OP_SPUT_BOOLEAN: /* 0x6a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23242,7 +12657,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (362 * 64)
+    adrl   lr, dvmAsmInstructionStart + (106 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23254,7 +12669,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_6BFF: /* 0x16b */
+.L_ALT_OP_SPUT_BYTE: /* 0x6b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23265,7 +12680,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (363 * 64)
+    adrl   lr, dvmAsmInstructionStart + (107 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23277,7 +12692,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_6CFF: /* 0x16c */
+.L_ALT_OP_SPUT_CHAR: /* 0x6c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23288,7 +12703,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (364 * 64)
+    adrl   lr, dvmAsmInstructionStart + (108 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23300,7 +12715,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_6DFF: /* 0x16d */
+.L_ALT_OP_SPUT_SHORT: /* 0x6d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23311,7 +12726,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (365 * 64)
+    adrl   lr, dvmAsmInstructionStart + (109 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23323,7 +12738,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_6EFF: /* 0x16e */
+.L_ALT_OP_INVOKE_VIRTUAL: /* 0x6e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23334,7 +12749,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (366 * 64)
+    adrl   lr, dvmAsmInstructionStart + (110 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23346,7 +12761,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_6FFF: /* 0x16f */
+.L_ALT_OP_INVOKE_SUPER: /* 0x6f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23357,7 +12772,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (367 * 64)
+    adrl   lr, dvmAsmInstructionStart + (111 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23369,7 +12784,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_70FF: /* 0x170 */
+.L_ALT_OP_INVOKE_DIRECT: /* 0x70 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23380,7 +12795,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (368 * 64)
+    adrl   lr, dvmAsmInstructionStart + (112 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23392,7 +12807,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_71FF: /* 0x171 */
+.L_ALT_OP_INVOKE_STATIC: /* 0x71 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23403,7 +12818,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (369 * 64)
+    adrl   lr, dvmAsmInstructionStart + (113 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23415,7 +12830,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_72FF: /* 0x172 */
+.L_ALT_OP_INVOKE_INTERFACE: /* 0x72 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23426,7 +12841,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (370 * 64)
+    adrl   lr, dvmAsmInstructionStart + (114 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23438,7 +12853,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_73FF: /* 0x173 */
+.L_ALT_OP_UNUSED_73: /* 0x73 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23449,7 +12864,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (371 * 64)
+    adrl   lr, dvmAsmInstructionStart + (115 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23461,7 +12876,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_74FF: /* 0x174 */
+.L_ALT_OP_INVOKE_VIRTUAL_RANGE: /* 0x74 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23472,7 +12887,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (372 * 64)
+    adrl   lr, dvmAsmInstructionStart + (116 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23484,7 +12899,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_75FF: /* 0x175 */
+.L_ALT_OP_INVOKE_SUPER_RANGE: /* 0x75 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23495,7 +12910,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (373 * 64)
+    adrl   lr, dvmAsmInstructionStart + (117 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23507,7 +12922,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_76FF: /* 0x176 */
+.L_ALT_OP_INVOKE_DIRECT_RANGE: /* 0x76 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23518,7 +12933,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (374 * 64)
+    adrl   lr, dvmAsmInstructionStart + (118 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23530,7 +12945,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_77FF: /* 0x177 */
+.L_ALT_OP_INVOKE_STATIC_RANGE: /* 0x77 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23541,7 +12956,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (375 * 64)
+    adrl   lr, dvmAsmInstructionStart + (119 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23553,7 +12968,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_78FF: /* 0x178 */
+.L_ALT_OP_INVOKE_INTERFACE_RANGE: /* 0x78 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23564,7 +12979,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (376 * 64)
+    adrl   lr, dvmAsmInstructionStart + (120 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23576,7 +12991,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_79FF: /* 0x179 */
+.L_ALT_OP_UNUSED_79: /* 0x79 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23587,7 +13002,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (377 * 64)
+    adrl   lr, dvmAsmInstructionStart + (121 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23599,7 +13014,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_7AFF: /* 0x17a */
+.L_ALT_OP_UNUSED_7A: /* 0x7a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23610,7 +13025,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (378 * 64)
+    adrl   lr, dvmAsmInstructionStart + (122 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23622,7 +13037,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_7BFF: /* 0x17b */
+.L_ALT_OP_NEG_INT: /* 0x7b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23633,7 +13048,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (379 * 64)
+    adrl   lr, dvmAsmInstructionStart + (123 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23645,7 +13060,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_7CFF: /* 0x17c */
+.L_ALT_OP_NOT_INT: /* 0x7c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23656,7 +13071,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (380 * 64)
+    adrl   lr, dvmAsmInstructionStart + (124 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23668,7 +13083,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_7DFF: /* 0x17d */
+.L_ALT_OP_NEG_LONG: /* 0x7d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23679,7 +13094,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (381 * 64)
+    adrl   lr, dvmAsmInstructionStart + (125 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23691,7 +13106,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_7EFF: /* 0x17e */
+.L_ALT_OP_NOT_LONG: /* 0x7e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23702,7 +13117,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (382 * 64)
+    adrl   lr, dvmAsmInstructionStart + (126 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23714,7 +13129,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_7FFF: /* 0x17f */
+.L_ALT_OP_NEG_FLOAT: /* 0x7f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23725,7 +13140,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (383 * 64)
+    adrl   lr, dvmAsmInstructionStart + (127 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23737,7 +13152,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_80FF: /* 0x180 */
+.L_ALT_OP_NEG_DOUBLE: /* 0x80 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23748,7 +13163,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (384 * 64)
+    adrl   lr, dvmAsmInstructionStart + (128 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23760,7 +13175,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_81FF: /* 0x181 */
+.L_ALT_OP_INT_TO_LONG: /* 0x81 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23771,7 +13186,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (385 * 64)
+    adrl   lr, dvmAsmInstructionStart + (129 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23783,7 +13198,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_82FF: /* 0x182 */
+.L_ALT_OP_INT_TO_FLOAT: /* 0x82 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23794,7 +13209,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (386 * 64)
+    adrl   lr, dvmAsmInstructionStart + (130 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23806,7 +13221,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_83FF: /* 0x183 */
+.L_ALT_OP_INT_TO_DOUBLE: /* 0x83 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23817,7 +13232,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (387 * 64)
+    adrl   lr, dvmAsmInstructionStart + (131 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23829,7 +13244,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_84FF: /* 0x184 */
+.L_ALT_OP_LONG_TO_INT: /* 0x84 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23840,7 +13255,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (388 * 64)
+    adrl   lr, dvmAsmInstructionStart + (132 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23852,7 +13267,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_85FF: /* 0x185 */
+.L_ALT_OP_LONG_TO_FLOAT: /* 0x85 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23863,7 +13278,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (389 * 64)
+    adrl   lr, dvmAsmInstructionStart + (133 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23875,7 +13290,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_86FF: /* 0x186 */
+.L_ALT_OP_LONG_TO_DOUBLE: /* 0x86 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23886,7 +13301,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (390 * 64)
+    adrl   lr, dvmAsmInstructionStart + (134 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23898,7 +13313,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_87FF: /* 0x187 */
+.L_ALT_OP_FLOAT_TO_INT: /* 0x87 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23909,7 +13324,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (391 * 64)
+    adrl   lr, dvmAsmInstructionStart + (135 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23921,7 +13336,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_88FF: /* 0x188 */
+.L_ALT_OP_FLOAT_TO_LONG: /* 0x88 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23932,7 +13347,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (392 * 64)
+    adrl   lr, dvmAsmInstructionStart + (136 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23944,7 +13359,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_89FF: /* 0x189 */
+.L_ALT_OP_FLOAT_TO_DOUBLE: /* 0x89 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23955,7 +13370,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (393 * 64)
+    adrl   lr, dvmAsmInstructionStart + (137 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23967,7 +13382,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_8AFF: /* 0x18a */
+.L_ALT_OP_DOUBLE_TO_INT: /* 0x8a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -23978,7 +13393,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (394 * 64)
+    adrl   lr, dvmAsmInstructionStart + (138 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -23990,7 +13405,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_8BFF: /* 0x18b */
+.L_ALT_OP_DOUBLE_TO_LONG: /* 0x8b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24001,7 +13416,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (395 * 64)
+    adrl   lr, dvmAsmInstructionStart + (139 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24013,7 +13428,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_8CFF: /* 0x18c */
+.L_ALT_OP_DOUBLE_TO_FLOAT: /* 0x8c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24024,7 +13439,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (396 * 64)
+    adrl   lr, dvmAsmInstructionStart + (140 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24036,7 +13451,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_8DFF: /* 0x18d */
+.L_ALT_OP_INT_TO_BYTE: /* 0x8d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24047,7 +13462,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (397 * 64)
+    adrl   lr, dvmAsmInstructionStart + (141 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24059,7 +13474,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_8EFF: /* 0x18e */
+.L_ALT_OP_INT_TO_CHAR: /* 0x8e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24070,7 +13485,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (398 * 64)
+    adrl   lr, dvmAsmInstructionStart + (142 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24082,7 +13497,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_8FFF: /* 0x18f */
+.L_ALT_OP_INT_TO_SHORT: /* 0x8f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24093,7 +13508,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (399 * 64)
+    adrl   lr, dvmAsmInstructionStart + (143 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24105,7 +13520,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_90FF: /* 0x190 */
+.L_ALT_OP_ADD_INT: /* 0x90 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24116,7 +13531,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (400 * 64)
+    adrl   lr, dvmAsmInstructionStart + (144 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24128,7 +13543,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_91FF: /* 0x191 */
+.L_ALT_OP_SUB_INT: /* 0x91 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24139,7 +13554,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (401 * 64)
+    adrl   lr, dvmAsmInstructionStart + (145 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24151,7 +13566,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_92FF: /* 0x192 */
+.L_ALT_OP_MUL_INT: /* 0x92 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24162,7 +13577,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (402 * 64)
+    adrl   lr, dvmAsmInstructionStart + (146 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24174,7 +13589,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_93FF: /* 0x193 */
+.L_ALT_OP_DIV_INT: /* 0x93 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24185,7 +13600,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (403 * 64)
+    adrl   lr, dvmAsmInstructionStart + (147 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24197,7 +13612,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_94FF: /* 0x194 */
+.L_ALT_OP_REM_INT: /* 0x94 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24208,7 +13623,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (404 * 64)
+    adrl   lr, dvmAsmInstructionStart + (148 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24220,7 +13635,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_95FF: /* 0x195 */
+.L_ALT_OP_AND_INT: /* 0x95 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24231,7 +13646,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (405 * 64)
+    adrl   lr, dvmAsmInstructionStart + (149 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24243,7 +13658,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_96FF: /* 0x196 */
+.L_ALT_OP_OR_INT: /* 0x96 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24254,7 +13669,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (406 * 64)
+    adrl   lr, dvmAsmInstructionStart + (150 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24266,7 +13681,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_97FF: /* 0x197 */
+.L_ALT_OP_XOR_INT: /* 0x97 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24277,7 +13692,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (407 * 64)
+    adrl   lr, dvmAsmInstructionStart + (151 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24289,7 +13704,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_98FF: /* 0x198 */
+.L_ALT_OP_SHL_INT: /* 0x98 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24300,7 +13715,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (408 * 64)
+    adrl   lr, dvmAsmInstructionStart + (152 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24312,7 +13727,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_99FF: /* 0x199 */
+.L_ALT_OP_SHR_INT: /* 0x99 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24323,7 +13738,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (409 * 64)
+    adrl   lr, dvmAsmInstructionStart + (153 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24335,7 +13750,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_9AFF: /* 0x19a */
+.L_ALT_OP_USHR_INT: /* 0x9a */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24346,7 +13761,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (410 * 64)
+    adrl   lr, dvmAsmInstructionStart + (154 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24358,7 +13773,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_9BFF: /* 0x19b */
+.L_ALT_OP_ADD_LONG: /* 0x9b */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24369,7 +13784,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (411 * 64)
+    adrl   lr, dvmAsmInstructionStart + (155 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24381,7 +13796,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_9CFF: /* 0x19c */
+.L_ALT_OP_SUB_LONG: /* 0x9c */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24392,7 +13807,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (412 * 64)
+    adrl   lr, dvmAsmInstructionStart + (156 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24404,7 +13819,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_9DFF: /* 0x19d */
+.L_ALT_OP_MUL_LONG: /* 0x9d */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24415,7 +13830,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (413 * 64)
+    adrl   lr, dvmAsmInstructionStart + (157 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24427,7 +13842,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_9EFF: /* 0x19e */
+.L_ALT_OP_DIV_LONG: /* 0x9e */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24438,7 +13853,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (414 * 64)
+    adrl   lr, dvmAsmInstructionStart + (158 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24450,7 +13865,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_9FFF: /* 0x19f */
+.L_ALT_OP_REM_LONG: /* 0x9f */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24461,7 +13876,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (415 * 64)
+    adrl   lr, dvmAsmInstructionStart + (159 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24473,7 +13888,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A0FF: /* 0x1a0 */
+.L_ALT_OP_AND_LONG: /* 0xa0 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24484,7 +13899,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (416 * 64)
+    adrl   lr, dvmAsmInstructionStart + (160 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24496,7 +13911,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A1FF: /* 0x1a1 */
+.L_ALT_OP_OR_LONG: /* 0xa1 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24507,7 +13922,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (417 * 64)
+    adrl   lr, dvmAsmInstructionStart + (161 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24519,7 +13934,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A2FF: /* 0x1a2 */
+.L_ALT_OP_XOR_LONG: /* 0xa2 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24530,7 +13945,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (418 * 64)
+    adrl   lr, dvmAsmInstructionStart + (162 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24542,7 +13957,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A3FF: /* 0x1a3 */
+.L_ALT_OP_SHL_LONG: /* 0xa3 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24553,7 +13968,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (419 * 64)
+    adrl   lr, dvmAsmInstructionStart + (163 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24565,7 +13980,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A4FF: /* 0x1a4 */
+.L_ALT_OP_SHR_LONG: /* 0xa4 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24576,7 +13991,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (420 * 64)
+    adrl   lr, dvmAsmInstructionStart + (164 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24588,7 +14003,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A5FF: /* 0x1a5 */
+.L_ALT_OP_USHR_LONG: /* 0xa5 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24599,7 +14014,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (421 * 64)
+    adrl   lr, dvmAsmInstructionStart + (165 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24611,7 +14026,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A6FF: /* 0x1a6 */
+.L_ALT_OP_ADD_FLOAT: /* 0xa6 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24622,7 +14037,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (422 * 64)
+    adrl   lr, dvmAsmInstructionStart + (166 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24634,7 +14049,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A7FF: /* 0x1a7 */
+.L_ALT_OP_SUB_FLOAT: /* 0xa7 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24645,7 +14060,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (423 * 64)
+    adrl   lr, dvmAsmInstructionStart + (167 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24657,7 +14072,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A8FF: /* 0x1a8 */
+.L_ALT_OP_MUL_FLOAT: /* 0xa8 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24668,7 +14083,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (424 * 64)
+    adrl   lr, dvmAsmInstructionStart + (168 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24680,7 +14095,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_A9FF: /* 0x1a9 */
+.L_ALT_OP_DIV_FLOAT: /* 0xa9 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24691,7 +14106,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (425 * 64)
+    adrl   lr, dvmAsmInstructionStart + (169 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24703,7 +14118,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_AAFF: /* 0x1aa */
+.L_ALT_OP_REM_FLOAT: /* 0xaa */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24714,7 +14129,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (426 * 64)
+    adrl   lr, dvmAsmInstructionStart + (170 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24726,7 +14141,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_ABFF: /* 0x1ab */
+.L_ALT_OP_ADD_DOUBLE: /* 0xab */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24737,7 +14152,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (427 * 64)
+    adrl   lr, dvmAsmInstructionStart + (171 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24749,7 +14164,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_ACFF: /* 0x1ac */
+.L_ALT_OP_SUB_DOUBLE: /* 0xac */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24760,7 +14175,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (428 * 64)
+    adrl   lr, dvmAsmInstructionStart + (172 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24772,7 +14187,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_ADFF: /* 0x1ad */
+.L_ALT_OP_MUL_DOUBLE: /* 0xad */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24783,7 +14198,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (429 * 64)
+    adrl   lr, dvmAsmInstructionStart + (173 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24795,7 +14210,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_AEFF: /* 0x1ae */
+.L_ALT_OP_DIV_DOUBLE: /* 0xae */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24806,7 +14221,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (430 * 64)
+    adrl   lr, dvmAsmInstructionStart + (174 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24818,7 +14233,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_AFFF: /* 0x1af */
+.L_ALT_OP_REM_DOUBLE: /* 0xaf */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24829,7 +14244,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (431 * 64)
+    adrl   lr, dvmAsmInstructionStart + (175 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24841,7 +14256,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B0FF: /* 0x1b0 */
+.L_ALT_OP_ADD_INT_2ADDR: /* 0xb0 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24852,7 +14267,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (432 * 64)
+    adrl   lr, dvmAsmInstructionStart + (176 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24864,7 +14279,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B1FF: /* 0x1b1 */
+.L_ALT_OP_SUB_INT_2ADDR: /* 0xb1 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24875,7 +14290,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (433 * 64)
+    adrl   lr, dvmAsmInstructionStart + (177 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24887,7 +14302,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B2FF: /* 0x1b2 */
+.L_ALT_OP_MUL_INT_2ADDR: /* 0xb2 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24898,7 +14313,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (434 * 64)
+    adrl   lr, dvmAsmInstructionStart + (178 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24910,7 +14325,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B3FF: /* 0x1b3 */
+.L_ALT_OP_DIV_INT_2ADDR: /* 0xb3 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24921,7 +14336,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (435 * 64)
+    adrl   lr, dvmAsmInstructionStart + (179 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24933,7 +14348,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B4FF: /* 0x1b4 */
+.L_ALT_OP_REM_INT_2ADDR: /* 0xb4 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24944,7 +14359,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (436 * 64)
+    adrl   lr, dvmAsmInstructionStart + (180 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24956,7 +14371,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B5FF: /* 0x1b5 */
+.L_ALT_OP_AND_INT_2ADDR: /* 0xb5 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24967,7 +14382,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (437 * 64)
+    adrl   lr, dvmAsmInstructionStart + (181 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -24979,7 +14394,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B6FF: /* 0x1b6 */
+.L_ALT_OP_OR_INT_2ADDR: /* 0xb6 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -24990,7 +14405,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (438 * 64)
+    adrl   lr, dvmAsmInstructionStart + (182 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25002,7 +14417,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B7FF: /* 0x1b7 */
+.L_ALT_OP_XOR_INT_2ADDR: /* 0xb7 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25013,7 +14428,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (439 * 64)
+    adrl   lr, dvmAsmInstructionStart + (183 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25025,7 +14440,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B8FF: /* 0x1b8 */
+.L_ALT_OP_SHL_INT_2ADDR: /* 0xb8 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25036,7 +14451,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (440 * 64)
+    adrl   lr, dvmAsmInstructionStart + (184 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25048,7 +14463,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_B9FF: /* 0x1b9 */
+.L_ALT_OP_SHR_INT_2ADDR: /* 0xb9 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25059,7 +14474,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (441 * 64)
+    adrl   lr, dvmAsmInstructionStart + (185 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25071,7 +14486,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_BAFF: /* 0x1ba */
+.L_ALT_OP_USHR_INT_2ADDR: /* 0xba */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25082,7 +14497,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (442 * 64)
+    adrl   lr, dvmAsmInstructionStart + (186 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25094,7 +14509,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_BBFF: /* 0x1bb */
+.L_ALT_OP_ADD_LONG_2ADDR: /* 0xbb */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25105,7 +14520,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (443 * 64)
+    adrl   lr, dvmAsmInstructionStart + (187 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25117,7 +14532,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_BCFF: /* 0x1bc */
+.L_ALT_OP_SUB_LONG_2ADDR: /* 0xbc */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25128,7 +14543,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (444 * 64)
+    adrl   lr, dvmAsmInstructionStart + (188 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25140,7 +14555,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_BDFF: /* 0x1bd */
+.L_ALT_OP_MUL_LONG_2ADDR: /* 0xbd */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25151,7 +14566,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (445 * 64)
+    adrl   lr, dvmAsmInstructionStart + (189 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25163,7 +14578,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_BEFF: /* 0x1be */
+.L_ALT_OP_DIV_LONG_2ADDR: /* 0xbe */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25174,7 +14589,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (446 * 64)
+    adrl   lr, dvmAsmInstructionStart + (190 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25186,7 +14601,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_BFFF: /* 0x1bf */
+.L_ALT_OP_REM_LONG_2ADDR: /* 0xbf */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25197,7 +14612,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (447 * 64)
+    adrl   lr, dvmAsmInstructionStart + (191 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25209,7 +14624,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C0FF: /* 0x1c0 */
+.L_ALT_OP_AND_LONG_2ADDR: /* 0xc0 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25220,7 +14635,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (448 * 64)
+    adrl   lr, dvmAsmInstructionStart + (192 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25232,7 +14647,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C1FF: /* 0x1c1 */
+.L_ALT_OP_OR_LONG_2ADDR: /* 0xc1 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25243,7 +14658,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (449 * 64)
+    adrl   lr, dvmAsmInstructionStart + (193 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25255,7 +14670,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C2FF: /* 0x1c2 */
+.L_ALT_OP_XOR_LONG_2ADDR: /* 0xc2 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25266,7 +14681,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (450 * 64)
+    adrl   lr, dvmAsmInstructionStart + (194 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25278,7 +14693,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C3FF: /* 0x1c3 */
+.L_ALT_OP_SHL_LONG_2ADDR: /* 0xc3 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25289,7 +14704,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (451 * 64)
+    adrl   lr, dvmAsmInstructionStart + (195 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25301,7 +14716,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C4FF: /* 0x1c4 */
+.L_ALT_OP_SHR_LONG_2ADDR: /* 0xc4 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25312,7 +14727,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (452 * 64)
+    adrl   lr, dvmAsmInstructionStart + (196 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25324,7 +14739,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C5FF: /* 0x1c5 */
+.L_ALT_OP_USHR_LONG_2ADDR: /* 0xc5 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25335,7 +14750,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (453 * 64)
+    adrl   lr, dvmAsmInstructionStart + (197 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25347,7 +14762,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C6FF: /* 0x1c6 */
+.L_ALT_OP_ADD_FLOAT_2ADDR: /* 0xc6 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25358,7 +14773,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (454 * 64)
+    adrl   lr, dvmAsmInstructionStart + (198 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25370,7 +14785,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C7FF: /* 0x1c7 */
+.L_ALT_OP_SUB_FLOAT_2ADDR: /* 0xc7 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25381,7 +14796,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (455 * 64)
+    adrl   lr, dvmAsmInstructionStart + (199 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25393,7 +14808,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C8FF: /* 0x1c8 */
+.L_ALT_OP_MUL_FLOAT_2ADDR: /* 0xc8 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25404,7 +14819,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (456 * 64)
+    adrl   lr, dvmAsmInstructionStart + (200 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25416,7 +14831,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_C9FF: /* 0x1c9 */
+.L_ALT_OP_DIV_FLOAT_2ADDR: /* 0xc9 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25427,7 +14842,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (457 * 64)
+    adrl   lr, dvmAsmInstructionStart + (201 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25439,7 +14854,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_CAFF: /* 0x1ca */
+.L_ALT_OP_REM_FLOAT_2ADDR: /* 0xca */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25450,7 +14865,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (458 * 64)
+    adrl   lr, dvmAsmInstructionStart + (202 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25462,7 +14877,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_CBFF: /* 0x1cb */
+.L_ALT_OP_ADD_DOUBLE_2ADDR: /* 0xcb */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25473,7 +14888,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (459 * 64)
+    adrl   lr, dvmAsmInstructionStart + (203 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25485,7 +14900,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_CCFF: /* 0x1cc */
+.L_ALT_OP_SUB_DOUBLE_2ADDR: /* 0xcc */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25496,7 +14911,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (460 * 64)
+    adrl   lr, dvmAsmInstructionStart + (204 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25508,7 +14923,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_CDFF: /* 0x1cd */
+.L_ALT_OP_MUL_DOUBLE_2ADDR: /* 0xcd */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25519,7 +14934,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (461 * 64)
+    adrl   lr, dvmAsmInstructionStart + (205 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25531,7 +14946,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_CEFF: /* 0x1ce */
+.L_ALT_OP_DIV_DOUBLE_2ADDR: /* 0xce */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25542,7 +14957,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (462 * 64)
+    adrl   lr, dvmAsmInstructionStart + (206 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25554,7 +14969,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_CFFF: /* 0x1cf */
+.L_ALT_OP_REM_DOUBLE_2ADDR: /* 0xcf */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25565,7 +14980,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (463 * 64)
+    adrl   lr, dvmAsmInstructionStart + (207 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25577,7 +14992,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D0FF: /* 0x1d0 */
+.L_ALT_OP_ADD_INT_LIT16: /* 0xd0 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25588,7 +15003,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (464 * 64)
+    adrl   lr, dvmAsmInstructionStart + (208 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25600,7 +15015,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D1FF: /* 0x1d1 */
+.L_ALT_OP_RSUB_INT: /* 0xd1 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25611,7 +15026,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (465 * 64)
+    adrl   lr, dvmAsmInstructionStart + (209 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25623,7 +15038,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D2FF: /* 0x1d2 */
+.L_ALT_OP_MUL_INT_LIT16: /* 0xd2 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25634,7 +15049,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (466 * 64)
+    adrl   lr, dvmAsmInstructionStart + (210 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25646,7 +15061,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D3FF: /* 0x1d3 */
+.L_ALT_OP_DIV_INT_LIT16: /* 0xd3 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25657,7 +15072,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (467 * 64)
+    adrl   lr, dvmAsmInstructionStart + (211 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25669,7 +15084,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D4FF: /* 0x1d4 */
+.L_ALT_OP_REM_INT_LIT16: /* 0xd4 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25680,7 +15095,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (468 * 64)
+    adrl   lr, dvmAsmInstructionStart + (212 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25692,7 +15107,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D5FF: /* 0x1d5 */
+.L_ALT_OP_AND_INT_LIT16: /* 0xd5 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25703,7 +15118,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (469 * 64)
+    adrl   lr, dvmAsmInstructionStart + (213 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25715,7 +15130,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D6FF: /* 0x1d6 */
+.L_ALT_OP_OR_INT_LIT16: /* 0xd6 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25726,7 +15141,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (470 * 64)
+    adrl   lr, dvmAsmInstructionStart + (214 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25738,7 +15153,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D7FF: /* 0x1d7 */
+.L_ALT_OP_XOR_INT_LIT16: /* 0xd7 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25749,7 +15164,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (471 * 64)
+    adrl   lr, dvmAsmInstructionStart + (215 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25761,7 +15176,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D8FF: /* 0x1d8 */
+.L_ALT_OP_ADD_INT_LIT8: /* 0xd8 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25772,7 +15187,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (472 * 64)
+    adrl   lr, dvmAsmInstructionStart + (216 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25784,7 +15199,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_D9FF: /* 0x1d9 */
+.L_ALT_OP_RSUB_INT_LIT8: /* 0xd9 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25795,7 +15210,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (473 * 64)
+    adrl   lr, dvmAsmInstructionStart + (217 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25807,7 +15222,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_DAFF: /* 0x1da */
+.L_ALT_OP_MUL_INT_LIT8: /* 0xda */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25818,7 +15233,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (474 * 64)
+    adrl   lr, dvmAsmInstructionStart + (218 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25830,7 +15245,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_DBFF: /* 0x1db */
+.L_ALT_OP_DIV_INT_LIT8: /* 0xdb */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25841,7 +15256,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (475 * 64)
+    adrl   lr, dvmAsmInstructionStart + (219 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25853,7 +15268,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_DCFF: /* 0x1dc */
+.L_ALT_OP_REM_INT_LIT8: /* 0xdc */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25864,7 +15279,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (476 * 64)
+    adrl   lr, dvmAsmInstructionStart + (220 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25876,7 +15291,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_DDFF: /* 0x1dd */
+.L_ALT_OP_AND_INT_LIT8: /* 0xdd */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25887,7 +15302,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (477 * 64)
+    adrl   lr, dvmAsmInstructionStart + (221 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25899,7 +15314,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_DEFF: /* 0x1de */
+.L_ALT_OP_OR_INT_LIT8: /* 0xde */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25910,7 +15325,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (478 * 64)
+    adrl   lr, dvmAsmInstructionStart + (222 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25922,7 +15337,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_DFFF: /* 0x1df */
+.L_ALT_OP_XOR_INT_LIT8: /* 0xdf */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25933,7 +15348,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (479 * 64)
+    adrl   lr, dvmAsmInstructionStart + (223 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25945,7 +15360,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E0FF: /* 0x1e0 */
+.L_ALT_OP_SHL_INT_LIT8: /* 0xe0 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25956,7 +15371,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (480 * 64)
+    adrl   lr, dvmAsmInstructionStart + (224 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25968,7 +15383,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E1FF: /* 0x1e1 */
+.L_ALT_OP_SHR_INT_LIT8: /* 0xe1 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -25979,7 +15394,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (481 * 64)
+    adrl   lr, dvmAsmInstructionStart + (225 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -25991,7 +15406,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E2FF: /* 0x1e2 */
+.L_ALT_OP_USHR_INT_LIT8: /* 0xe2 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26002,7 +15417,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (482 * 64)
+    adrl   lr, dvmAsmInstructionStart + (226 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26014,7 +15429,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E3FF: /* 0x1e3 */
+.L_ALT_OP_IGET_VOLATILE: /* 0xe3 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26025,7 +15440,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (483 * 64)
+    adrl   lr, dvmAsmInstructionStart + (227 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26037,7 +15452,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E4FF: /* 0x1e4 */
+.L_ALT_OP_IPUT_VOLATILE: /* 0xe4 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26048,7 +15463,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (484 * 64)
+    adrl   lr, dvmAsmInstructionStart + (228 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26060,7 +15475,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E5FF: /* 0x1e5 */
+.L_ALT_OP_SGET_VOLATILE: /* 0xe5 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26071,7 +15486,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (485 * 64)
+    adrl   lr, dvmAsmInstructionStart + (229 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26083,7 +15498,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E6FF: /* 0x1e6 */
+.L_ALT_OP_SPUT_VOLATILE: /* 0xe6 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26094,7 +15509,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (486 * 64)
+    adrl   lr, dvmAsmInstructionStart + (230 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26106,7 +15521,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E7FF: /* 0x1e7 */
+.L_ALT_OP_IGET_OBJECT_VOLATILE: /* 0xe7 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26117,7 +15532,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (487 * 64)
+    adrl   lr, dvmAsmInstructionStart + (231 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26129,7 +15544,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E8FF: /* 0x1e8 */
+.L_ALT_OP_IGET_WIDE_VOLATILE: /* 0xe8 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26140,7 +15555,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (488 * 64)
+    adrl   lr, dvmAsmInstructionStart + (232 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26152,7 +15567,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_E9FF: /* 0x1e9 */
+.L_ALT_OP_IPUT_WIDE_VOLATILE: /* 0xe9 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26163,7 +15578,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (489 * 64)
+    adrl   lr, dvmAsmInstructionStart + (233 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26175,7 +15590,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_EAFF: /* 0x1ea */
+.L_ALT_OP_SGET_WIDE_VOLATILE: /* 0xea */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26186,7 +15601,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (490 * 64)
+    adrl   lr, dvmAsmInstructionStart + (234 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26198,7 +15613,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_EBFF: /* 0x1eb */
+.L_ALT_OP_SPUT_WIDE_VOLATILE: /* 0xeb */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26209,7 +15624,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (491 * 64)
+    adrl   lr, dvmAsmInstructionStart + (235 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26221,7 +15636,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_ECFF: /* 0x1ec */
+.L_ALT_OP_BREAKPOINT: /* 0xec */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26232,7 +15647,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (492 * 64)
+    adrl   lr, dvmAsmInstructionStart + (236 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26244,7 +15659,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_EDFF: /* 0x1ed */
+.L_ALT_OP_THROW_VERIFICATION_ERROR: /* 0xed */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26255,7 +15670,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (493 * 64)
+    adrl   lr, dvmAsmInstructionStart + (237 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26267,7 +15682,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_EEFF: /* 0x1ee */
+.L_ALT_OP_EXECUTE_INLINE: /* 0xee */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26278,7 +15693,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (494 * 64)
+    adrl   lr, dvmAsmInstructionStart + (238 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26290,7 +15705,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_EFFF: /* 0x1ef */
+.L_ALT_OP_EXECUTE_INLINE_RANGE: /* 0xef */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26301,7 +15716,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (495 * 64)
+    adrl   lr, dvmAsmInstructionStart + (239 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26313,7 +15728,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_F0FF: /* 0x1f0 */
+.L_ALT_OP_INVOKE_OBJECT_INIT_RANGE: /* 0xf0 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26324,7 +15739,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (496 * 64)
+    adrl   lr, dvmAsmInstructionStart + (240 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26336,7 +15751,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_UNUSED_F1FF: /* 0x1f1 */
+.L_ALT_OP_RETURN_VOID_BARRIER: /* 0xf1 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26347,7 +15762,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (497 * 64)
+    adrl   lr, dvmAsmInstructionStart + (241 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26359,7 +15774,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_INVOKE_OBJECT_INIT_JUMBO: /* 0x1f2 */
+.L_ALT_OP_IGET_QUICK: /* 0xf2 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26370,7 +15785,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (498 * 64)
+    adrl   lr, dvmAsmInstructionStart + (242 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26382,7 +15797,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_VOLATILE_JUMBO: /* 0x1f3 */
+.L_ALT_OP_IGET_WIDE_QUICK: /* 0xf3 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26393,7 +15808,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (499 * 64)
+    adrl   lr, dvmAsmInstructionStart + (243 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26405,7 +15820,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_WIDE_VOLATILE_JUMBO: /* 0x1f4 */
+.L_ALT_OP_IGET_OBJECT_QUICK: /* 0xf4 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26416,7 +15831,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (500 * 64)
+    adrl   lr, dvmAsmInstructionStart + (244 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26428,7 +15843,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IGET_OBJECT_VOLATILE_JUMBO: /* 0x1f5 */
+.L_ALT_OP_IPUT_QUICK: /* 0xf5 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26439,7 +15854,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (501 * 64)
+    adrl   lr, dvmAsmInstructionStart + (245 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26451,7 +15866,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_VOLATILE_JUMBO: /* 0x1f6 */
+.L_ALT_OP_IPUT_WIDE_QUICK: /* 0xf6 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26462,7 +15877,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (502 * 64)
+    adrl   lr, dvmAsmInstructionStart + (246 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26474,7 +15889,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_WIDE_VOLATILE_JUMBO: /* 0x1f7 */
+.L_ALT_OP_IPUT_OBJECT_QUICK: /* 0xf7 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26485,7 +15900,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (503 * 64)
+    adrl   lr, dvmAsmInstructionStart + (247 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26497,7 +15912,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_IPUT_OBJECT_VOLATILE_JUMBO: /* 0x1f8 */
+.L_ALT_OP_INVOKE_VIRTUAL_QUICK: /* 0xf8 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26508,7 +15923,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (504 * 64)
+    adrl   lr, dvmAsmInstructionStart + (248 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26520,7 +15935,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_VOLATILE_JUMBO: /* 0x1f9 */
+.L_ALT_OP_INVOKE_VIRTUAL_QUICK_RANGE: /* 0xf9 */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26531,7 +15946,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (505 * 64)
+    adrl   lr, dvmAsmInstructionStart + (249 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26543,7 +15958,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_WIDE_VOLATILE_JUMBO: /* 0x1fa */
+.L_ALT_OP_INVOKE_SUPER_QUICK: /* 0xfa */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26554,7 +15969,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (506 * 64)
+    adrl   lr, dvmAsmInstructionStart + (250 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26566,7 +15981,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SGET_OBJECT_VOLATILE_JUMBO: /* 0x1fb */
+.L_ALT_OP_INVOKE_SUPER_QUICK_RANGE: /* 0xfb */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26577,7 +15992,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (507 * 64)
+    adrl   lr, dvmAsmInstructionStart + (251 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26589,7 +16004,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_VOLATILE_JUMBO: /* 0x1fc */
+.L_ALT_OP_IPUT_OBJECT_VOLATILE: /* 0xfc */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26600,7 +16015,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (508 * 64)
+    adrl   lr, dvmAsmInstructionStart + (252 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26612,7 +16027,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_WIDE_VOLATILE_JUMBO: /* 0x1fd */
+.L_ALT_OP_SGET_OBJECT_VOLATILE: /* 0xfd */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26623,7 +16038,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (509 * 64)
+    adrl   lr, dvmAsmInstructionStart + (253 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26635,7 +16050,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_SPUT_OBJECT_VOLATILE_JUMBO: /* 0x1fe */
+.L_ALT_OP_SPUT_OBJECT_VOLATILE: /* 0xfe */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26646,7 +16061,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (510 * 64)
+    adrl   lr, dvmAsmInstructionStart + (254 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -26658,7 +16073,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
 
 /* ------------------------------ */
     .balign 64
-.L_ALT_OP_THROW_VERIFICATION_ERROR_JUMBO: /* 0x1ff */
+.L_ALT_OP_UNUSED_FF: /* 0xff */
 /* File: armv5te/alt_stub.S */
 /*
  * Inter-instruction transfer stub.  Call out to dvmCheckBefore to handle
@@ -26669,7 +16084,7 @@ dvmAsmAltInstructionStart = .L_ALT_OP_NOP
  * bail to the real handler if breakFlags==0.
  */
     ldrb   r3, [rSELF, #offThread_breakFlags]
-    adrl   lr, dvmAsmInstructionStart + (511 * 64)
+    adrl   lr, dvmAsmInstructionStart + (255 * 64)
     ldr    rIBASE, [rSELF, #offThread_curHandlerTable]
     cmp    r3, #0
     bxeq   lr                   @ nothing to do - jump to real handler
@@ -27152,35 +16567,6 @@ save_callsiteinfo:
 #endif
 
 /*
- * Common code for jumbo method invocation.
- * NOTE: this adjusts rPC to account for the difference in instruction width.
- * As a result, the savedPc in the stack frame will not be wholly accurate. So
- * long as that is only used for source file line number calculations, we're
- * okay.
- */
-common_invokeMethodJumboNoThis:
-#if defined(WITH_JIT)
- /* On entry: r0 is "Method* methodToCall */
-    mov     r9, #0                      @ clear "this"
-#endif
-common_invokeMethodJumbo:
- /* On entry: r0 is "Method* methodToCall, r9 is "this" */
-.LinvokeNewJumbo:
-#if defined(WITH_JIT)
-    ldrh    r1, [rSELF, #offThread_subMode]
-    ands    r1, #kSubModeJitTraceBuild
-    blne    save_callsiteinfo
-#endif
-    @ prepare to copy args to "outs" area of current frame
-    add     rPC, rPC, #4                @ adjust pc to make return consistent
-    FETCH(r2, 1)                        @ r2<- BBBB (arg count)
-    SAVEAREA_FROM_FP(r10, rFP)          @ r10<- stack save area
-    cmp     r2, #0                      @ no args?
-    beq     .LinvokeArgsDone            @ if no args, skip the rest
-    FETCH(r1, 2)                        @ r1<- CCCC
-    b       .LinvokeRangeArgs           @ handle args like invoke range
-
-/*
  * Common code for method invocation with range.
  *
  * On entry:
diff --git a/vm/mterp/out/InterpC-armv6-vfp.cpp b/vm/mterp/out/InterpC-armv6-vfp.cpp
index 950607b..a5b542c 100644
--- a/vm/mterp/out/InterpC-armv6-vfp.cpp
+++ b/vm/mterp/out/InterpC-armv6-vfp.cpp
@@ -102,7 +102,7 @@
         {                                                                   \
             char* desc;                                                     \
             desc = dexProtoCopyMethodDescriptor(&curMethod->prototype);     \
-            LOGE("Invalid branch %d at 0x%04x in %s.%s %s",                 \
+            ALOGE("Invalid branch %d at 0x%04x in %s.%s %s",                 \
                 myoff, (int) (pc - curMethod->insns),                       \
                 curMethod->clazz->descriptor, curMethod->name, desc);       \
             free(desc);                                                     \
@@ -128,10 +128,10 @@
         char debugStrBuf[128];                                              \
         snprintf(debugStrBuf, sizeof(debugStrBuf), __VA_ARGS__);            \
         if (curMethod != NULL)                                              \
-            LOG(_level, LOG_TAG"i", "%-2d|%04x%s",                          \
+            ALOG(_level, LOG_TAG"i", "%-2d|%04x%s",                          \
                 self->threadId, (int)(pc - curMethod->insns), debugStrBuf); \
         else                                                                \
-            LOG(_level, LOG_TAG"i", "%-2d|####%s",                          \
+            ALOG(_level, LOG_TAG"i", "%-2d|####%s",                          \
                 self->threadId, debugStrBuf);                               \
     } while(false)
 void dvmDumpRegs(const Method* method, const u4* framePtr, bool inOnly);
@@ -320,15 +320,15 @@ static inline bool checkForNull(Object* obj)
         return false;
     }
 #ifdef WITH_EXTRA_OBJECT_VALIDATION
-    if (!dvmIsHeapAddressObject(obj)) {
-        LOGE("Invalid object %p", obj);
+    if (!dvmIsHeapAddress(obj)) {
+        ALOGE("Invalid object %p", obj);
         dvmAbort();
     }
 #endif
 #ifndef NDEBUG
     if (obj->clazz == NULL || ((u4) obj->clazz) <= 65536) {
         /* probable heap corruption */
-        LOGE("Invalid object class %p (in %p)", obj->clazz, obj);
+        ALOGE("Invalid object class %p (in %p)", obj->clazz, obj);
         dvmAbort();
     }
 #endif
@@ -353,14 +353,14 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
     }
 #ifdef WITH_EXTRA_OBJECT_VALIDATION
     if (!dvmIsHeapAddress(obj)) {
-        LOGE("Invalid object %p", obj);
+        ALOGE("Invalid object %p", obj);
         dvmAbort();
     }
 #endif
 #ifndef NDEBUG
     if (obj->clazz == NULL || ((u4) obj->clazz) <= 65536) {
         /* probable heap corruption */
-        LOGE("Invalid object class %p (in %p)", obj->clazz, obj);
+        ALOGE("Invalid object class %p (in %p)", obj->clazz, obj);
         dvmAbort();
     }
 #endif
@@ -471,9 +471,9 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
         return;                                                             \
     } while(false)
 
-#define GOTO_invoke(_target, _methodCallRange, _jumboFormat)                \
+#define GOTO_invoke(_target, _methodCallRange)                              \
     do {                                                                    \
-        dvmMterp_##_target(self, _methodCallRange, _jumboFormat);           \
+        dvmMterp_##_target(self, _methodCallRange);                         \
         return;                                                             \
     } while(false)
 
@@ -505,14 +505,14 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
 
 /* File: c/opcommon.cpp */
 /* forward declarations of goto targets */
-GOTO_TARGET_DECL(filledNewArray, bool methodCallRange, bool jumboFormat);
-GOTO_TARGET_DECL(invokeVirtual, bool methodCallRange, bool jumboFormat);
-GOTO_TARGET_DECL(invokeSuper, bool methodCallRange, bool jumboFormat);
-GOTO_TARGET_DECL(invokeInterface, bool methodCallRange, bool jumboFormat);
-GOTO_TARGET_DECL(invokeDirect, bool methodCallRange, bool jumboFormat);
-GOTO_TARGET_DECL(invokeStatic, bool methodCallRange, bool jumboFormat);
-GOTO_TARGET_DECL(invokeVirtualQuick, bool methodCallRange, bool jumboFormat);
-GOTO_TARGET_DECL(invokeSuperQuick, bool methodCallRange, bool jumboFormat);
+GOTO_TARGET_DECL(filledNewArray, bool methodCallRange);
+GOTO_TARGET_DECL(invokeVirtual, bool methodCallRange);
+GOTO_TARGET_DECL(invokeSuper, bool methodCallRange);
+GOTO_TARGET_DECL(invokeInterface, bool methodCallRange);
+GOTO_TARGET_DECL(invokeDirect, bool methodCallRange);
+GOTO_TARGET_DECL(invokeStatic, bool methodCallRange);
+GOTO_TARGET_DECL(invokeVirtualQuick, bool methodCallRange);
+GOTO_TARGET_DECL(invokeSuperQuick, bool methodCallRange);
 GOTO_TARGET_DECL(invokeMethod, bool methodCallRange, const Method* methodToCall,
     u2 count, u2 regs);
 GOTO_TARGET_DECL(returnFromMethod);
@@ -1036,33 +1036,6 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
     }                                                                       \
     FINISH(2);
 
-#define HANDLE_IGET_X_JUMBO(_opcode, _opname, _ftype, _regsize)             \
-    HANDLE_OPCODE(_opcode /*vBBBB, vCCCC, class@AAAAAAAA*/)                 \
-    {                                                                       \
-        InstField* ifield;                                                  \
-        Object* obj;                                                        \
-        EXPORT_PC();                                                        \
-        ref = FETCH(1) | (u4)FETCH(2) << 16;   /* field ref */              \
-        vdst = FETCH(3);                                                    \
-        vsrc1 = FETCH(4);                      /* object ptr */             \
-        ILOGV("|iget%s/jumbo v%d,v%d,field@0x%08x",                         \
-            (_opname), vdst, vsrc1, ref);                                   \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
-        if (!checkForNull(obj))                                             \
-            GOTO_exceptionThrown();                                         \
-        ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
-        if (ifield == NULL) {                                               \
-            ifield = dvmResolveInstField(curMethod->clazz, ref);            \
-            if (ifield == NULL)                                             \
-                GOTO_exceptionThrown();                                     \
-        }                                                                   \
-        SET_REGISTER##_regsize(vdst,                                        \
-            dvmGetField##_ftype(obj, ifield->byteOffset));                  \
-        ILOGV("+ IGET '%s'=0x%08llx", ifield->field.name,                   \
-            (u8) GET_REGISTER##_regsize(vdst));                             \
-    }                                                                       \
-    FINISH(5);
-
 #define HANDLE_IGET_X_QUICK(_opcode, _opname, _ftype, _regsize)             \
     HANDLE_OPCODE(_opcode /*vA, vB, field@CCCC*/)                           \
     {                                                                       \
@@ -1107,33 +1080,6 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
     }                                                                       \
     FINISH(2);
 
-#define HANDLE_IPUT_X_JUMBO(_opcode, _opname, _ftype, _regsize)             \
-    HANDLE_OPCODE(_opcode /*vBBBB, vCCCC, class@AAAAAAAA*/)                 \
-    {                                                                       \
-        InstField* ifield;                                                  \
-        Object* obj;                                                        \
-        EXPORT_PC();                                                        \
-        ref = FETCH(1) | (u4)FETCH(2) << 16;   /* field ref */              \
-        vdst = FETCH(3);                                                    \
-        vsrc1 = FETCH(4);                      /* object ptr */             \
-        ILOGV("|iput%s/jumbo v%d,v%d,field@0x%08x",                         \
-            (_opname), vdst, vsrc1, ref);                                   \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
-        if (!checkForNull(obj))                                             \
-            GOTO_exceptionThrown();                                         \
-        ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
-        if (ifield == NULL) {                                               \
-            ifield = dvmResolveInstField(curMethod->clazz, ref);            \
-            if (ifield == NULL)                                             \
-                GOTO_exceptionThrown();                                     \
-        }                                                                   \
-        dvmSetField##_ftype(obj, ifield->byteOffset,                        \
-            GET_REGISTER##_regsize(vdst));                                  \
-        ILOGV("+ IPUT '%s'=0x%08llx", ifield->field.name,                   \
-            (u8) GET_REGISTER##_regsize(vdst));                             \
-    }                                                                       \
-    FINISH(5);
-
 #define HANDLE_IPUT_X_QUICK(_opcode, _opname, _ftype, _regsize)             \
     HANDLE_OPCODE(_opcode /*vA, vB, field@CCCC*/)                           \
     {                                                                       \
@@ -1183,29 +1129,6 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
     }                                                                       \
     FINISH(2);
 
-#define HANDLE_SGET_X_JUMBO(_opcode, _opname, _ftype, _regsize)             \
-    HANDLE_OPCODE(_opcode /*vBBBB, class@AAAAAAAA*/)                        \
-    {                                                                       \
-        StaticField* sfield;                                                \
-        ref = FETCH(1) | (u4)FETCH(2) << 16;   /* field ref */              \
-        vdst = FETCH(3);                                                    \
-        ILOGV("|sget%s/jumbo v%d,sfield@0x%08x", (_opname), vdst, ref);     \
-        sfield = (StaticField*)dvmDexGetResolvedField(methodClassDex, ref); \
-        if (sfield == NULL) {                                               \
-            EXPORT_PC();                                                    \
-            sfield = dvmResolveStaticField(curMethod->clazz, ref);          \
-            if (sfield == NULL)                                             \
-                GOTO_exceptionThrown();                                     \
-            if (dvmDexGetResolvedField(methodClassDex, ref) == NULL) {      \
-                JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
-            }                                                               \
-        }                                                                   \
-        SET_REGISTER##_regsize(vdst, dvmGetStaticField##_ftype(sfield));    \
-        ILOGV("+ SGET '%s'=0x%08llx",                                       \
-            sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
-    }                                                                       \
-    FINISH(4);
-
 #define HANDLE_SPUT_X(_opcode, _opname, _ftype, _regsize)                   \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
@@ -1229,29 +1152,6 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
     }                                                                       \
     FINISH(2);
 
-#define HANDLE_SPUT_X_JUMBO(_opcode, _opname, _ftype, _regsize)             \
-    HANDLE_OPCODE(_opcode /*vBBBB, class@AAAAAAAA*/)                        \
-    {                                                                       \
-        StaticField* sfield;                                                \
-        ref = FETCH(1) | (u4)FETCH(2) << 16;   /* field ref */              \
-        vdst = FETCH(3);                                                    \
-        ILOGV("|sput%s/jumbo v%d,sfield@0x%08x", (_opname), vdst, ref);     \
-        sfield = (StaticField*)dvmDexGetResolvedField(methodClassDex, ref); \
-        if (sfield == NULL) {                                               \
-            EXPORT_PC();                                                    \
-            sfield = dvmResolveStaticField(curMethod->clazz, ref);          \
-            if (sfield == NULL)                                             \
-                GOTO_exceptionThrown();                                     \
-            if (dvmDexGetResolvedField(methodClassDex, ref) == NULL) {      \
-                JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
-            }                                                               \
-        }                                                                   \
-        dvmSetStaticField##_ftype(sfield, GET_REGISTER##_regsize(vdst));    \
-        ILOGV("+ SPUT '%s'=0x%08llx",                                       \
-            sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
-    }                                                                       \
-    FINISH(4);
-
 /* File: cstubs/enddefs.cpp */
 
 /* undefine "magic" name remapping */
@@ -1276,6 +1176,8 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
  */
 void dvmMterpDumpArmRegs(uint32_t r0, uint32_t r1, uint32_t r2, uint32_t r3)
 {
+  // TODO: Clang does not support asm declaration syntax.
+#ifndef __clang__
     register uint32_t rPC       asm("r4");
     register uint32_t rFP       asm("r5");
     register uint32_t rSELF     asm("r6");
@@ -1290,6 +1192,7 @@ void dvmMterpDumpArmRegs(uint32_t r0, uint32_t r1, uint32_t r2, uint32_t r3)
     printf("    : rPC=%08x rFP=%08x rSELF=%08x rINST=%08x\n",
         rPC, rFP, rSELF, rINST);
     printf("    : rIBASE=%08x r9=%08x r10=%08x\n", rIBASE, r9, r10);
+#endif
 
     //Thread* self = (Thread*) rSELF;
     //const Method* method = self->method;
diff --git a/vm/mterp/out/InterpC-armv6j.cpp b/vm/mterp/out/InterpC-armv6j.cpp
index 603c35b..b9c2035 100644
--- a/vm/mterp/out/InterpC-armv6j.cpp
+++ b/vm/mterp/out/InterpC-armv6j.cpp
@@ -102,7 +102,7 @@
         {                                                                   \
             char* desc;                                                     \
             desc = dexProtoCopyMethodDescriptor(&curMethod->prototype);     \
-            LOGE("Invalid branch %d at 0x%04x in %s.%s %s",                 \
+            ALOGE("Invalid branch %d at 0x%04x in %s.%s %s",                 \
                 myoff, (int) (pc - curMethod->insns),                       \
                 curMethod->clazz->descriptor, curMethod->name, desc);       \
             free(desc);                                                     \
@@ -128,10 +128,10 @@
         char debugStrBuf[128];                                              \
         snprintf(debugStrBuf, sizeof(debugStrBuf), __VA_ARGS__);            \
         if (curMethod != NULL)                                              \
-            LOG(_level, LOG_TAG"i", "%-2d|%04x%s",                          \
+            ALOG(_level, LOG_TAG"i", "%-2d|%04x%s",                          \
                 self->threadId, (int)(pc - curMethod->insns), debugStrBuf); \
         else                                                                \
-            LOG(_level, LOG_TAG"i", "%-2d|####%s",                          \
+            ALOG(_level, LOG_TAG"i", "%-2d|####%s",                          \
                 self->threadId, debugStrBuf);                               \
     } while(false)
 void dvmDumpRegs(const Method* method, const u4* framePtr, bool inOnly);
@@ -320,15 +320,15 @@ static inline bool checkForNull(Object* obj)
         return false;
     }
 #ifdef WITH_EXTRA_OBJECT_VALIDATION
-    if (!dvmIsHeapAddressObject(obj)) {
-        LOGE("Invalid object %p", obj);
+    if (!dvmIsHeapAddress(obj)) {
+        ALOGE("Invalid object %p", obj);
         dvmAbort();
     }
 #endif
 #ifndef NDEBUG
     if (obj->clazz == NULL || ((u4) obj->clazz) <= 65536) {
         /* probable heap corruption */
-        LOGE("Invalid object class %p (in %p)", obj->clazz, obj);
+        ALOGE("Invalid object class %p (in %p)", obj->clazz, obj);
         dvmAbort();
     }
 #endif
@@ -353,14 +353,14 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
     }
 #ifdef WITH_EXTRA_OBJECT_VALIDATION
     if (!dvmIsHeapAddress(obj)) {
-        LOGE("Invalid object %p", obj);
+        ALOGE("Invalid object %p", obj);
         dvmAbort();
     }
 #endif
 #ifndef NDEBUG
     if (obj->clazz == NULL || ((u4) obj->clazz) <= 65536) {
         /* probable heap corruption */
-        LOGE("Invalid object class %p (in %p)", obj->clazz, obj);
+        ALOGE("Invalid object class %p (in %p)", obj->clazz, obj);
         dvmAbort();
     }
 #endif
@@ -471,9 +471,9 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
         return;                                                             \
     } while(false)
 
-#define GOTO_invoke(_target, _methodCallRange, _jumboFormat)                \
+#define GOTO_invoke(_target, _methodCallRange)                              \
     do {                                                                    \
-        dvmMterp_##_target(self, _methodCallRange, _jumboFormat);           \
+        dvmMterp_##_target(self, _methodCallRange);                         \
         return;                                                             \
     } while(false)
 
@@ -505,14 +505,14 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
 
 /* File: c/opcommon.cpp */
 /* forward declarations of goto targets */
-GOTO_TARGET_DECL(filledNewArray, bool methodCallRange, bool jumboFormat);
-GOTO_TARGET_DECL(invokeVirtual, bool methodCallRange, bool jumboFormat);
-GOTO_TARGET_DECL(invokeSuper, bool methodCallRange, bool jumboFormat);
-GOTO_TARGET_DECL(invokeInterface, bool methodCallRange, bool jumboFormat);
-GOTO_TARGET_DECL(invokeDirect, bool methodCallRange, bool jumboFormat);
-GOTO_TARGET_DECL(invokeStatic, bool methodCallRange, bool jumboFormat);
-GOTO_TARGET_DECL(invokeVirtualQuick, bool methodCallRange, bool jumboFormat);
-GOTO_TARGET_DECL(invokeSuperQuick, bool methodCallRange, bool jumboFormat);
+GOTO_TARGET_DECL(filledNewArray, bool methodCallRange);
+GOTO_TARGET_DECL(invokeVirtual, bool methodCallRange);
+GOTO_TARGET_DECL(invokeSuper, bool methodCallRange);
+GOTO_TARGET_DECL(invokeInterface, bool methodCallRange);
+GOTO_TARGET_DECL(invokeDirect, bool methodCallRange);
+GOTO_TARGET_DECL(invokeStatic, bool methodCallRange);
+GOTO_TARGET_DECL(invokeVirtualQuick, bool methodCallRange);
+GOTO_TARGET_DECL(invokeSuperQuick, bool methodCallRange);
 GOTO_TARGET_DECL(invokeMethod, bool methodCallRange, const Method* methodToCall,
     u2 count, u2 regs);
 GOTO_TARGET_DECL(returnFromMethod);
@@ -1036,33 +1036,6 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
     }                                                                       \
     FINISH(2);
 
-#define HANDLE_IGET_X_JUMBO(_opcode, _opname, _ftype, _regsize)             \
-    HANDLE_OPCODE(_opcode /*vBBBB, vCCCC, class@AAAAAAAA*/)                 \
-    {                                                                       \
-        InstField* ifield;                                                  \
-        Object* obj;                                                        \
-        EXPORT_PC();                                                        \
-        ref = FETCH(1) | (u4)FETCH(2) << 16;   /* field ref */              \
-        vdst = FETCH(3);                                                    \
-        vsrc1 = FETCH(4);                      /* object ptr */             \
-        ILOGV("|iget%s/jumbo v%d,v%d,field@0x%08x",                         \
-            (_opname), vdst, vsrc1, ref);                                   \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
-        if (!checkForNull(obj))                                             \
-            GOTO_exceptionThrown();                                         \
-        ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
-        if (ifield == NULL) {                                               \
-            ifield = dvmResolveInstField(curMethod->clazz, ref);            \
-            if (ifield == NULL)                                             \
-                GOTO_exceptionThrown();                                     \
-        }                                                                   \
-        SET_REGISTER##_regsize(vdst,                                        \
-            dvmGetField##_ftype(obj, ifield->byteOffset));                  \
-        ILOGV("+ IGET '%s'=0x%08llx", ifield->field.name,                   \
-            (u8) GET_REGISTER##_regsize(vdst));                             \
-    }                                                                       \
-    FINISH(5);
-
 #define HANDLE_IGET_X_QUICK(_opcode, _opname, _ftype, _regsize)             \
     HANDLE_OPCODE(_opcode /*vA, vB, field@CCCC*/)                           \
     {                                                                       \
@@ -1107,33 +1080,6 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
     }                                                                       \
     FINISH(2);
 
-#define HANDLE_IPUT_X_JUMBO(_opcode, _opname, _ftype, _regsize)             \
-    HANDLE_OPCODE(_opcode /*vBBBB, vCCCC, class@AAAAAAAA*/)                 \
-    {                                                                       \
-        InstField* ifield;                                                  \
-        Object* obj;                                                        \
-        EXPORT_PC();                                                        \
-        ref = FETCH(1) | (u4)FETCH(2) << 16;   /* field ref */              \
-        vdst = FETCH(3);                                                    \
-        vsrc1 = FETCH(4);                      /* object ptr */             \
-        ILOGV("|iput%s/jumbo v%d,v%d,field@0x%08x",                         \
-            (_opname), vdst, vsrc1, ref);                                   \
-        obj = (Object*) GET_REGISTER(vsrc1);                                \
-        if (!checkForNull(obj))                                             \
-            GOTO_exceptionThrown();                                         \
-        ifield = (InstField*) dvmDexGetResolvedField(methodClassDex, ref);  \
-        if (ifield == NULL) {                                               \
-            ifield = dvmResolveInstField(curMethod->clazz, ref);            \
-            if (ifield == NULL)                                             \
-                GOTO_exceptionThrown();                                     \
-        }                                                                   \
-        dvmSetField##_ftype(obj, ifield->byteOffset,                        \
-            GET_REGISTER##_regsize(vdst));                                  \
-        ILOGV("+ IPUT '%s'=0x%08llx", ifield->field.name,                   \
-            (u8) GET_REGISTER##_regsize(vdst));                             \
-    }                                                                       \
-    FINISH(5);
-
 #define HANDLE_IPUT_X_QUICK(_opcode, _opname, _ftype, _regsize)             \
     HANDLE_OPCODE(_opcode /*vA, vB, field@CCCC*/)                           \
     {                                                                       \
@@ -1183,29 +1129,6 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
     }                                                                       \
     FINISH(2);
 
-#define HANDLE_SGET_X_JUMBO(_opcode, _opname, _ftype, _regsize)             \
-    HANDLE_OPCODE(_opcode /*vBBBB, class@AAAAAAAA*/)                        \
-    {                                                                       \
-        StaticField* sfield;                                                \
-        ref = FETCH(1) | (u4)FETCH(2) << 16;   /* field ref */              \
-        vdst = FETCH(3);                                                    \
-        ILOGV("|sget%s/jumbo v%d,sfield@0x%08x", (_opname), vdst, ref);     \
-        sfield = (StaticField*)dvmDexGetResolvedField(methodClassDex, ref); \
-        if (sfield == NULL) {                                               \
-            EXPORT_PC();                                                    \
-            sfield = dvmResolveStaticField(curMethod->clazz, ref);          \
-            if (sfield == NULL)                                             \
-                GOTO_exceptionThrown();                                     \
-            if (dvmDexGetResolvedField(methodClassDex, ref) == NULL) {      \
-                JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
-            }                                                               \
-        }                                                                   \
-        SET_REGISTER##_regsize(vdst, dvmGetStaticField##_ftype(sfield));    \
-        ILOGV("+ SGET '%s'=0x%08llx",                                       \
-            sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
-    }                                                                       \
-    FINISH(4);
-
 #define HANDLE_SPUT_X(_opcode, _opname, _ftype, _regsize)                   \
     HANDLE_OPCODE(_opcode /*vAA, field@BBBB*/)                              \
     {                                                                       \
@@ -1229,29 +1152,6 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
     }                                                                       \
     FINISH(2);
 
-#define HANDLE_SPUT_X_JUMBO(_opcode, _opname, _ftype, _regsize)             \
-    HANDLE_OPCODE(_opcode /*vBBBB, class@AAAAAAAA*/)                        \
-    {                                                                       \
-        StaticField* sfield;                                                \
-        ref = FETCH(1) | (u4)FETCH(2) << 16;   /* field ref */              \
-        vdst = FETCH(3);                                                    \
-        ILOGV("|sput%s/jumbo v%d,sfield@0x%08x", (_opname), vdst, ref);     \
-        sfield = (StaticField*)dvmDexGetResolvedField(methodClassDex, ref); \
-        if (sfield == NULL) {                                               \
-            EXPORT_PC();                                                    \
-            sfield = dvmResolveStaticField(curMethod->clazz, ref);          \
-            if (sfield == NULL)                                             \
-                GOTO_exceptionThrown();                                     \
-            if (dvmDexGetResolvedField(methodClassDex, ref) == NULL) {      \
-                JIT_STUB_HACK(dvmJitEndTraceSelect(self,pc));               \
-            }                                                               \
-        }                                                                   \
-        dvmSetStaticField##_ftype(sfield, GET_REGISTER##_regsize(vdst));    \
-        ILOGV("+ SPUT '%s'=0x%08llx",                                       \
-            sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
-    }                                                                       \
-    FINISH(4);
-
 /* File: cstubs/enddefs.cpp */
 
 /* undefine "magic" name remapping */
@@ -1276,6 +1176,8 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
  */
 void dvmMterpDumpArmRegs(uint32_t r0, uint32_t r1, uint32_t r2, uint32_t r3)
 {
+  // TODO: Clang does not support asm declaration syntax.
+#ifndef __clang__
     register uint32_t rPC       asm("r4");
     register uint32_t rFP       asm("r5");
     register uint32_t rSELF     asm("r6");
@@ -1290,6 +1192,7 @@ void dvmMterpDumpArmRegs(uint32_t r0, uint32_t r1, uint32_t r2, uint32_t r3)
     printf("    : rPC=%08x rFP=%08x rSELF=%08x rINST=%08x\n",
         rPC, rFP, rSELF, rINST);
     printf("    : rIBASE=%08x r9=%08x r10=%08x\n", rIBASE, r9, r10);
+#endif
 
     //Thread* self = (Thread*) rSELF;
     //const Method* method = self->method;
-- 
1.7.10
